From f123a275a38ce72e0d97b22386a7ac82cb6b81f3 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 10 Jan 2011 12:36:14 -0600
Subject: [PATCH] port of u-boot for am3517crane

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 Makefile                                  |    9 +-
 board/ti/am3517crane/Makefile             |   47 +
 board/ti/am3517crane/am3517crane.c        |  146 +++
 board/ti/am3517crane/am3517crane.h        |  339 ++++++
 board/ti/am3517crane/config.mk            |   29 +
 board/ti/am3517evm/Makefile               |   47 +
 board/ti/am3517evm/am3517evm.c            |  130 ++
 board/ti/am3517evm/am3517evm.h            |  400 +++++++
 board/ti/am3517evm/config.mk              |   29 +
 board/ti/evm/evm.c                        |   63 +-
 board/ti/evm/evm.h                        |   14 +
 common/Makefile                           |    1 +
 common/cmd_readmacid.c                    |   51 +
 common/cmd_usb.c                          |   20 +-
 common/usb.c                              |   35 +-
 common/usb_kbd.c                          |   22 +-
 common/usb_storage.c                      |   16 +-
 cpu/arm_cortexa8/omap3/Makefile           |    6 +
 cpu/arm_cortexa8/omap3/board.c            |   36 +-
 cpu/arm_cortexa8/omap3/cache.S            |   35 +-
 cpu/arm_cortexa8/omap3/clock.c            |  587 +++++++---
 cpu/arm_cortexa8/omap3/emif4.c            |  161 +++
 cpu/arm_cortexa8/omap3/lowlevel_init.S    |   51 +
 cpu/arm_cortexa8/omap3/mem.c              |   69 --
 cpu/arm_cortexa8/omap3/sdrc.c             |  174 +++
 cpu/arm_cortexa8/omap3/sys_info.c         |  261 +++--
 cpu/ppc4xx/usbdev.c                       |    4 +-
 drivers/mmc/omap3_mmc.c                   |    2 +
 drivers/net/davinci_emac.c                |  113 ++-
 drivers/net/davinci_emac.h                |  304 +++++
 drivers/serial/usbtty.h                   |    2 +
 drivers/usb/host/ehci-hcd.c               |    2 +-
 drivers/usb/musb/Makefile                 |    3 +
 drivers/usb/musb/am3517.c                 |  126 ++
 drivers/usb/musb/am3517.h                 |   97 ++
 drivers/usb/musb/davinci.c                |    1 +
 drivers/usb/musb/musb_core.c              |   37 +-
 drivers/usb/musb/musb_core.h              |   50 +-
 drivers/usb/musb/musb_debug.h             |  205 ++++
 drivers/usb/musb/musb_hcd.c               |    2 +-
 drivers/usb/musb/musb_udc.c               |  966 +++++++++++++++
 drivers/usb/musb/omap3.c                  |  141 +++
 drivers/usb/musb/omap3.h                  |   56 +
 drivers/usb/phy/Makefile                  |   44 +
 drivers/usb/phy/twl4030.c                 |  189 +++
 include/asm-arm/arch-davinci/emac_defs.h  |  260 +----
 include/asm-arm/arch-omap3/clocks.h       |   23 +
 include/asm-arm/arch-omap3/clocks_omap3.h |   32 +-
 include/asm-arm/arch-omap3/cpu.h          |   32 +-
 include/asm-arm/arch-omap3/emac_defs.h    |   56 +
 include/asm-arm/arch-omap3/emif4.h        |   76 ++
 include/asm-arm/arch-omap3/mem.h          |   69 ++-
 include/asm-arm/arch-omap3/mux.h          |   36 +
 include/asm-arm/arch-omap3/omap3.h        |   46 +-
 include/asm-arm/arch-omap3/omap3_flash.h  |   34 +
 include/asm-arm/arch-omap3/omap_gpmc.h    |    5 +
 include/asm-arm/arch-omap3/sys_proto.h    |   11 +-
 include/asm-arm/mach-types.h              | 1829 ++++++++++++++++++++++++++++-
 include/configs/am3517_crane.h            |  352 ++++++
 include/configs/am3517_evm.h              |  350 ++++++
 include/configs/omap3_beagle.h            |   20 +-
 include/configs/omap3_evm.h               |   70 +-
 include/configs/omap3_overo.h             |   22 +-
 include/configs/omap3_pandora.h           |   20 +-
 include/configs/omap3_sdp3430.h           |   19 +-
 include/configs/omap3_zoom1.h             |   21 +-
 include/configs/omap3_zoom2.h             |   21 +-
 include/twl4030.h                         |  143 ++-
 include/usb.h                             |   73 +-
 include/usb/musb_udc.h                    |   54 +
 include/usbdescriptors.h                  |   26 +
 include/usbdevice.h                       |  103 ++
 lib_arm/board.c                           |    1 +
 net/tftp.c                                |    7 +-
 74 files changed, 8079 insertions(+), 854 deletions(-)
 create mode 100644 board/ti/am3517crane/Makefile
 create mode 100644 board/ti/am3517crane/am3517crane.c
 create mode 100644 board/ti/am3517crane/am3517crane.h
 create mode 100644 board/ti/am3517crane/config.mk
 create mode 100644 board/ti/am3517evm/Makefile
 create mode 100644 board/ti/am3517evm/am3517evm.c
 create mode 100644 board/ti/am3517evm/am3517evm.h
 create mode 100644 board/ti/am3517evm/config.mk
 create mode 100644 common/cmd_readmacid.c
 create mode 100644 cpu/arm_cortexa8/omap3/emif4.c
 create mode 100644 cpu/arm_cortexa8/omap3/sdrc.c
 create mode 100644 drivers/net/davinci_emac.h
 create mode 100644 drivers/usb/musb/am3517.c
 create mode 100644 drivers/usb/musb/am3517.h
 create mode 100644 drivers/usb/musb/musb_debug.h
 create mode 100644 drivers/usb/musb/musb_udc.c
 create mode 100644 drivers/usb/musb/omap3.c
 create mode 100644 drivers/usb/musb/omap3.h
 create mode 100644 drivers/usb/phy/Makefile
 create mode 100644 drivers/usb/phy/twl4030.c
 create mode 100644 include/asm-arm/arch-omap3/emac_defs.h
 create mode 100644 include/asm-arm/arch-omap3/emif4.h
 create mode 100644 include/asm-arm/arch-omap3/omap3_flash.h
 create mode 100644 include/configs/am3517_crane.h
 create mode 100644 include/configs/am3517_evm.h
 create mode 100644 include/usb/musb_udc.h

diff --git a/Makefile b/Makefile
index f06a97c..85413ff 100644
--- a/Makefile
+++ b/Makefile
@@ -243,12 +243,14 @@ LIBS += drivers/twserial/libtws.a
 LIBS += drivers/usb/gadget/libusb_gadget.a
 LIBS += drivers/usb/host/libusb_host.a
 LIBS += drivers/usb/musb/libusb_musb.a
+LIBS += drivers/usb/phy/libusb_phy.a
 LIBS += drivers/video/libvideo.a
 LIBS += drivers/watchdog/libwatchdog.a
 LIBS += common/libcommon.a
 LIBS += libfdt/libfdt.a
 LIBS += api/libapi.a
 LIBS += post/libpost.a
+#LIBS += ../itbok/libitbok.a
 
 LIBS := $(addprefix $(obj),$(LIBS))
 .PHONY : $(LIBS) $(TIMESTAMP_FILE) $(VERSION_FILE)
@@ -3143,7 +3145,6 @@ SMN42_config	:	unconfig
 #########################################################################
 ## ARM CORTEX Systems
 #########################################################################
-
 devkit8000_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 devkit8000 timll omap3
 
@@ -3156,6 +3157,12 @@ omap3_overo_config :	unconfig
 omap3_evm_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 evm ti omap3
 
+am3517_crane_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 am3517crane ti omap3
+
+am3517_evm_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 am3517evm ti omap3
+
 omap3_pandora_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 pandora NULL omap3
 
diff --git a/board/ti/am3517crane/Makefile b/board/ti/am3517crane/Makefile
new file mode 100644
index 0000000..021602e
--- /dev/null
+++ b/board/ti/am3517crane/Makefile
@@ -0,0 +1,47 @@
+#
+# Author: Srinath.R <srinath@mistralsolutions.com>
+#
+# Based on ti/am3517evm/Makefile
+#
+# Copyright (C) 2010 Mistral Solutions Pvt Ltd
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= am3517crane.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
diff --git a/board/ti/am3517crane/am3517crane.c b/board/ti/am3517crane/am3517crane.c
new file mode 100644
index 0000000..2f525b6
--- /dev/null
+++ b/board/ti/am3517crane/am3517crane.c
@@ -0,0 +1,146 @@
+/*
+ * am3517crane.c - board file for AM3517/05 Craneboard.
+ *
+ * Author: Srinath.R <srinath@mistralsolutions.com>
+ *
+ * Based on ti/am3517evm/am3517evm.c
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/emac_defs.h>
+#include <asm/arch/gpio.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "am3517crane.h"
+
+
+#if defined(CONFIG_DRIVER_TI_EMAC)
+#define AM3517_IP_SW_RESET	0x48002598
+#define CPGMACSS_SW_RST		(1 << 1)
+#define ETHERNET_NRST		34
+#define EMACID_ADDR_LSB 	0x48002380
+#define EMACID_ADDR_MSB 	0x48002384
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Routine: board_init
+ * Description: Early hardware init.
+ */
+int board_init(void)
+{
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_CRANEBOARD;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/*
+ * Routine: misc_init_r
+ * Description: Init ethernet (done here so udelay works)
+ */
+int misc_init_r(void)
+{
+	u32 ctr;
+	u32 reset;
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+	dieid_num_r();
+#if defined(CONFIG_DRIVER_TI_EMAC)
+	omap_request_gpio(ETHERNET_NRST);
+	omap_set_gpio_direction(ETHERNET_NRST, 0);
+	omap_set_gpio_dataout(ETHERNET_NRST, 0);
+	ctr  = 0;
+	do {
+		udelay(1000);
+		ctr++;
+		} while (ctr < 300);
+	omap_set_gpio_dataout(ETHERNET_NRST, 1);
+	ctr = 0;
+	/* allow the PHY to stabilize and settle down */
+	do {
+		udelay(1000);
+		ctr++;
+		} while (ctr < 300);
+
+	/*ensure that the module is out of reset*/
+	reset = readl(AM3517_IP_SW_RESET);
+	reset &= (~CPGMACSS_SW_RST);
+	writel(reset, AM3517_IP_SW_RESET);
+#endif
+	return 0;
+}
+
+/*
+ * Initializes on-chip ethernet controllers.
+ * to override, implement board_eth_init()
+ */
+int cpu_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_DRIVER_TI_EMAC)
+	char mac_buf_lsb[8];
+	char mac_buf_msb[16];
+	char mac_id[24];
+	const unsigned char separator = ':';
+
+	printf("davinci_emac_initialize\n");
+	davinci_emac_initialize();
+
+	memset(mac_buf_lsb, '\0', sizeof(mac_buf_lsb));
+	memset(mac_buf_msb, '\0', sizeof(mac_buf_msb));
+	memset(mac_id, '\0', sizeof(mac_id));
+
+	sprintf(mac_buf_msb, "%x", readl(EMACID_ADDR_MSB));
+	sprintf(mac_buf_lsb, "%x", readl(EMACID_ADDR_LSB));
+	strcat(mac_buf_msb, mac_buf_lsb);
+	sprintf(mac_id, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",
+			mac_buf_msb[0], mac_buf_msb[1], separator,
+			mac_buf_msb[2], mac_buf_msb[3], separator,
+			mac_buf_msb[4], mac_buf_msb[5], separator,
+			mac_buf_msb[6], mac_buf_msb[7], separator,
+			mac_buf_msb[8], mac_buf_msb[9], separator,
+			mac_buf_msb[10], mac_buf_msb[11]);
+
+	printf("EMAC ID %s\n", mac_id);
+	setenv("ethaddr", mac_id);
+#endif
+	return 0;
+}
+
+/*
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ */
+void set_muxconf_regs(void)
+{
+	MUX_AM3517CRANE();
+}
diff --git a/board/ti/am3517crane/am3517crane.h b/board/ti/am3517crane/am3517crane.h
new file mode 100644
index 0000000..ffb2b0a
--- /dev/null
+++ b/board/ti/am3517crane/am3517crane.h
@@ -0,0 +1,339 @@
+/*
+ * am3517crane.h - Header file for the AM3517/05 Craneboard.
+ *
+ * Author: Srinath R <srinath@mistralsolutions.com>
+ *
+ * Based on ti/am3517evm/am3517evm.h
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AM3517CRANE_H_
+#define _AM3517CRANE_H_
+
+const omap3_sysinfo sysinfo = {
+	DDR_DISCRETE,
+	"Craneboard",
+	"NAND",
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_AM3517CRANE() \
+ /* SDRC */\
+	MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_CKE0),		(M0)) \
+	MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS0N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS1N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS2N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS3N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(STRBEN_DLY0),	(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(STRBEN_DLY1),	(IEN  | PTD | EN  | M0)) \
+/* GPMC */\
+	/* GPIO_34 ETHERNET_nRST */ \
+	MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M4)) \
+	/* GPIO_35 USB1_HOST_EN */ \
+	MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | DIS | M4)) \
+	/* GPIO_36 USB0_OVER_CURRENT*/ \
+	MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M4)) \
+	/* GPIO_37 USB1_OVER_CURRENT */ \
+	MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M4)) \
+	/* GPIO_38 USB3320_RESET# */ \
+	MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M4)) \
+	MUX_VAL(CP(GPMC_A6),		(M7)) \
+	/* GPIO_40 MMC1_WP */ \
+	MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M4)) \
+	/* GPIO_41 MMC1_CD */ \
+	MUX_VAL(CP(GPMC_A8),		(IEN  | PTU | EN  | M4)) \
+	MUX_VAL(CP(GPMC_A9),		(M7)) \
+	MUX_VAL(CP(GPMC_A10),		(M7)) \
+	MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) \
+	/* GPIO_52 DVI_LCD_PD */ \
+	MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M4)) \
+	MUX_VAL(CP(GPMC_NCS2),		(M7)) \
+	MUX_VAL(CP(GPMC_NCS3),		(M7)) \
+	MUX_VAL(CP(GPMC_NCS4),		(M7)) \
+	MUX_VAL(CP(GPMC_NCS5),		(M7)) \
+	MUX_VAL(CP(GPMC_NCS6),		(M7)) \
+	MUX_VAL(CP(GPMC_NCS7),		(M7)) \
+	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTU | EN  | M0)) /* TP */ \
+	MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NBE1),		(M7)) \
+	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_WAIT0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_WAIT1),		(M7)) \
+	MUX_VAL(CP(GPMC_WAIT2),		(M7)) \
+	MUX_VAL(CP(GPMC_WAIT3),		(M7)) \
+/* DSS */\
+	MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_ACBIAS),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA10),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA11),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA12),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA13),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA14),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA15),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA16),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA17),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA18),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA19),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA20),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA21),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA22),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA23),		(IDIS | PTD | DIS | M0)) \
+ /* CCDC */\
+	MUX_VAL(CP(CCDC_PCLK),		(IEN  | PTU | EN  | M0)) \
+	/* CCDC_DATA8 */ \
+	MUX_VAL(CP(CCDC_FIELD),		(IEN  | PTD | DIS | M1)) \
+	MUX_VAL(CP(CCDC_HD),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CCDC_VD),		(IEN  | PTU | EN  | M0)) \
+	/* CCDC_DATA9 */ \
+	MUX_VAL(CP(CCDC_WEN),		(IEN  | PTD | DIS | M1)) \
+	MUX_VAL(CP(CCDC_DATA0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA7),		(IEN  | PTD | DIS | M0)) \
+ /* RMII */\
+	MUX_VAL(CP(RMII_MDIO_DATA),	(IEN  |  M0)) \
+	MUX_VAL(CP(RMII_MDIO_CLK),	(M0)) \
+	MUX_VAL(CP(RMII_RXD0)	,	(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_RXD1),		(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_CRS_DV),	(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_RXER),		(PTD  | M0)) \
+	MUX_VAL(CP(RMII_TXD0),		(PTD  | M0)) \
+	MUX_VAL(CP(RMII_TXD1),		(PTD  | M0)) \
+	MUX_VAL(CP(RMII_TXEN),		(PTD  | M0)) \
+	MUX_VAL(CP(RMII_50MHZ_CLK),	(IEN  | PTD | EN  | M0)) \
+ /* McBSP2 */\
+	MUX_VAL(CP(MCBSP2_FSX),		(M7)) \
+	MUX_VAL(CP(MCBSP2_CLKX),	(M7)) \
+	MUX_VAL(CP(MCBSP2_DR),		(M7)) \
+	MUX_VAL(CP(MCBSP2_DX),		(M7)) \
+ /* MMC1 */\
+	MUX_VAL(CP(MMC1_CLK),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | DIS | M0)) \
+ /* MMC2 */\
+	MUX_VAL(CP(MMC2_CLK),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(MMC2_CMD),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTD | DIS | M0)) \
+ /* McBSP3 */\
+	MUX_VAL(CP(MCBSP3_DX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_FSX),		(IEN  | PTD | DIS | M0)) \
+ /* UART2 */\
+	MUX_VAL(CP(UART2_CTS),		(M7)) \
+	MUX_VAL(CP(UART2_RTS),		(M7)) \
+	MUX_VAL(CP(UART2_TX),		(M7)) \
+	MUX_VAL(CP(UART2_RX),		(M7)) \
+ /* UART1 */\
+	MUX_VAL(CP(UART1_TX),		(M7)) \
+	MUX_VAL(CP(UART1_RTS),		(M7)) \
+	MUX_VAL(CP(UART1_CTS),		(M7)) \
+	MUX_VAL(CP(UART1_RX),		(M7)) \
+	MUX_VAL(CP(MCBSP4_CLKX),	(M7)) \
+	MUX_VAL(CP(MCBSP4_DR),		(M7)) \
+	MUX_VAL(CP(MCBSP4_DX),		(M7)) \
+	MUX_VAL(CP(MCBSP4_FSX),		(M7)) \
+ /* McBSP1 */ \
+	MUX_VAL(CP(MCBSP_CLKS),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_CLKR),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_FSR),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_DR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_FSX),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_CLKX),	(IEN  | PTD | DIS | M0)) \
+ /* UART3 */\
+	MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) \
+ /* HSUSB */\
+	MUX_VAL(CP(USB0_DRVBUS),	(IEN  | PTD | EN  | M0)) \
+ /* HECC */\
+	MUX_VAL(CP(HECC1_TXD),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(HECC1_RXD),		(IEN  | PTU | EN  | M0)) \
+ /* I2C 1, 2, 3 */\
+	MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) \
+ /* HDQ */\
+	/* GPIO_170 TP */ \
+	MUX_VAL(CP(HDQ_SIO),		(IEN  | PTU | EN  | M4)) \
+	/* McSPI1 */\
+	/* GPIO_171 TP */ \
+	MUX_VAL(CP(MCSPI1_CLK),		(IEN  | PTU | EN  | M4)) \
+	/* GPIO_172 TP */ \
+	MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) \
+	/* GPIO_173 TP */ \
+	MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTU | EN  | M4)) \
+	 /* GPIO_174 TP */ \
+	MUX_VAL(CP(MCSPI1_CS0),		(IEN  | PTU | EN  | M4)) \
+	/* GPIO_175 TP */ \
+	MUX_VAL(CP(MCSPI1_CS1),		(IEN  | PTU | EN  | M4)) \
+	/* GPIO_176 TP*/ \
+	MUX_VAL(CP(MCSPI1_CS2),		(IEN  | PTU | EN  | M4)) \
+	 /* GPIO_176 TP*/ \
+	MUX_VAL(CP(MCSPI1_CS3),		(IEN  | PTD | EN  | M4)) \
+ /* McSPI2 */\
+	MUX_VAL(CP(MCSPI2_CLK),		(M7)) \
+	MUX_VAL(CP(MCSPI2_SIMO),	(M7)) \
+	MUX_VAL(CP(MCSPI2_SOMI),	(M7)) \
+	MUX_VAL(CP(MCSPI2_CS0),		(M7)) \
+	MUX_VAL(CP(MCSPI2_CS1),		(M7)) \
+	MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M0)) \
+ /* ETK (ES2 onwards) */\
+	MUX_VAL(CP(ETK_CLK_ES2),	(IEN  | PTU | EN  | M3)) \
+	MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D0_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D1_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D2_ES2),		(IEN  | PTD | EN  | M3)) \
+	MUX_VAL(CP(ETK_D3_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D4_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D5_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D6_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D7_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D8_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D9_ES2),		(IEN  | PTD | DIS | M3)) \
+	MUX_VAL(CP(ETK_D10_ES2),	(M7)) \
+	MUX_VAL(CP(ETK_D11_ES2),	(M7)) \
+	MUX_VAL(CP(ETK_D12_ES2),	(M7)) \
+	MUX_VAL(CP(ETK_D13_ES2),	(M7)) \
+	MUX_VAL(CP(ETK_D14_ES2),	(M7)) \
+	MUX_VAL(CP(ETK_D15_ES2),	(M7)) \
+	MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) \
+	/* GPIO_1 TPS_SLEEP */ \
+	MUX_VAL(CP(SYS_CLKREQ),		(IEN  | PTD | DIS | M4)) \
+	/* GPIO_30 TO Exp */ \
+	MUX_VAL(CP(SYS_NRESWARM),     	(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_BOOT7),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SYS_BOOT8),		(IEN  | PTD | EN  | M0)) \
+	/* GPIO_10 TP */ \
+	MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M4)) \
+ /* JTAG */ \
+	MUX_VAL(CP(JTAG_nTRST),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TCK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TMS),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TDI),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_EMU0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_EMU1),		(IEN  | PTD | DIS | M0)) \
+
+#endif /* _AM3517CRANE_H_ */
diff --git a/board/ti/am3517crane/config.mk b/board/ti/am3517crane/config.mk
new file mode 100644
index 0000000..529edb5
--- /dev/null
+++ b/board/ti/am3517crane/config.mk
@@ -0,0 +1,29 @@
+#
+# Author: Srinath.R <srinath@mistralsolutions.com>
+#
+# Based on ti/am3517evm/config.mk
+#
+# Copyright (C) 2010 Mistral Solutions Pvt Ltd
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff --git a/board/ti/am3517evm/Makefile b/board/ti/am3517evm/Makefile
new file mode 100644
index 0000000..87712f8
--- /dev/null
+++ b/board/ti/am3517evm/Makefile
@@ -0,0 +1,47 @@
+#
+# Author: Vaibhav Hiremath <hvaibhav@ti.com>
+#
+# Based on ti/evm/Makefile
+#
+# Copyright (C) 2009 Texas Instruments Incorporated
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= am3517evm.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
diff --git a/board/ti/am3517evm/am3517evm.c b/board/ti/am3517evm/am3517evm.c
new file mode 100644
index 0000000..8ca6342
--- /dev/null
+++ b/board/ti/am3517evm/am3517evm.c
@@ -0,0 +1,130 @@
+/*
+ * am3517evm.c - board file for TI's AM3517 family of devices.
+ *
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Based on ti/evm/evm.c
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/emac_defs.h>
+#include <asm/arch/gpio.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "am3517evm.h"
+
+
+#define AM3517_IP_SW_RESET	0x48002598
+#define CPGMACSS_SW_RST		(1 << 1)
+
+
+
+/*
+ * Routine: board_init
+ * Description: Early hardware init.
+ */
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3517EVM;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/*
+ * Routine: misc_init_r
+ * Description: Init ethernet (done here so udelay works)
+ */
+int misc_init_r(void)
+{
+	volatile unsigned int ctr;
+	u32 reset;
+
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+	dieid_num_r();
+
+
+#if defined(CONFIG_DRIVER_TI_EMAC)
+
+	omap_request_gpio(30);
+	omap_set_gpio_direction(30,0);
+	omap_set_gpio_dataout(30,0);
+	ctr  = 0;
+	do{
+		udelay(1000);
+		ctr++;
+		}while (ctr <300);
+	omap_set_gpio_dataout(30,1);
+	ctr =0;
+	/* allow the PHY to stabilize and settle down */
+	do{
+		udelay(1000);
+		ctr++;
+		}while (ctr <300);
+
+	/*ensure that the module is out of reset*/
+	reset = readl(AM3517_IP_SW_RESET);
+	reset &= (~CPGMACSS_SW_RST);
+	writel(reset,AM3517_IP_SW_RESET);
+
+#endif
+
+
+	return 0;
+}
+
+
+/*
+ * Initializes on-chip ethernet controllers.
+ * to override, implement board_eth_init()
+ */
+int cpu_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_DRIVER_TI_EMAC)
+	printf("davinci_emac_initialize\n");
+	davinci_emac_initialize();
+#endif
+	return 0;
+ }
+
+
+/*
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ */
+void set_muxconf_regs(void)
+{
+	MUX_AM3517EVM();
+}
diff --git a/board/ti/am3517evm/am3517evm.h b/board/ti/am3517evm/am3517evm.h
new file mode 100644
index 0000000..ce7aeaf
--- /dev/null
+++ b/board/ti/am3517evm/am3517evm.h
@@ -0,0 +1,400 @@
+/*
+ * am3517evm.h - Header file for the AM3517 EVM.
+ *
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Based on ti/evm/evm.h
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AM3517EVM_H_
+#define _AM3517EVM_H_
+
+const omap3_sysinfo sysinfo = {
+	DDR_DISCRETE,
+	"AM3517EVM Board",
+	"NAND",
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_AM3517EVM() \
+	/* SDRC */\
+	MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SDRC_DQS0N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS1N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS2N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_DQS3N),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SDRC_CKE0),		(M0)) \
+	MUX_VAL(CP(SDRC_CKE1),		(M0)) \
+	MUX_VAL(CP(STRBEN_DLY0),	(IEN  | PTD | EN  | M0)) /*sdrc_strben_dly0*/\
+	MUX_VAL(CP(STRBEN_DLY1),	(IEN  | PTD | EN  | M0)) /*sdrc_strben_dly1*/\
+	/* GPMC */\
+	MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A6),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A8),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A9),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_A10),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS4),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(GPMC_WAIT0),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_WAIT1),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(GPMC_WAIT2),		(IEN  | PTU | EN  | M4)) /*GPIO_64*/\
+							 /* - ETH_nRESET*/\
+	MUX_VAL(CP(GPMC_WAIT3),		(IEN  | PTU | EN  | M0)) \
+	/* DSS */\
+	MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_ACBIAS),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA10),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA11),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA12),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA13),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA14),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA15),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA16),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA17),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA18),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA19),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA20),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA21),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA22),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(DSS_DATA23),		(IDIS | PTD | DIS | M0)) \
+	/* CAMERA */\
+	MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+							 /* - CAM_RESET*/\
+	MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+	MUX_VAL(CP(CAM_STROBE),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) \
+	/* MMC */\
+	MUX_VAL(CP(MMC1_CLK),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M4)) /* WriteProtect */\
+	MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M4)) /* CardDetect*/\
+	MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M4)) \
+	MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M4)) \
+	\
+	MUX_VAL(CP(MMC2_CLK),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(MMC2_CMD),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTD | DIS | M0)) \
+	/* McBSP */\
+	MUX_VAL(CP(MCBSP_CLKS),		(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_CLKR),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_FSR),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_DR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_FSX),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP1_CLKX),	(IEN  | PTD | DIS | M0)) \
+	\
+	MUX_VAL(CP(MCBSP2_FSX),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) \
+	\
+	MUX_VAL(CP(MCBSP3_DX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCBSP3_FSX),		(IEN  | PTD | DIS | M0)) \
+	\
+	MUX_VAL(CP(MCBSP4_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_152*/\
+							 /* - LCD_INI*/\
+	MUX_VAL(CP(MCBSP4_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_153*/\
+							 /* - LCD_ENVDD */\
+	MUX_VAL(CP(MCBSP4_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_154*/\
+							 /* - LCD_QVGA/nVGA */\
+	MUX_VAL(CP(MCBSP4_FSX),		(IDIS | PTD | DIS | M4)) /*GPIO_155*/\
+							 /* - LCD_RESB */\
+	/* UART */\
+	MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0)) \
+	\
+	MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M0)) \
+	\
+	MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTU | DIS | M0)) \
+	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) \
+	/* I2C */\
+	MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) \
+	/* McSPI */\
+	MUX_VAL(CP(MCSPI1_CLK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI1_CS0),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(MCSPI1_CS1),		(IEN  | PTD | EN  | M4)) /*GPIO_175*/\
+	MUX_VAL(CP(MCSPI1_CS2),		(IEN  | PTU | DIS | M4)) /*GPIO_176*/\
+							 /* - LAN_INTR*/\
+	MUX_VAL(CP(MCSPI1_CS3),		(IEN  | PTD | EN  | M0)) \
+	\
+	MUX_VAL(CP(MCSPI2_CLK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(MCSPI2_CS0),		(IEN  | PTD | EN  | M4)) \
+	MUX_VAL(CP(MCSPI2_CS1),		(IEN  | PTD | EN  | M4)) \
+	/* CCDC */\
+	MUX_VAL(CP(CCDC_PCLK),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CCDC_FIELD),		(IEN  | PTD | DIS | M1)) \
+	MUX_VAL(CP(CCDC_HD),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CCDC_VD),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(CCDC_WEN),		(IEN  | PTD | DIS | M1)) \
+	MUX_VAL(CP(CCDC_DATA0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA1),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA2),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA3),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA4),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA5),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA6),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(CCDC_DATA7),		(IEN  | PTD | DIS | M0)) \
+	/* RMII */\
+	MUX_VAL(CP(RMII_MDIO_DATA),	(IEN  |  M0)) \
+	MUX_VAL(CP(RMII_MDIO_CLK),	(M0)) \
+	MUX_VAL(CP(RMII_RXD0)	,	(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_RXD1),		(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_CRS_DV),	(IEN  | PTD | M0)) \
+	MUX_VAL(CP(RMII_RXER),		(PTD | M0)) \
+	MUX_VAL(CP(RMII_TXD0),		(PTD | M0)) \
+	MUX_VAL(CP(RMII_TXD1),		(PTD | M0)) \
+	MUX_VAL(CP(RMII_TXEN),		(PTD | M0)) \
+	MUX_VAL(CP(RMII_50MHZ_CLK),	(IEN  | PTD | EN  | M0)) \
+	/* HECC */\
+	MUX_VAL(CP(HECC1_TXD),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(HECC1_RXD),		(IEN  | PTU | EN  | M0)) \
+	/* HSUSB */\
+	MUX_VAL(CP(HSUSB0_CLK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_STP),		(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(HSUSB0_DIR),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_NXT),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(USB0_DRVBUS),	(IEN  | PTD | EN  | M0)) \
+	/* HDQ */\
+	MUX_VAL(CP(HDQ_SIO),		(IEN  | PTU | EN  | M0)) \
+	/* Control and debug */\
+	MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_CLKREQ),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(SYS_NRESWARM),     	(IDIS | PTU | DIS | M4)) /*SYS_nRESWARM */\
+							/* - GPIO30 */\
+	MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+							 /* - PEN_IRQ */\
+	MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3 */\
+	MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4*/\
+	MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+	MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+	MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+	MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/\
+							 /* - VIO_1V8*/\
+	MUX_VAL(CP(SYS_BOOT7),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(SYS_BOOT8),		(IEN  | PTD | EN  | M0)) \
+	\
+	MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M0)) \
+	/* JTAG */\
+	MUX_VAL(CP(JTAG_nTRST),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TCK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TMS),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_TDI),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_EMU0),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(JTAG_EMU1),		(IEN  | PTD | DIS | M0)) \
+	/* ETK (ES2 onwards) */\
+	MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M0)) \
+	MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D0_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D1_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D2_ES2 ),	(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(ETK_D3_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D4_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D5_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D6_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D7_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D8_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D9_ES2 ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D10_ES2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D11_ES2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | DIS | M0)) \
+	/* Die to Die */\
+	MUX_VAL(CP(D2D_MCAD34),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_MCAD35),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_MCAD36),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GTDI),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GTDO),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GTMS),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GTCK),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_MSTDBY),		(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) \
+	MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) \
+	MUX_VAL(CP(D2D_MWRITE),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_SWRITE),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) \
+	MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) \
+
+#endif
diff --git a/board/ti/am3517evm/config.mk b/board/ti/am3517evm/config.mk
new file mode 100644
index 0000000..7b2951f
--- /dev/null
+++ b/board/ti/am3517evm/config.mk
@@ -0,0 +1,29 @@
+#
+# Author: Vaibhav Hiremath <hvaibhav@ti.com>
+#
+# Based on ti/evm/config.mk
+#
+# Copyright (C) 2009 Texas Instruments Incorporated
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff --git a/board/ti/evm/evm.c b/board/ti/evm/evm.c
index 0718a08..edfe4bb 100644
--- a/board/ti/evm/evm.c
+++ b/board/ti/evm/evm.c
@@ -30,13 +30,41 @@
 #include <common.h>
 #include <netdev.h>
 #include <asm/io.h>
+#include <asm/mach-types.h>
 #include <asm/arch/mem.h>
 #include <asm/arch/mux.h>
+#include <asm/arch/omap_gpmc.h>
 #include <asm/arch/sys_proto.h>
 #include <i2c.h>
-#include <asm/mach-types.h>
 #include "evm.h"
 
+static u8 omap3_evm_version;
+
+u8 get_omap3_evm_rev(void)
+{
+	return omap3_evm_version;
+}
+
+static void omap3_evm_get_revision(void)
+{
+	unsigned int smsc_id;
+
+	/* Ethernet PHY ID is stored at ID_REV register */
+	smsc_id = readl(CONFIG_SMC911X_BASE + 0x50) & 0xFFFF0000;
+	printf("Read back SMSC id 0x%x\n", smsc_id);
+
+	switch (smsc_id) {
+	/* SMSC9115 chipset */
+	case 0x01150000:
+		omap3_evm_version = OMAP3EVM_BOARD_GEN_1;
+		break;
+	/* SMSC 9220 chipset */
+	case 0x92200000:
+	default:
+		omap3_evm_version = OMAP3EVM_BOARD_GEN_2;
+       }
+}
+
 /*
  * Routine: board_init
  * Description: Early hardware init.
@@ -93,6 +121,7 @@ void set_muxconf_regs(void)
 static void setup_net_chip(void)
 {
 	struct gpio *gpio3_base = (struct gpio *)OMAP34XX_GPIO3_BASE;
+	struct gpio *gpio1_base = (struct gpio *)OMAP34XX_GPIO1_BASE;
 	struct ctrl *ctrl_base = (struct ctrl *)OMAP34XX_CTRL_BASE;
 
 	/* Configure GPMC registers */
@@ -112,15 +141,31 @@ static void setup_net_chip(void)
 	writew(readw(&ctrl_base->gpmc_nadv_ale) | 0x0E00,
 		&ctrl_base->gpmc_nadv_ale);
 
-	/* Make GPIO 64 as output pin */
-	writel(readl(&gpio3_base->oe) & ~(GPIO0), &gpio3_base->oe);
+	/* determine omap3evm revision */
+	omap3_evm_get_revision();
+
+	if ( get_omap3_evm_rev() == OMAP3EVM_BOARD_GEN_1 ){
+		/* Make GPIO 64 as output pin */
+		writel(readl(&gpio3_base->oe) & ~(GPIO0), &gpio3_base->oe);
+
+		/* Now send a pulse on the GPIO pin */
+		writel(GPIO0, &gpio3_base->setdataout);
+		udelay(1);
+		writel(GPIO0, &gpio3_base->cleardataout);
+		udelay(1);
+		writel(GPIO0, &gpio3_base->setdataout);
+	}else{
+		/* Make GPIO 07 as output pin */
+		writel(readl(&gpio1_base->oe) & ~(GPIO7), &gpio1_base->oe);
+
+		/* Now send a pulse on the GPIO pin */
+		writel(GPIO7, &gpio1_base->setdataout);
+		udelay(1);
+		writel(GPIO7, &gpio1_base->cleardataout);
+		udelay(1);
+		writel(GPIO7, &gpio1_base->setdataout);
+	}
 
-	/* Now send a pulse on the GPIO pin */
-	writel(GPIO0, &gpio3_base->setdataout);
-	udelay(1);
-	writel(GPIO0, &gpio3_base->cleardataout);
-	udelay(1);
-	writel(GPIO0, &gpio3_base->setdataout);
 }
 
 int board_eth_init(bd_t *bis)
diff --git a/board/ti/evm/evm.h b/board/ti/evm/evm.h
index 37da29d..e2581f6 100644
--- a/board/ti/evm/evm.h
+++ b/board/ti/evm/evm.h
@@ -33,6 +33,20 @@ const omap3_sysinfo sysinfo = {
 #endif
 };
 
+/*
+ * OMAP35x EVM revision
+ * Run time detection of EVM revision is done by reading Ethernet
+ * PHY ID -
+ *      GEN_1   = 0x01150000
+ *      GEN_2   = 0x92200000
+ */
+enum {
+	OMAP3EVM_BOARD_GEN_1 = 0,	/* EVM Rev between  A - D */
+	OMAP3EVM_BOARD_GEN_2,		/* EVM Rev >= Rev E */
+};
+
+u8 get_omap3_evm_rev(void);
+
 static void setup_net_chip(void);
 
 /*
diff --git a/common/Makefile b/common/Makefile
index 47f6a71..e5a7b7c 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -159,6 +159,7 @@ COBJS-$(CONFIG_LYNXKDI) += lynxkdi.o
 COBJS-$(CONFIG_MODEM_SUPPORT) += modem.o
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
 COBJS-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
+COBJS-$(CONFIG_DRIVER_TI_EMAC) += cmd_readmacid.o
 
 
 COBJS	:= $(sort $(COBJS-y))
diff --git a/common/cmd_readmacid.c b/common/cmd_readmacid.c
new file mode 100644
index 0000000..4ebe870
--- /dev/null
+++ b/common/cmd_readmacid.c
@@ -0,0 +1,51 @@
+/*
+ * cmd_readmacid.c
+ *
+ * Displays Craneboard's EMAC ID
+ *
+ * Author : Ulaganathan.V  <ulaganathan@mistralsolutions.com>
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd  <www.mistralsolutions.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+/*
+ * modification history
+ * --------------------
+ * 23 Aug 2010 - Created
+ *
+ */
+#include <common.h>
+
+#if defined(CONFIG_DRIVER_TI_EMAC)
+/* MAC ID */
+#define EMAC_MACID_ADDR_LSB 0x48002380
+#define EMAC_MACID_ADDR_MSB 0x48002384
+
+int read_mac_id(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	run_command("print ethaddr", 0);
+	return 0;
+}
+U_BOOT_CMD(readmacid, 10, 1, read_mac_id, "Display the EMAC ID of the board\n",
+		"\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+#endif
+
+
+
+
+
diff --git a/common/cmd_usb.c b/common/cmd_usb.c
index 7b8ee6b..1e297d5 100644
--- a/common/cmd_usb.c
+++ b/common/cmd_usb.c
@@ -157,7 +157,7 @@ void usb_display_desc(struct usb_device *dev)
 {
 	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
 		printf("%d: %s,  USB Revision %x.%x\n", dev->devnum,
-		usb_get_class_desc(dev->config.if_desc[0].bInterfaceClass),
+		usb_get_class_desc(dev->config.if_desc[0].desc.bInterfaceClass),
 				   (dev->descriptor.bcdUSB>>8) & 0xff,
 				   dev->descriptor.bcdUSB & 0xff);
 
@@ -174,7 +174,7 @@ void usb_display_desc(struct usb_device *dev)
 		} else {
 			printf(" - Class: (from Interface) %s\n",
 			       usb_get_class_desc(
-				dev->config.if_desc[0].bInterfaceClass));
+				dev->config.if_desc[0].desc.bInterfaceClass));
 		}
 		printf(" - PacketSize: %d  Configurations: %d\n",
 			dev->descriptor.bMaxPacketSize0,
@@ -187,14 +187,14 @@ void usb_display_desc(struct usb_device *dev)
 
 }
 
-void usb_display_conf_desc(struct usb_config_descriptor *config,
+void usb_display_conf_desc(struct usb_configuration_descriptor *config,
 			   struct usb_device *dev)
 {
 	printf("   Configuration: %d\n", config->bConfigurationValue);
 	printf("   - Interfaces: %d %s%s%dmA\n", config->bNumInterfaces,
 	       (config->bmAttributes & 0x40) ? "Self Powered " : "Bus Powered ",
 	       (config->bmAttributes & 0x20) ? "Remote Wakeup " : "",
-		config->MaxPower*2);
+		config->bMaxPower*2);
 	if (config->iConfiguration) {
 		printf("   - ");
 		usb_display_string(dev, config->iConfiguration);
@@ -246,16 +246,16 @@ void usb_display_ep_desc(struct usb_endpoint_descriptor *epdesc)
 /* main routine to diasplay the configs, interfaces and endpoints */
 void usb_display_config(struct usb_device *dev)
 {
-	struct usb_config_descriptor *config;
-	struct usb_interface_descriptor *ifdesc;
+	struct usb_config *config;
+	struct usb_interface *ifdesc;
 	struct usb_endpoint_descriptor *epdesc;
 	int i, ii;
 
 	config = &dev->config;
-	usb_display_conf_desc(config, dev);
+	usb_display_conf_desc(&config->desc, dev);
 	for (i = 0; i < config->no_of_if; i++) {
 		ifdesc = &config->if_desc[i];
-		usb_display_if_desc(ifdesc, dev);
+		usb_display_if_desc(&ifdesc->desc, dev);
 		for (ii = 0; ii < ifdesc->no_of_ep; ii++) {
 			epdesc = &ifdesc->ep_desc[ii];
 			usb_display_ep_desc(epdesc);
@@ -319,9 +319,9 @@ void usb_show_tree_graph(struct usb_device *dev, char *pre)
 	pre[index++] = has_child ? '|' : ' ';
 	pre[index] = 0;
 	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
-					dev->config.if_desc[0].bInterfaceClass),
+					dev->config.if_desc[0].desc.bInterfaceClass),
 					portspeed(dev->speed),
-					dev->config.MaxPower * 2);
+					dev->config.desc.bMaxPower * 2);
 	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
 		printf(" %s  %s %s %s\n", pre, dev->mf, dev->prod, dev->serial);
 	printf(" %s\n", pre);
diff --git a/common/usb.c b/common/usb.c
index 87fca70..eef4b34 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -299,8 +299,8 @@ int usb_set_maxpacket(struct usb_device *dev)
 {
 	int i, ii;
 
-	for (i = 0; i < dev->config.bNumInterfaces; i++)
-		for (ii = 0; ii < dev->config.if_desc[i].bNumEndpoints; ii++)
+	for (i = 0; i < dev->config.desc.bNumInterfaces; i++)
+		for (ii = 0; ii < dev->config.if_desc[i].desc.bNumEndpoints; ii++)
 			usb_set_maxpacket_ep(dev,
 					  &dev->config.if_desc[i].ep_desc[ii]);
 
@@ -330,14 +330,14 @@ int usb_parse_config(struct usb_device *dev, unsigned char *buffer, int cfgno)
 		return -1;
 	}
 	memcpy(&dev->config, buffer, buffer[0]);
-	le16_to_cpus(&(dev->config.wTotalLength));
+	le16_to_cpus(&(dev->config.desc.wTotalLength));
 	dev->config.no_of_if = 0;
 
-	index = dev->config.bLength;
+	index = dev->config.desc.bLength;
 	/* Ok the first entry must be a configuration entry,
 	 * now process the others */
 	head = (struct usb_descriptor_header *) &buffer[index];
-	while (index + 1 < dev->config.wTotalLength) {
+	while (index + 1 < dev->config.desc.wTotalLength) {
 		switch (head->bDescriptorType) {
 		case USB_DT_INTERFACE:
 			if (((struct usb_interface_descriptor *) \
@@ -350,7 +350,7 @@ int usb_parse_config(struct usb_device *dev, unsigned char *buffer, int cfgno)
 				dev->config.if_desc[ifno].no_of_ep = 0;
 				dev->config.if_desc[ifno].num_altsetting = 1;
 				curr_if_num =
-				     dev->config.if_desc[ifno].bInterfaceNumber;
+				     dev->config.if_desc[ifno].desc.bInterfaceNumber;
 			} else {
 				/* found alternate setting for the interface */
 				dev->config.if_desc[ifno].num_altsetting++;
@@ -440,10 +440,9 @@ int usb_get_configuration_no(struct usb_device *dev,
 {
 	int result;
 	unsigned int tmp;
-	struct usb_config_descriptor *config;
+	struct usb_configuration_descriptor *config;
 
-
-	config = (struct usb_config_descriptor *)&buffer[0];
+	config = (struct usb_configuration_descriptor *)&buffer[0];
 	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 9);
 	if (result < 9) {
 		if (result < 0)
@@ -489,11 +488,11 @@ int usb_set_address(struct usb_device *dev)
  */
 int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 {
-	struct usb_interface_descriptor *if_face = NULL;
+	struct usb_interface *if_face = NULL;
 	int ret, i;
 
-	for (i = 0; i < dev->config.bNumInterfaces; i++) {
-		if (dev->config.if_desc[i].bInterfaceNumber == interface) {
+	for (i = 0; i < dev->config.desc.bNumInterfaces; i++) {
+		if (dev->config.if_desc[i].desc.bInterfaceNumber == interface) {
 			if_face = &dev->config.if_desc[i];
 			break;
 		}
@@ -897,7 +896,7 @@ int usb_new_device(struct usb_device *dev)
 	usb_parse_config(dev, &tmpbuf[0], 0);
 	usb_set_maxpacket(dev);
 	/* we set the default configuration here */
-	if (usb_set_configuration(dev, dev->config.bConfigurationValue)) {
+	if (usb_set_configuration(dev, dev->config.desc.bConfigurationValue)) {
 		printf("failed to set default configuration " \
 			"len %d, status %lX\n", dev->act_len, dev->status);
 		return -1;
@@ -1347,21 +1346,21 @@ int usb_hub_configure(struct usb_device *dev)
 
 int usb_hub_probe(struct usb_device *dev, int ifnum)
 {
-	struct usb_interface_descriptor *iface;
+	struct usb_interface *iface;
 	struct usb_endpoint_descriptor *ep;
 	int ret;
 
 	iface = &dev->config.if_desc[ifnum];
 	/* Is it a hub? */
-	if (iface->bInterfaceClass != USB_CLASS_HUB)
+	if (iface->desc.bInterfaceClass != USB_CLASS_HUB)
 		return 0;
 	/* Some hubs have a subclass of 1, which AFAICT according to the */
 	/*  specs is not defined, but it works */
-	if ((iface->bInterfaceSubClass != 0) &&
-	    (iface->bInterfaceSubClass != 1))
+	if ((iface->desc.bInterfaceSubClass != 0) &&
+	    (iface->desc.bInterfaceSubClass != 1))
 		return 0;
 	/* Multiple endpoints? What kind of mutant ninja-hub is this? */
-	if (iface->bNumEndpoints != 1)
+	if (iface->desc.bNumEndpoints != 1)
 		return 0;
 	ep = &iface->ep_desc[0];
 	/* Output endpoint? Curiousier and curiousier.. */
diff --git a/common/usb_kbd.c b/common/usb_kbd.c
index b458d77..9957dcc 100644
--- a/common/usb_kbd.c
+++ b/common/usb_kbd.c
@@ -229,7 +229,7 @@ int usb_kbd_deregister(void)
 
 static void usb_kbd_setled(struct usb_device *dev)
 {
-	struct usb_interface_descriptor *iface;
+	struct usb_interface *iface;
 	iface = &dev->config.if_desc[0];
 	leds=0;
 	if(scroll_lock!=0)
@@ -242,7 +242,7 @@ static void usb_kbd_setled(struct usb_device *dev)
 		leds|=1;
 	usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 		USB_REQ_SET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
-		0x200, iface->bInterfaceNumber,(void *)&leds, 1, 0);
+		0x200, iface->desc.bInterfaceNumber, (void *)&leds, 1, 0);
 
 }
 
@@ -348,17 +348,21 @@ static int usb_kbd_irq(struct usb_device *dev)
 /* probes the USB device dev for keyboard type */
 static int usb_kbd_probe(struct usb_device *dev, unsigned int ifnum)
 {
-	struct usb_interface_descriptor *iface;
+	struct usb_interface *iface;
 	struct usb_endpoint_descriptor *ep;
 	int pipe,maxp;
 
 	if (dev->descriptor.bNumConfigurations != 1) return 0;
 	iface = &dev->config.if_desc[ifnum];
 
-	if (iface->bInterfaceClass != 3) return 0;
-	if (iface->bInterfaceSubClass != 1) return 0;
-	if (iface->bInterfaceProtocol != 1) return 0;
-	if (iface->bNumEndpoints != 1) return 0;
+	if (iface->desc.bInterfaceClass != 3)
+		return 0;
+	if (iface->desc.bInterfaceSubClass != 1)
+		return 0;
+	if (iface->desc.bInterfaceProtocol != 1)
+		return 0;
+	if (iface->desc.bNumEndpoints != 1)
+		return 0;
 
 	ep = &iface->ep_desc[0];
 
@@ -367,9 +371,9 @@ static int usb_kbd_probe(struct usb_device *dev, unsigned int ifnum)
 	USB_KBD_PRINTF("USB KBD found set protocol...\n");
 	/* ok, we found a USB Keyboard, install it */
 	/* usb_kbd_get_hid_desc(dev); */
-	usb_set_protocol(dev, iface->bInterfaceNumber, 0);
+	usb_set_protocol(dev, iface->desc.bInterfaceNumber, 0);
 	USB_KBD_PRINTF("USB KBD found set idle...\n");
-	usb_set_idle(dev, iface->bInterfaceNumber, REPEAT_RATE, 0);
+	usb_set_idle(dev, iface->desc.bInterfaceNumber, REPEAT_RATE, 0);
 	memset(&new[0], 0, 8);
 	memset(&old[0], 0, 8);
 	repeat_delay=0;
diff --git a/common/usb_storage.c b/common/usb_storage.c
index 19613f2..391948b 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -1070,7 +1070,7 @@ retry_it:
 int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 		      struct us_data *ss)
 {
-	struct usb_interface_descriptor *iface;
+	struct usb_interface *iface;
 	int i;
 	unsigned int flags = 0;
 
@@ -1094,9 +1094,9 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 #endif
 
 	if (dev->descriptor.bDeviceClass != 0 ||
-			iface->bInterfaceClass != USB_CLASS_MASS_STORAGE ||
-			iface->bInterfaceSubClass < US_SC_MIN ||
-			iface->bInterfaceSubClass > US_SC_MAX) {
+			iface->desc.bInterfaceClass != USB_CLASS_MASS_STORAGE ||
+			iface->desc.bInterfaceSubClass < US_SC_MIN ||
+			iface->desc.bInterfaceSubClass > US_SC_MAX) {
 		/* if it's not a mass storage, we go no further */
 		return 0;
 	}
@@ -1119,8 +1119,8 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 		ss->subclass = subclass;
 		ss->protocol = protocol;
 	} else {
-		ss->subclass = iface->bInterfaceSubClass;
-		ss->protocol = iface->bInterfaceProtocol;
+		ss->subclass = iface->desc.bInterfaceSubClass;
+		ss->protocol = iface->desc.bInterfaceProtocol;
 	}
 
 	/* set the handler pointers based on the protocol */
@@ -1153,7 +1153,7 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 	 * An optional interrupt is OK (necessary for CBI protocol).
 	 * We will ignore any others.
 	 */
-	for (i = 0; i < iface->bNumEndpoints; i++) {
+	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
 		/* is it an BULK endpoint? */
 		if ((iface->ep_desc[i].bmAttributes &
 		     USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK) {
@@ -1178,7 +1178,7 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
 		  ss->ep_in, ss->ep_out, ss->ep_int);
 
 	/* Do some basic sanity checks, and bail if we find a problem */
-	if (usb_set_interface(dev, iface->bInterfaceNumber, 0) ||
+	if (usb_set_interface(dev, iface->desc.bInterfaceNumber, 0) ||
 	    !ss->ep_in || !ss->ep_out ||
 	    (ss->protocol == US_PR_CBI && ss->ep_int == 0)) {
 		USB_STOR_PRINTF("Problems with device\n");
diff --git a/cpu/arm_cortexa8/omap3/Makefile b/cpu/arm_cortexa8/omap3/Makefile
index 136b163..0a23fa5 100644
--- a/cpu/arm_cortexa8/omap3/Makefile
+++ b/cpu/arm_cortexa8/omap3/Makefile
@@ -33,6 +33,12 @@ COBJS	+= board.o
 COBJS	+= clock.o
 COBJS	+= gpio.o
 COBJS	+= mem.o
+ifdef	CONFIG_SDRC
+COBJS	+= sdrc.o
+endif
+ifdef	CONFIG_EMIF4
+COBJS	+= emif4.o
+endif
 COBJS	+= syslib.o
 COBJS	+= sys_info.o
 COBJS	+= timer.o
diff --git a/cpu/arm_cortexa8/omap3/board.c b/cpu/arm_cortexa8/omap3/board.c
index 2aa69b3..ed287e5 100644
--- a/cpu/arm_cortexa8/omap3/board.c
+++ b/cpu/arm_cortexa8/omap3/board.c
@@ -40,8 +40,6 @@
 
 extern omap3_sysinfo sysinfo;
 
-extern u32 is_mem_sdr(void);
-
 /******************************************************************************
  * Routine: delay
  * Description: spinning delay to use before udelay works
@@ -193,6 +191,8 @@ void s_init(void)
 {
 	int in_sdram = is_running_in_sdram();
 
+	identify_cpu();
+
 	watchdog_init();
 
 	try_unlock_memory();
@@ -227,7 +227,7 @@ void s_init(void)
 	per_clocks_enable();
 
 	if (!in_sdram)
-		sdrc_init();
+		mem_init();
 }
 
 /******************************************************************************
@@ -268,36 +268,6 @@ void watchdog_init(void)
 }
 
 /******************************************************************************
- * Routine: dram_init
- * Description: sets uboots idea of sdram size
- *****************************************************************************/
-int dram_init(void)
-{
-	DECLARE_GLOBAL_DATA_PTR;
-	unsigned int size0 = 0, size1 = 0;
-
-	/*
-	 * If a second bank of DDR is attached to CS1 this is
-	 * where it can be started.  Early init code will init
-	 * memory on CS0.
-	 */
-	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
-		do_sdrc_init(CS1, NOT_EARLY);
-		make_cs1_contiguous();
-	}
-
-	size0 = get_sdr_cs_size(CS0);
-	size1 = get_sdr_cs_size(CS1);
-
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = size0;
-	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
-	gd->bd->bi_dram[1].size = size1;
-
-	return 0;
-}
-
-/******************************************************************************
  * Dummy function to handle errors for EABI incompatibility
  *****************************************************************************/
 void abort(void)
diff --git a/cpu/arm_cortexa8/omap3/cache.S b/cpu/arm_cortexa8/omap3/cache.S
index 0f63815..5121336 100644
--- a/cpu/arm_cortexa8/omap3/cache.S
+++ b/cpu/arm_cortexa8/omap3/cache.S
@@ -131,10 +131,28 @@ finished_inval:
 
 l2_cache_enable:
 	push	{r0, r1, r2, lr}
-	@ ES2 onwards we can disable/enable L2 ourselves
+	@ We can disable/enable L2 ourselves for these devices
+	@ - OMAP3430/OMAP35xx (ES2 onwards)
+	@ - AM35xx
+	mov	r0, #CPU_AM35XX
+	bl	is_cpu_family
+	cmp	r0, #1
+	beq	l2_cache_enable_LATER_THAN_ES2	@ family is AM35xx
+
+	mov	r0, #CPU_OMAP36XX
+	bl	is_cpu_family
+	cmp	r0, #1
+	beq	l2_cache_enable_LATER_THAN_ES2	@ family of OMAP36x/37x
+
+	mov	r0, #CPU_OMAP34XX
+	bl	is_cpu_family
+	cmp	r0, #1
+	bne	l2_cache_enable_END		@ Family isn't OMAP34xx/35xx
+
 	bl	get_cpu_rev
 	cmp	r0, #CPU_3XX_ES20
 	blt	l2_cache_disable_EARLIER_THAN_ES2
+l2_cache_enable_LATER_THAN_ES2:
 	mrc	15, 0, r3, cr1, cr0, 1
 	orr	r3, r3, #2
 	mcr	15, 0, r3, cr1, cr0, 1
@@ -162,10 +180,23 @@ l2_cache_enable_END:
 
 l2_cache_disable:
 	push	{r0, r1, r2, lr}
-	@ ES2 onwards we can disable/enable L2 ourselves
+	@ We can disable/enable L2 ourselves for these devices
+	@ - OMAP3430/OMAP35xx (ES2 onwards)
+	@ - AM35xx
+	mov	r0, #CPU_AM35XX
+	bl	is_cpu_family
+	cmp	r0, #1
+	beq	l2_cache_disable_LATER_THAN_ES2	@ family is AM35xx
+
+	mov	r0, #CPU_OMAP34XX
+	bl	is_cpu_family
+	cmp	r0, #1
+	bne	l2_cache_enable_END		@ Family isn't OMAP34xx/35xx
+
 	bl	get_cpu_rev
 	cmp	r0, #CPU_3XX_ES20
 	blt	l2_cache_disable_EARLIER_THAN_ES2
+l2_cache_disable_LATER_THAN_ES2:
 	mrc	15, 0, r3, cr1, cr0, 1
 	bic	r3, r3, #2
 	mcr	15, 0, r3, cr1, cr0, 1
diff --git a/cpu/arm_cortexa8/omap3/clock.c b/cpu/arm_cortexa8/omap3/clock.c
index 174c453..90d8a57 100644
--- a/cpu/arm_cortexa8/omap3/clock.c
+++ b/cpu/arm_cortexa8/omap3/clock.c
@@ -40,7 +40,7 @@
  *****************************************************************************/
 u32 get_osc_clk_speed(void)
 {
-	u32 start, cstart, cend, cdiff, val;
+	u32 start, cstart, cend, cdiff, cdiv, val;
 	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
 	struct prm *prm_base = (struct prm *)PRM_BASE;
 	struct gptimer *gpt1_base = (struct gptimer *)OMAP34XX_GPT1;
@@ -48,9 +48,17 @@ u32 get_osc_clk_speed(void)
 
 	val = readl(&prm_base->clksrc_ctrl);
 
-	/* If SYS_CLK is being divided by 2, remove for now */
-	val = (val & (~SYSCLKDIV_2)) | SYSCLKDIV_1;
-	writel(val, &prm_base->clksrc_ctrl);
+	if (val & SYSCLKDIV_2)
+		cdiv = 2;
+	else if (val & SYSCLKDIV_1)
+		cdiv = 1;
+	else
+		/*
+		 * Should never reach here!
+		 * TBD: Add a WARN()/BUG()
+		 *      For now, assume divider as 1.
+		 */
+		cdiv = 1;
 
 	/* enable timer2 */
 	val = readl(&prcm_base->clksel_wkup) | CLKSEL_GPT1;
@@ -61,6 +69,7 @@ u32 get_osc_clk_speed(void)
 	/* Enable I and F Clocks for GPT1 */
 	val = readl(&prcm_base->iclken_wkup) | EN_GPT1 | EN_32KSYNC;
 	writel(val, &prcm_base->iclken_wkup);
+
 	val = readl(&prcm_base->fclken_wkup) | EN_GPT1;
 	writel(val, &prcm_base->fclken_wkup);
 
@@ -83,6 +92,11 @@ u32 get_osc_clk_speed(void)
 	cend = readl(&gpt1_base->tcrr);		/* get end sys_clk count */
 	cdiff = cend - cstart;			/* get elapsed ticks */
 
+	if (cdiv == 2)
+	{
+		cdiff *= 2;
+	}
+
 	/* based on number of ticks assign speed */
 	if (cdiff > 19000)
 		return S38_4M;
@@ -123,65 +137,24 @@ void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
 	}
 }
 
-/******************************************************************************
- * prcm_init() - inits clocks for PRCM as defined in clocks.h
- *               called from SRAM, or Flash (using temp SRAM stack).
- *****************************************************************************/
-void prcm_init(void)
+/*
+ * OMAP3530 specific functions
+ */
+/**
+ * Initialize CORE DPLL for OMAP34x/35x
+ */
+static void dpll3_init_34xx(u32 sil_index, u32 clk_index)
 {
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_core_dpll_param();
 	void (*f_lock_pll) (u32, u32, u32, u32);
 	int xip_safe, p0, p1, p2, p3;
-	u32 osc_clk = 0, sys_clkin_sel;
-	u32 clk_index, sil_index = 0;
-	struct prm *prm_base = (struct prm *)PRM_BASE;
-	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
-	dpll_param *dpll_param_p;
-
-	f_lock_pll = (void *) ((u32) &_end_vect - (u32) &_start +
-				SRAM_VECT_CODE);
 
 	xip_safe = is_running_in_sram();
 
-	/*
-	 * Gauge the input clock speed and find out the sys_clkin_sel
-	 * value corresponding to the input clock.
-	 */
-	osc_clk = get_osc_clk_speed();
-	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
-
-	/* set input crystal speed */
-	sr32(&prm_base->clksel, 0, 3, sys_clkin_sel);
+	/* Moving to the right sysclk and ES rev base */
+	ptr = ptr + (3 * clk_index) + sil_index;
 
-	/* If the input clock is greater than 19.2M always divide/2 */
-	if (sys_clkin_sel > 2) {
-		/* input clock divider */
-		sr32(&prm_base->clksrc_ctrl, 6, 2, 2);
-		clk_index = sys_clkin_sel / 2;
-	} else {
-		/* input clock divider */
-		sr32(&prm_base->clksrc_ctrl, 6, 2, 1);
-		clk_index = sys_clkin_sel;
-	}
-
-	/*
-	 * The DPLL tables are defined according to sysclk value and
-	 * silicon revision. The clk_index value will be used to get
-	 * the values for that input sysclk from the DPLL param table
-	 * and sil_index will get the values for that SysClk for the
-	 * appropriate silicon rev.
-	 */
-	if (get_cpu_rev())
-		sil_index = 1;
-
-	/* Unlock MPU DPLL (slows things down, and needed later) */
-	sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOW_POWER_BYPASS);
-	wait_on_value(ST_MPU_CLK, 0, &prcm_base->idlest_pll_mpu, LDELAY);
-
-	/* Getting the base address of Core DPLL param table */
-	dpll_param_p = (dpll_param *) get_core_dpll_param();
-
-	/* Moving it to the right sysclk and ES rev base */
-	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
 	if (xip_safe) {
 		/*
 		 * CORE DPLL
@@ -196,34 +169,38 @@ void prcm_init(void)
 		 * work. write another value and then default value.
 		 */
 
-		/* m3x2 */
-		sr32(&prcm_base->clksel1_emu, 16, 5, CORE_M3X2 + 1);
-		/* m3x2 */
+		/* CM_CLKSEL1_EMU[DIV_DPLL3] */
+		sr32(&prcm_base->clksel1_emu, 16, 5, (CORE_M3X2 + 1)) ;
 		sr32(&prcm_base->clksel1_emu, 16, 5, CORE_M3X2);
-		/* Set M2 */
-		sr32(&prcm_base->clksel1_pll, 27, 2, dpll_param_p->m2);
-		/* Set M */
-		sr32(&prcm_base->clksel1_pll, 16, 11, dpll_param_p->m);
-		/* Set N */
-		sr32(&prcm_base->clksel1_pll, 8, 7, dpll_param_p->n);
-		/* 96M Src */
+
+		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
+		sr32(&prcm_base->clksel1_pll, 27, 5, ptr->m2);
+
+		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
+		sr32(&prcm_base->clksel1_pll, 16, 11, ptr->m);
+
+		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
+		sr32(&prcm_base->clksel1_pll, 8, 7, ptr->n);
+
+		/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
 		sr32(&prcm_base->clksel1_pll, 6, 1, 0);
-		/* ssi */
+
+		/* SSI */
 		sr32(&prcm_base->clksel_core, 8, 4, CORE_SSI_DIV);
-		/* fsusb */
+		/* FSUSB */
 		sr32(&prcm_base->clksel_core, 4, 2, CORE_FUSB_DIV);
-		/* l4 */
+		/* L4 */
 		sr32(&prcm_base->clksel_core, 2, 2, CORE_L4_DIV);
-		/* l3 */
+		/* L3 */
 		sr32(&prcm_base->clksel_core, 0, 2, CORE_L3_DIV);
-		/* gfx */
-		sr32(&prcm_base->clksel_gfx, 0, 3, GFX_DIV);
-		/* reset mgr */
+		/* GFX */
+		sr32(&prcm_base->clksel_gfx,  0, 3, GFX_DIV_34X);
+		/* RESET MGR */
 		sr32(&prcm_base->clksel_wkup, 1, 2, WKUP_RSM);
-		/* FREQSEL */
-		sr32(&prcm_base->clken_pll, 4, 4, dpll_param_p->fsel);
-		/* lock mode */
-		sr32(&prcm_base->clken_pll, 0, 3, PLL_LOCK);
+		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
+		sr32(&prcm_base->clken_pll,   4, 4, ptr->fsel);
+		/* LOCK MODE */
+		sr32(&prcm_base->clken_pll,   0, 3, PLL_LOCK);
 
 		wait_on_value(ST_CORE_CLK, 1, &prcm_base->idlest_ckgen,
 				LDELAY);
@@ -232,102 +209,417 @@ void prcm_init(void)
 		 * if running from flash, jump to small relocated code
 		 * area in SRAM.
 		 */
+		f_lock_pll = (void *) ((u32) &_end_vect - (u32) &_start +
+				SRAM_VECT_CODE);
+
 		p0 = readl(&prcm_base->clken_pll);
 		sr32(&p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
-		sr32(&p0, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
+		sr32(&p0, 4, 4, ptr->fsel);
 
 		p1 = readl(&prcm_base->clksel1_pll);
-		sr32(&p1, 27, 2, dpll_param_p->m2);	/* Set M2 */
-		sr32(&p1, 16, 11, dpll_param_p->m);	/* Set M */
-		sr32(&p1, 8, 7, dpll_param_p->n);		/* Set N */
-		sr32(&p1, 6, 1, 0);	/* set source for 96M */
+		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
+		sr32(&p1, 27, 5, ptr->m2);
+		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
+		sr32(&p1, 16, 11, ptr->m);
+		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
+		sr32(&p1, 8, 7, ptr->n);
+		/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
+		sr32(&p1, 6, 1, 0);
 
 		p2 = readl(&prcm_base->clksel_core);
-		sr32(&p2, 8, 4, CORE_SSI_DIV);	/* ssi */
-		sr32(&p2, 4, 2, CORE_FUSB_DIV);	/* fsusb */
-		sr32(&p2, 2, 2, CORE_L4_DIV);	/* l4 */
-		sr32(&p2, 0, 2, CORE_L3_DIV);	/* l3 */
+		/* SSI */
+		sr32(&p2, 8, 4, CORE_SSI_DIV);
+		/* FSUSB */
+		sr32(&p2, 4, 2, CORE_FUSB_DIV);
+		/* L4 */
+		sr32(&p2, 2, 2, CORE_L4_DIV);
+		/* L3 */
+		sr32(&p2, 0, 2, CORE_L3_DIV);
 
 		p3 = (u32)&prcm_base->idlest_ckgen;
 
 		(*f_lock_pll) (p0, p1, p2, p3);
 	}
+}
 
-	/* PER DPLL */
-	sr32(&prcm_base->clken_pll, 16, 3, PLL_STOP);
-	wait_on_value(ST_PERIPH_CLK, 0, &prcm_base->idlest_ckgen, LDELAY);
-
-	/* Getting the base address to PER DPLL param table */
-
-	/* Set N */
-	dpll_param_p = (dpll_param *) get_per_dpll_param();
+/**
+ * Initialize PER DPLL for OMAP34x/35x
+ */
+static void dpll4_init_34xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_per_dpll_param();
 
 	/* Moving it to the right sysclk base */
-	dpll_param_p = dpll_param_p + clk_index;
+	ptr = ptr + clk_index;
+
+	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_STOP);
+	wait_on_value(ST_PERIPH_CLK, 0, &prcm_base->idlest_ckgen, LDELAY);
 
 	/*
 	 * Errata 1.50 Workaround for OMAP3 ES1.0 only
 	 * If using default divisors, write default divisor + 1
 	 * and then the actual divisor value
 	 */
-	sr32(&prcm_base->clksel1_emu, 24, 5, PER_M6X2 + 1);	/* set M6 */
-	sr32(&prcm_base->clksel1_emu, 24, 5, PER_M6X2);		/* set M6 */
-	sr32(&prcm_base->clksel_cam, 0, 5, PER_M5X2 + 1);	/* set M5 */
-	sr32(&prcm_base->clksel_cam, 0, 5, PER_M5X2);		/* set M5 */
-	sr32(&prcm_base->clksel_dss, 0, 5, PER_M4X2 + 1);	/* set M4 */
-	sr32(&prcm_base->clksel_dss, 0, 5, PER_M4X2);		/* set M4 */
-	sr32(&prcm_base->clksel_dss, 8, 5, PER_M3X2 + 1);	/* set M3 */
-	sr32(&prcm_base->clksel_dss, 8, 5, PER_M3X2);		/* set M3 */
-	sr32(&prcm_base->clksel3_pll, 0, 5, dpll_param_p->m2 + 1); /* set M2 */
-	sr32(&prcm_base->clksel3_pll, 0, 5, dpll_param_p->m2);	/* set M2 */
+	/* M6 */
+	sr32(&prcm_base->clksel1_emu, 24, 5, (PER_M6X2 + 1));
+	sr32(&prcm_base->clksel1_emu, 24, 5, PER_M6X2);
+	/* M5 */
+	sr32(&prcm_base->clksel_cam, 0, 5, (PER_M5X2 + 1));
+	sr32(&prcm_base->clksel_cam, 0, 5, PER_M5X2);
+	/* M4 */
+	sr32(&prcm_base->clksel_dss, 0, 5, (PER_M4X2 + 1));
+	sr32(&prcm_base->clksel_dss, 0, 5, PER_M4X2);
+	/* M3 */
+	sr32(&prcm_base->clksel_dss, 8, 5, (PER_M3X2 + 1));
+	sr32(&prcm_base->clksel_dss, 8, 5, PER_M3X2);
+	/* M2 (DIV_96M): CM_CLKSEL3_PLL[0:4] */
+	sr32(&prcm_base->clksel3_pll, 0, 5, (ptr->m2 + 1));
+	sr32(&prcm_base->clksel3_pll, 0, 5, ptr->m2);
 	/* Workaround end */
 
-	sr32(&prcm_base->clksel2_pll, 8, 11, dpll_param_p->m);	/* set m */
-	sr32(&prcm_base->clksel2_pll, 0, 7, dpll_param_p->n);	/* set n */
-	sr32(&prcm_base->clken_pll, 20, 4, dpll_param_p->fsel);	/* FREQSEL */
-	sr32(&prcm_base->clken_pll, 16, 3, PLL_LOCK);		/* lock mode */
+	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:18] */
+	sr32(&prcm_base->clksel2_pll, 8, 11, ptr->m);
+
+	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
+	sr32(&prcm_base->clksel2_pll, 0, 7, ptr->n);
+
+	/* FREQSEL (PERIPH_DPLL_FREQSEL): CM_CLKEN_PLL[20:23] */
+	sr32(&prcm_base->clken_pll, 20, 4, ptr->fsel);
+
+	/* LOCK MODE (EN_PERIPH_DPLL): CM_CLKEN_PLL[16:18] */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_LOCK);
 	wait_on_value(ST_PERIPH_CLK, 2, &prcm_base->idlest_ckgen, LDELAY);
+}
 
-	/* Getting the base address to MPU DPLL param table */
-	dpll_param_p = (dpll_param *) get_mpu_dpll_param();
+static void mpu_init_34xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_mpu_dpll_param();
 
-	/* Moving it to the right sysclk and ES rev base */
-	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+	/* Moving to the right sysclk and ES rev base */
+	ptr = ptr + (3 * clk_index) + sil_index;
 
 	/* MPU DPLL (unlocked already) */
 
-	/* Set M2 */
-	sr32(&prcm_base->clksel2_pll_mpu, 0, 5, dpll_param_p->m2);
-	/* Set M */
-	sr32(&prcm_base->clksel1_pll_mpu, 8, 11, dpll_param_p->m);
-	/* Set N */
-	sr32(&prcm_base->clksel1_pll_mpu, 0, 7, dpll_param_p->n);
-	/* FREQSEL */
-	sr32(&prcm_base->clken_pll_mpu, 4, 4, dpll_param_p->fsel);
-	/* lock mode */
-	sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOCK);
-	wait_on_value(ST_MPU_CLK, 1, &prcm_base->idlest_pll_mpu, LDELAY);
-
-	/* Getting the base address to IVA DPLL param table */
-	dpll_param_p = (dpll_param *) get_iva_dpll_param();
-
-	/* Moving it to the right sysclk and ES rev base */
-	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
-
-	/* IVA DPLL (set to 12*20=240MHz) */
+	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
+	sr32(&prcm_base->clksel2_pll_mpu, 0, 5, ptr->m2);
+
+	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
+	sr32(&prcm_base->clksel1_pll_mpu, 8, 11, ptr->m);
+
+	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
+	sr32(&prcm_base->clksel1_pll_mpu, 0, 7, ptr->n);
+
+	/* FREQSEL (MPU_DPLL_FREQSEL) : CM_CLKEN_PLL_MPU[4:7] */
+	sr32(&prcm_base->clken_pll_mpu, 4, 4, ptr->fsel);
+}
+
+static void iva_init_34xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_iva_dpll_param();
+
+	/* Moving to the right sysclk and ES rev base */
+	ptr = ptr + (3 * clk_index) + sil_index;
+
+	/* IVA DPLL */
+	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
 	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_STOP);
 	wait_on_value(ST_IVA2_CLK, 0, &prcm_base->idlest_pll_iva2, LDELAY);
-	/* set M2 */
-	sr32(&prcm_base->clksel2_pll_iva2, 0, 5, dpll_param_p->m2);
-	/* set M */
-	sr32(&prcm_base->clksel1_pll_iva2, 8, 11, dpll_param_p->m);
-	/* set N */
-	sr32(&prcm_base->clksel1_pll_iva2, 0, 7, dpll_param_p->n);
-	/* FREQSEL */
-	sr32(&prcm_base->clken_pll_iva2, 4, 4, dpll_param_p->fsel);
-	/* lock mode */
+
+	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
+	sr32(&prcm_base->clksel2_pll_iva2, 0, 5, ptr->m2);
+
+	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
+	sr32(&prcm_base->clksel1_pll_iva2, 8, 11, ptr->m);
+
+	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
+	sr32(&prcm_base->clksel1_pll_iva2, 0, 7, ptr->n);
+
+	/* FREQSEL (IVA2_DPLL_FREQSEL) : CM_CLKEN_PLL_IVA2[4:7] */
+	sr32(&prcm_base->clken_pll_iva2, 4, 4, ptr->fsel);
+
+	/* LOCK MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
 	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_LOCK);
+
 	wait_on_value(ST_IVA2_CLK, 1, &prcm_base->idlest_pll_iva2, LDELAY);
+}
+
+/*
+ * OMAP3630 specific functions
+ */
+/**
+ * Initialize PER DPLL for OMAP36x/37x
+ */
+static void dpll3_init_36xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_36x_core_dpll_param();
+	void (*f_lock_pll) (u32, u32, u32, u32);
+	int xip_safe, p0, p1, p2, p3;
+
+	xip_safe = is_running_in_sram();
+
+	/* Moving it to the right sysclk base */
+	ptr += clk_index;
+
+	if (xip_safe) {
+		/* CORE DPLL */
+
+		/* Select relock bypass: CM_CLKEN_PLL[0:2] */
+		sr32(&prcm_base->clken_pll, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		wait_on_value(ST_CORE_CLK, 0, &prcm_base->idlest_ckgen,
+				LDELAY);
+
+		/* CM_CLKSEL1_EMU[DIV_DPLL3] */
+		sr32(&prcm_base->clksel1_emu, 16, 5, CORE_M3X2);
+
+		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
+		sr32(&prcm_base->clksel1_pll, 27, 5, ptr->m2);
+
+		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
+		sr32(&prcm_base->clksel1_pll, 16, 11, ptr->m);
+
+		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
+		sr32(&prcm_base->clksel1_pll, 8, 7, ptr->n);
+
+		/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
+		sr32(&prcm_base->clksel1_pll, 6, 1, 0);
+
+		/* SSI */
+		sr32(&prcm_base->clksel_core, 8, 4, CORE_SSI_DIV);
+		/* FSUSB */
+		sr32(&prcm_base->clksel_core, 4, 2, CORE_FUSB_DIV);
+		/* L4 */
+		sr32(&prcm_base->clksel_core, 2, 2, CORE_L4_DIV);
+		/* L3 */
+		sr32(&prcm_base->clksel_core, 0, 2, CORE_L3_DIV);
+		/* GFX */
+		sr32(&prcm_base->clksel_gfx,  0, 3, GFX_DIV_36X);
+		/* RESET MGR */
+		sr32(&prcm_base->clksel_wkup, 1, 2, WKUP_RSM);
+		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
+		sr32(&prcm_base->clken_pll,   4, 4, ptr->fsel);
+		/* LOCK MODE */
+		sr32(&prcm_base->clken_pll,   0, 3, PLL_LOCK);
+
+		wait_on_value(ST_CORE_CLK, 1, &prcm_base->idlest_ckgen,
+				LDELAY);
+	} else if (is_running_in_flash()) {
+		/*
+		 * if running from flash, jump to small relocated code
+		 * area in SRAM.
+		 */
+		f_lock_pll = (void *) ((u32) &_end_vect - (u32) &_start +
+				SRAM_VECT_CODE);
+
+		p0 = readl(&prcm_base->clken_pll);
+		sr32(&p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		/* FREQSEL (CORE_DPLL_FREQSEL): CM_CLKEN_PLL[4:7] */
+		sr32(&p0, 4, 4, ptr->fsel);
+
+		p1 = readl(&prcm_base->clksel1_pll);
+		/* M2 (CORE_DPLL_CLKOUT_DIV): CM_CLKSEL1_PLL[27:31] */
+		sr32(&p1, 27, 5, ptr->m2);
+		/* M (CORE_DPLL_MULT): CM_CLKSEL1_PLL[16:26] */
+		sr32(&p1, 16, 11, ptr->m);
+		/* N (CORE_DPLL_DIV): CM_CLKSEL1_PLL[8:14] */
+		sr32(&p1, 8, 7, ptr->n);
+		/* Source is the CM_96M_FCLK: CM_CLKSEL1_PLL[6] */
+		sr32(&p1, 6, 1, 0);
+
+		p2 = readl(&prcm_base->clksel_core);
+		/* SSI */
+		sr32(&p2, 8, 4, CORE_SSI_DIV);
+		/* FSUSB */
+		sr32(&p2, 4, 2, CORE_FUSB_DIV);
+		/* L4 */
+		sr32(&p2, 2, 2, CORE_L4_DIV);
+		/* L3 */
+		sr32(&p2, 0, 2, CORE_L3_DIV);
+
+		p3 = (u32)&prcm_base->idlest_ckgen;
+
+		(*f_lock_pll) (p0, p1, p2, p3);
+	}
+}
+
+static void dpll4_init_36xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	struct dpll_per_36x_param *ptr;
+
+	ptr = (struct dpll_per_36x_param *)get_36x_per_dpll_param();
+
+	/* Moving it to the right sysclk base */
+	ptr += clk_index;
+
+	/* EN_PERIPH_DPLL: CM_CLKEN_PLL[16:18] */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_STOP);
+	wait_on_value(ST_PERIPH_CLK, 0, &prcm_base->idlest_ckgen, LDELAY);
+
+	/* M6 (DIV_DPLL4): CM_CLKSEL1_EMU[24:29] */
+	sr32(&prcm_base->clksel1_emu, 24, 6, ptr->m6);
+
+	/* M5 (CLKSEL_CAM): CM_CLKSEL1_EMU[0:5] */
+	sr32(&prcm_base->clksel_cam, 0, 6, ptr->m5);
+
+	/* M4 (CLKSEL_DSS1): CM_CLKSEL_DSS[0:5] */
+	sr32(&prcm_base->clksel_dss, 0, 6, ptr->m4);
+
+	/* M3 (CLKSEL_DSS1): CM_CLKSEL_DSS[8:13] */
+	sr32(&prcm_base->clksel_dss, 8, 6, ptr->m3);
+
+	/* M2 (DIV_96M): CM_CLKSEL3_PLL[0:4] */
+	sr32(&prcm_base->clksel3_pll, 0, 5, ptr->m2);
+
+	/* M (PERIPH_DPLL_MULT): CM_CLKSEL2_PLL[8:19] */
+	sr32(&prcm_base->clksel2_pll, 8, 12, ptr->m);
+
+	/* N (PERIPH_DPLL_DIV): CM_CLKSEL2_PLL[0:6] */
+	sr32(&prcm_base->clksel2_pll, 0, 7, ptr->n);
+
+	/* M2DIV (CLKSEL_96M): CM_CLKSEL_CORE[12:13] */
+	sr32(&prcm_base->clksel_core, 12, 2, ptr->m2div);
+
+	/* LOCK MODE (EN_PERIPH_DPLL): CM_CLKEN_PLL[16:18] */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_LOCK);
+	wait_on_value(ST_PERIPH_CLK, 2, &prcm_base->idlest_ckgen, LDELAY);
+}
+
+static void mpu_init_36xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *) get_36x_mpu_dpll_param();
+
+	/* Moving to the right sysclk */
+	ptr += clk_index;
+
+	/* MPU DPLL (unlocked already */
+
+	/* M2 (MPU_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_MPU[0:4] */
+	sr32(&prcm_base->clksel2_pll_mpu, 0, 5, ptr->m2);
+
+	/* M (MPU_DPLL_MULT) : CM_CLKSEL2_PLL_MPU[8:18] */
+	sr32(&prcm_base->clksel1_pll_mpu, 8, 11, ptr->m);
+
+	/* N (MPU_DPLL_DIV) : CM_CLKSEL2_PLL_MPU[0:6] */
+	sr32(&prcm_base->clksel1_pll_mpu, 0, 7, ptr->n);
+}
+
+static void iva_init_36xx(u32 sil_index, u32 clk_index)
+{
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+	dpll_param *ptr = (dpll_param *)get_36x_iva_dpll_param();
+
+	/* Moving to the right sysclk */
+	ptr += clk_index;
+
+	/* IVA DPLL */
+	/* EN_IVA2_DPLL : CM_CLKEN_PLL_IVA2[0:2] */
+	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_STOP);
+	wait_on_value(ST_IVA2_CLK, 0, &prcm_base->idlest_pll_iva2, LDELAY);
+
+	/* M2 (IVA2_DPLL_CLKOUT_DIV) : CM_CLKSEL2_PLL_IVA2[0:4] */
+	sr32(&prcm_base->clksel2_pll_iva2, 0, 5, ptr->m2);
+
+	/* M (IVA2_DPLL_MULT) : CM_CLKSEL1_PLL_IVA2[8:18] */
+	sr32(&prcm_base->clksel1_pll_iva2, 8, 11, ptr->m);
+
+	/* N (IVA2_DPLL_DIV) : CM_CLKSEL1_PLL_IVA2[0:6] */
+	sr32(&prcm_base->clksel1_pll_iva2, 0, 7, ptr->n);
+
+	/* LOCK (MODE (EN_IVA2_DPLL) : CM_CLKEN_PLL_IVA2[0:2] */
+	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_LOCK);
+
+	wait_on_value(ST_IVA2_CLK, 1, &prcm_base->idlest_pll_iva2, LDELAY);
+}
+
+/******************************************************************************
+ * prcm_init() - inits clocks for PRCM as defined in clocks.h
+ *               called from SRAM, or Flash (using temp SRAM stack).
+ *****************************************************************************/
+void prcm_init(void)
+{
+	u32 osc_clk = 0, sys_clkin_sel;
+	u32 clk_index, sil_index = 0;
+	struct prm *prm_base = (struct prm *)PRM_BASE;
+	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
+
+	/*
+	 * Gauge the input clock speed and find out the sys_clkin_sel
+	 * value corresponding to the input clock.
+	 */
+	osc_clk = get_osc_clk_speed();
+	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
+
+	/* set input crystal speed */
+	sr32(&prm_base->clksel, 0, 3, sys_clkin_sel);
+
+	/* If the input clock is greater than 19.2M always divide/2 */
+	/*
+	 * On OMAP3630, DDR data corruption has been observed on OFF mode
+	 * exit if the sys clock was lower than 26M. As a work around,
+	 * OMAP3630 is operated at 26M sys clock and this internal division
+	 * is not performed.
+	 */
+	if ((!is_cpu_family(CPU_OMAP36XX)) && (sys_clkin_sel > 2)) {
+		/* input clock divider */
+		sr32(&prm_base->clksrc_ctrl, 6, 2, 2);
+		clk_index = sys_clkin_sel / 2;
+	} else {
+		/* input clock divider */
+		sr32(&prm_base->clksrc_ctrl, 6, 2, 1);
+		clk_index = sys_clkin_sel;
+	}
+
+	if (is_cpu_family(CPU_OMAP36XX)) {
+		/* Unlock MPU DPLL (slows things down, and needed later) */
+		sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOW_POWER_BYPASS);
+		wait_on_value(ST_MPU_CLK, 0, &prcm_base->idlest_pll_mpu,
+				LDELAY);
+
+		dpll3_init_36xx(0, clk_index);
+		dpll4_init_36xx(0, clk_index);
+		iva_init_36xx(0, clk_index);
+		mpu_init_36xx(0, clk_index);
+
+		/* Lock MPU DPLL to set frequency */
+		sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOCK);
+		wait_on_value(ST_MPU_CLK, 1, &prcm_base->idlest_pll_mpu,
+				LDELAY);
+	} else {
+		/*
+		 * The DPLL tables are defined according to sysclk value and
+		 * silicon revision. The clk_index value will be used to get
+		 * the values for that input sysclk from the DPLL param table
+		 * and sil_index will get the values for that SysClk for the
+		 * appropriate silicon rev.
+		 */
+		if ((is_cpu_family(CPU_OMAP34XX)
+				&& (get_cpu_rev() >= CPU_3XX_ES20)) ||
+			(is_cpu_family(CPU_AM35XX)))
+			sil_index = 1;
+
+		/* Unlock MPU DPLL (slows things down, and needed later) */
+		sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOW_POWER_BYPASS);
+		wait_on_value(ST_MPU_CLK, 0, &prcm_base->idlest_pll_mpu,
+				LDELAY);
+
+		dpll3_init_34xx(sil_index, clk_index);
+		dpll4_init_34xx(sil_index, clk_index);
+		if (!is_cpu_family(CPU_AM35XX))
+			iva_init_34xx(sil_index, clk_index);
+		mpu_init_34xx(sil_index, clk_index);
+
+		/* Lock MPU DPLL to set frequency */
+		sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOCK);
+		wait_on_value(ST_MPU_CLK, 1, &prcm_base->idlest_pll_mpu,
+				LDELAY);
+	}
 
 	/* Set up GPTimers to sys_clk source only */
 	sr32(&prcm_base->clksel_per, 0, 8, 0xff);
@@ -387,7 +679,16 @@ void per_clocks_enable(void)
 	/* Enable the ICLK for 32K Sync Timer as its used in udelay */
 	sr32(&prcm_base->iclken_wkup, 2, 1, 0x1);
 
+	sr32(&prcm_base->fclken1_core, 24, 1, 1);
+	sr32(&prcm_base->iclken_wkup, 24, 1, 1);
+
+	sr32(&prcm_base->fclken1_core, 25, 1, 1);
+	sr32(&prcm_base->iclken_wkup, 25, 1, 1);
+
+#if  (!defined(CONFIG_OMAP3_AM3517EVM) || !defined(CONFIG_OMAP3_AM3517CRANE))
 	sr32(&prcm_base->fclken_iva2, 0, 32, FCK_IVA2_ON);
+#endif
+
 	sr32(&prcm_base->fclken1_core, 0, 32, FCK_CORE1_ON);
 	sr32(&prcm_base->iclken1_core, 0, 32, ICK_CORE1_ON);
 	sr32(&prcm_base->iclken2_core, 0, 32, ICK_CORE2_ON);
@@ -395,8 +696,12 @@ void per_clocks_enable(void)
 	sr32(&prcm_base->iclken_wkup, 0, 32, ICK_WKUP_ON);
 	sr32(&prcm_base->fclken_dss, 0, 32, FCK_DSS_ON);
 	sr32(&prcm_base->iclken_dss, 0, 32, ICK_DSS_ON);
+
+#if  (!defined(CONFIG_OMAP3_AM3517EVM) || !defined(CONFIG_OMAP3_AM3517CRANE))
 	sr32(&prcm_base->fclken_cam, 0, 32, FCK_CAM_ON);
 	sr32(&prcm_base->iclken_cam, 0, 32, ICK_CAM_ON);
+#endif
+
 	sr32(&prcm_base->fclken_per, 0, 32, FCK_PER_ON);
 	sr32(&prcm_base->iclken_per, 0, 32, ICK_PER_ON);
 
diff --git a/cpu/arm_cortexa8/omap3/emif4.c b/cpu/arm_cortexa8/omap3/emif4.c
new file mode 100644
index 0000000..baf4dcc
--- /dev/null
+++ b/cpu/arm_cortexa8/omap3/emif4.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Based on mem.c and sdrc.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/emif4.h>
+
+extern omap3_sysinfo sysinfo;
+
+static emif4_t *emif4_base = (emif4_t *)OMAP34XX_SDRC_BASE;
+
+/**
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ */
+u32 is_mem_sdr(void)
+{
+	return 0;
+}
+
+/**
+ * get_sdr_cs_size() - get size of chip select 0/1
+ */
+u32 get_sdr_cs_size(u32 cs)
+{
+	u32 size;
+
+	/* TODO: Calculate the size based on EMIF4 configuration */
+	size = CONFIG_SYS_CS0_SIZE;
+
+	return size;
+}
+
+/**
+ * get_sdr_cs_offset() - get offset of cs from cs0 start
+ */
+u32 get_sdr_cs_offset(u32 cs)
+{
+	u32 offset=0;
+
+	return offset;
+}
+
+/**
+ * do_emif4_init() - init the emif4 module for DDR access
+ *  - early init routines, called from flash or
+ *  SRAM.
+ */
+void do_emif4_init(void)
+{
+	unsigned int regval;
+	/* Set the DDR PHY parameters in PHY ctrl registers */
+	regval = (EMIF4_DDR1_READ_LAT | EMIF4_DDR1_PWRDN_DIS |
+		EMIF4_DDR1_EXT_STRB_DIS);
+	writel(regval, &emif4_base->ddr_phyctrl1);
+	writel(regval, &emif4_base->ddr_phyctrl1_shdw);
+	writel(0, &emif4_base->ddr_phyctrl2);
+
+	/* Reset the DDR PHY and wait till completed */
+	regval = readl(&emif4_base->sdram_iodft_tlgc);
+	regval |= (1<<10);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/*Wait till that bit clears*/
+	while ((readl(&emif4_base->sdram_iodft_tlgc) & (1<<10)) == 0x1);
+	/*Re-verify the DDR PHY status*/
+	while ((readl(&emif4_base->sdram_sts) & (1<<2)) == 0x0);
+
+	regval |= (1<<0);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/* Set SDR timing registers */
+	regval = (EMIF4_TIM1_T_WTR | EMIF4_TIM1_T_RRD |
+		EMIF4_TIM1_T_RC | EMIF4_TIM1_T_RAS |
+		EMIF4_TIM1_T_WR | EMIF4_TIM1_T_RCD |
+		EMIF4_TIM1_T_RP);
+	writel(regval, &emif4_base->sdram_time1);
+	writel(regval, &emif4_base->sdram_time1_shdw);
+
+	regval = (EMIF4_TIM2_T_CKE | EMIF4_TIM2_T_RTP |
+		EMIF4_TIM2_T_XSRD | EMIF4_TIM2_T_XSNR |
+		EMIF4_TIM2_T_ODT | EMIF4_TIM2_T_XP);
+	writel(regval, &emif4_base->sdram_time2);
+	writel(regval, &emif4_base->sdram_time2_shdw);
+
+	regval = (EMIF4_TIM3_T_RAS_MAX | EMIF4_TIM3_T_RFC);
+	writel(regval, &emif4_base->sdram_time3);
+	writel(regval, &emif4_base->sdram_time3_shdw);
+
+	/* Set the PWR control register */
+	regval = (EMIF4_PWR_PM_TIM | EMIF4_PWR_LP_MODE |
+		EMIF4_PWR_DPD_DIS | EMIF4_PWR_IDLE_MODE);
+	writel(regval, &emif4_base->sdram_pwr_mgmt);
+	writel(regval, &emif4_base->sdram_pwr_mgmt_shdw);
+
+	/* Set the DDR refresh rate control register */
+	regval = (EMIF4_REFRESH_RATE | EMIF4_INITREF_DIS);
+	writel(regval, &emif4_base->sdram_refresh_ctrl);
+	writel(regval, &emif4_base->sdram_refresh_ctrl_shdw);
+
+	/* set the SDRAM configuration register */
+	regval = (EMIF4_CFG_PGSIZE | EMIF4_CFG_EBANK |
+		EMIF4_CFG_IBANK | EMIF4_CFG_ROWSIZE |
+		EMIF4_CFG_CL | EMIF4_CFG_NARROW_MD |
+		EMIF4_CFG_SDR_DRV | EMIF4_CFG_DDR_DIS_DLL |
+		EMIF4_CFG_DDR2_DDQS | EMIF4_CFG_DDR_TERM |
+		EMIF4_CFG_IBANK_POS | EMIF4_CFG_SDRAM_TYP);
+	writel(regval, &emif4_base->sdram_config);
+}
+
+/**
+ * dram_init - Sets uboots idea of sdram size
+ */
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+
+	size0 = get_sdr_cs_size(CS0);
+	/*
+	 * If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
+		size1 = get_sdr_cs_size(CS1);
+	}
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+/**
+ * mem_init() - Initialize memory subsystem
+ */
+void mem_init(void)
+{
+	do_emif4_init();
+}
diff --git a/cpu/arm_cortexa8/omap3/lowlevel_init.S b/cpu/arm_cortexa8/omap3/lowlevel_init.S
index 73063ec..a22dad8 100644
--- a/cpu/arm_cortexa8/omap3/lowlevel_init.S
+++ b/cpu/arm_cortexa8/omap3/lowlevel_init.S
@@ -359,3 +359,54 @@ per_dpll_param:
 get_per_dpll_param:
 	adr	r0, per_dpll_param
 	mov	pc, lr
+
+
+/*
+ * Tables for 36x/37x devices
+ *
+ * (Populated for 13MHz only)
+ */
+mpu_36x_dpll_param:
+.word 300, 12, 0, 1
+.word 300, 12, 0, 1
+.word 300, 12, 0, 1
+.word 300, 12, 0, 1
+
+iva_36x_dpll_param:
+.word 10, 0, 0, 1
+.word 10, 0, 0, 1
+.word 10, 0, 0, 1
+.word 10, 0, 0, 1
+
+core_36x_dpll_param:
+.word 200, 12, 0, 1
+.word 200, 12, 0, 1
+.word 200, 12, 0, 1
+.word 200, 12, 0, 1
+
+per_36x_dpll_param:
+/*    SYSCLK    M       N      M2      M3      M4     M5      M6      m2DIV */
+.word 26000,    432,   12,     9,      16,     9,     4,      3,      1
+.word 26000,    432,   12,     9,      16,     9,     4,      3,      1
+.word 26000,    432,   12,     9,      16,     9,     4,      3,      1
+.word 26000,    432,   12,     9,      16,     9,     4,      3,      1
+
+.globl get_36x_mpu_dpll_param
+get_36x_mpu_dpll_param:
+	adr	r0, mpu_36x_dpll_param
+	mov	pc, lr
+
+.globl get_36x_iva_dpll_param
+get_36x_iva_dpll_param:
+	adr	r0, iva_36x_dpll_param
+	mov	pc, lr
+
+.globl get_36x_core_dpll_param
+get_36x_core_dpll_param:
+	adr	r0, core_36x_dpll_param
+	mov	pc, lr
+
+.globl get_36x_per_dpll_param
+get_36x_per_dpll_param:
+	adr	r0, per_36x_dpll_param
+	mov	pc, lr
diff --git a/cpu/arm_cortexa8/omap3/mem.c b/cpu/arm_cortexa8/omap3/mem.c
index 8b8cd6d..107ffb2 100644
--- a/cpu/arm_cortexa8/omap3/mem.c
+++ b/cpu/arm_cortexa8/omap3/mem.c
@@ -123,75 +123,6 @@ u32 mem_ok(u32 cs)
 		return 1;
 }
 
-/********************************************************
- *  sdrc_init() - init the sdrc chip selects CS0 and CS1
- *  - early init routines, called from flash or
- *  SRAM.
- *******************************************************/
-void sdrc_init(void)
-{
-	/* only init up first bank here */
-	do_sdrc_init(CS0, EARLY_INIT);
-}
-
-/*************************************************************************
- * do_sdrc_init(): initialize the SDRAM for use.
- *  -code sets up SDRAM basic SDRC timings for CS0
- *  -optimal settings can be placed here, or redone after i2c
- *      inspection of board info
- *
- *  - code called once in C-Stack only context for CS0 and a possible 2nd
- *      time depending on memory configuration from stack+global context
- **************************************************************************/
-
-void do_sdrc_init(u32 cs, u32 early)
-{
-	struct sdrc_actim *sdrc_actim_base;
-
-	if(cs)
-		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL1_BASE;
-	else
-		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL0_BASE;
-
-	if (early) {
-		/* reset sdrc controller */
-		writel(SOFTRESET, &sdrc_base->sysconfig);
-		wait_on_value(RESETDONE, RESETDONE, &sdrc_base->status,
-			      12000000);
-		writel(0, &sdrc_base->sysconfig);
-
-		/* setup sdrc to ball mux */
-		writel(SDP_SDRC_SHARING, &sdrc_base->sharing);
-
-		/* Disable Power Down of CKE cuz of 1 CKE on combo part */
-		writel(SRFRONRESET | PAGEPOLICY_HIGH, &sdrc_base->power);
-
-		writel(ENADLL | DLLPHASE_90, &sdrc_base->dlla_ctrl);
-		sdelay(0x20000);
-	}
-
-	writel(RASWIDTH_13BITS | CASWIDTH_10BITS | ADDRMUXLEGACY |
-		RAMSIZE_128 | BANKALLOCATION | B32NOT16 | B32NOT16 |
-		DEEPPD | DDR_SDRAM, &sdrc_base->cs[cs].mcfg);
-	writel(ARCV | ARE_ARCV_1, &sdrc_base->cs[cs].rfr_ctrl);
-	writel(V_ACTIMA_165, &sdrc_actim_base->ctrla);
-	writel(V_ACTIMB_165, &sdrc_actim_base->ctrlb);
-
-	writel(CMD_NOP, &sdrc_base ->cs[cs].manual);
-	writel(CMD_PRECHARGE, &sdrc_base->cs[cs].manual);
-	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
-	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
-
-	/*
-	 * CAS latency 3, Write Burst = Read Burst, Serial Mode,
-	 * Burst length = 4
-	 */
-	writel(CASL3 | BURSTLENGTH4, &sdrc_base->cs[cs].mr);
-
-	if (!mem_ok(cs))
-		writel(0, &sdrc_base->cs[cs].mcfg);
-}
-
 void enable_gpmc_cs_config(const u32 *gpmc_config, struct gpmc_cs *cs, u32 base,
 			u32 size)
 {
diff --git a/cpu/arm_cortexa8/omap3/sdrc.c b/cpu/arm_cortexa8/omap3/sdrc.c
new file mode 100644
index 0000000..deef7da
--- /dev/null
+++ b/cpu/arm_cortexa8/omap3/sdrc.c
@@ -0,0 +1,174 @@
+/*
+ * Functions related to SDRC.
+ *
+ * This file has been created after exctracting and consolidating
+ * the SDRC related content from mem.c and board.c.
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+
+extern omap3_sysinfo sysinfo;
+
+static struct sdrc *sdrc_base = (struct sdrc *)OMAP34XX_SDRC_BASE;
+
+/**
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ */
+u32 is_mem_sdr(void)
+{
+	if (readl(&sdrc_base->cs[CS0].mr) == SDRC_MR_0_SDR)
+		return 1;
+	return 0;
+}
+
+/**
+ * get_sdr_cs_size() - get size of chip select 0/1
+ */
+u32 get_sdr_cs_size(u32 cs)
+{
+	u32 size;
+
+	/* get ram size field */
+	size = readl(&sdrc_base->cs[cs].mcfg) >> 8;
+	size &= 0x3FF;		/* remove unwanted bits */
+	size <<= 21;		/* multiply by 2 MiB to find size in MB */
+	return size;
+}
+
+/**
+ * get_sdr_cs_offset() - get offset of cs from cs0 start
+ */
+u32 get_sdr_cs_offset(u32 cs)
+{
+	u32 offset;
+
+	if (!cs)
+		return 0;
+
+	offset = readl(&sdrc_base->cs_cfg);
+	offset = (offset & 15) << 27 | (offset & 0x30) >> 17;
+
+	return offset;
+}
+
+/**
+ * do_sdrc_init(): initialize the SDRAM for use.
+ *  -Sets up SDRAM basic SDRC timings for CS0
+ *  -Optimal settings can be placed here, or redone after i2c
+ *      inspection of board info
+ *
+ *  - code called once in C-Stack only context for CS0 and a possible 2nd
+ *    time depending on memory configuration from stack+global context
+ */
+void do_sdrc_init(u32 cs, u32 early)
+{
+	struct sdrc_actim *sdrc_actim_base;
+
+	if(cs)
+		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL1_BASE;
+	else
+		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL0_BASE;
+
+	if (early) {
+		/* reset sdrc controller */
+		writel(SOFTRESET, &sdrc_base->sysconfig);
+		wait_on_value(RESETDONE, RESETDONE, &sdrc_base->status,
+			      12000000);
+		writel(0, &sdrc_base->sysconfig);
+
+		/* setup sdrc to ball mux */
+		writel(SDRC_SHARING, &sdrc_base->sharing);
+
+		/* Disable Power Down of CKE cuz of 1 CKE on combo part */
+		writel(WAKEUPPROC | SRFRONRESET | PAGEPOLICY_HIGH,
+				&sdrc_base->power);
+
+		writel(ENADLL | DLLPHASE_90, &sdrc_base->dlla_ctrl);
+		sdelay(0x20000);
+	}
+
+	writel(RASWIDTH_13BITS | CASWIDTH_10BITS | ADDRMUXLEGACY |
+		RAMSIZE_128 | BANKALLOCATION | B32NOT16 | B32NOT16 |
+		DEEPPD | DDR_SDRAM, &sdrc_base->cs[cs].mcfg);
+	writel(ARCV | ARE_ARCV_1, &sdrc_base->cs[cs].rfr_ctrl);
+	if (is_cpu_family(CPU_OMAP36XX)) {
+		writel(V_ACTIMA_200, &sdrc_actim_base->ctrla);
+		writel(V_ACTIMB_200, &sdrc_actim_base->ctrlb);
+	} else {
+		writel(V_ACTIMA_165, &sdrc_actim_base->ctrla);
+		writel(V_ACTIMB_165, &sdrc_actim_base->ctrlb);
+	}
+
+	writel(CMD_NOP, &sdrc_base ->cs[cs].manual);
+	writel(CMD_PRECHARGE, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+
+	/*
+	 * CAS latency 3, Write Burst = Read Burst, Serial Mode,
+	 * Burst length = 4
+	 */
+	writel(CASL3 | BURSTLENGTH4, &sdrc_base->cs[cs].mr);
+
+	if (!mem_ok(cs))
+		writel(0, &sdrc_base->cs[cs].mcfg);
+}
+
+/**
+ * dram_init - Sets uboots idea of sdram size
+ */
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+
+	size0 = get_sdr_cs_size(CS0);
+	/*
+	 * If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
+		do_sdrc_init(CS1, NOT_EARLY);
+		make_cs1_contiguous();
+
+		size1 = get_sdr_cs_size(CS1);
+	}
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+/**
+ * mem_init() - init the sdrc chip selects CS0 and CS1
+ *  - early init routines, called from flash or SRAM.
+ */
+void mem_init(void)
+{
+	/* only init up first bank here */
+	do_sdrc_init(CS0, EARLY_INIT);
+}
diff --git a/cpu/arm_cortexa8/omap3/sys_info.c b/cpu/arm_cortexa8/omap3/sys_info.c
index 31b2003..8d08691 100644
--- a/cpu/arm_cortexa8/omap3/sys_info.c
+++ b/cpu/arm_cortexa8/omap3/sys_info.c
@@ -29,10 +29,11 @@
 #include <asm/io.h>
 #include <asm/arch/mem.h>	/* get mem tables */
 #include <asm/arch/sys_proto.h>
+#include <asm/arch/omap_gpmc.h>
 #include <i2c.h>
 
 extern omap3_sysinfo sysinfo;
-static struct sdrc *sdrc_base = (struct sdrc *)OMAP34XX_SDRC_BASE;
+
 static struct ctrl *ctrl_base = (struct ctrl *)OMAP34XX_CTRL_BASE;
 static char *rev_s[CPU_3XX_MAX_REV] = {
 				"1.0",
@@ -41,6 +42,152 @@ static char *rev_s[CPU_3XX_MAX_REV] = {
 				"3.0",
 				"3.1"};
 
+static u16 cpu_family;
+static u16 cpu_id;
+static u8  cpu_revision;
+
+static u32 get_cpu_type(void);
+
+/**
+ * Identify the silicon
+ *
+ * It identifies the cpu family, exact cpu and silicon revision.
+ */
+void identify_cpu (void)
+{
+	u32 cpuid = 0;
+	u32 cputype;
+	u16 hawkeye;
+	struct ctrl_id *id_base;
+
+	/*
+	 * On ES1.0 the IDCODE register is not exposed on L4
+	 * so using CPU ID to differentiate between ES1.0 and > ES1.0.
+	 */
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
+	if ((cpuid & 0xf) == 0x0) {
+		cpu_family = CPU_OMAP34XX;
+		cpu_revision = CPU_3XX_ES10;
+	} else {
+		/* Decode the IDs on > ES1.0 */
+		id_base = (struct ctrl_id *) OMAP34XX_ID_L4_IO_BASE;
+
+		cpuid = readl(&id_base->idcode);
+
+		hawkeye  = (cpuid >> HAWKEYE_SHIFT) & 0xffff;
+		cpu_revision = (cpuid >> CPU_3XX_ID_SHIFT) & 0xf;
+
+		/*
+		 * Identify cpu family and revision
+		 */
+		switch (hawkeye) {
+		case HAWKEYE_OMAP34XX:
+			cpu_family = CPU_OMAP34XX;
+
+			/* Some early ES2.0 seem to report ID 0, fix this */
+			if(cpu_revision == 0)
+				cpu_revision = CPU_3XX_ES20;
+			break;
+
+		case HAWKEYE_AM35XX:
+			cpu_family = CPU_AM35XX;
+			break;
+
+		case HAWKEYE_OMAP36XX:
+			cpu_family = CPU_OMAP36XX;
+			break;
+
+		default:
+			cpu_family = CPU_OMAP34XX;
+			break;
+		}
+
+		cputype = get_cpu_type();
+		switch (cpu_family)
+		{
+		case CPU_OMAP34XX:
+			switch (cputype) {
+			case CTRL_OMAP3503:
+				cpu_id = OMAP3503;
+				break;
+			case CTRL_OMAP3515:
+				cpu_id = OMAP3515;
+				break;
+			case CTRL_OMAP3525:
+				cpu_id = OMAP3525;
+				break;
+			case CTRL_OMAP3530:
+				cpu_id = OMAP3430;	/* Same as OMAP3530 */
+				break;
+			default:
+				cpu_id = OMAP3430;
+				break;
+			}
+			break;
+
+		case CPU_AM35XX:
+			switch (cputype) {
+			case CTRL_AM3505:
+				cpu_id = AM3505;
+				break;
+			case CTRL_AM3517:
+				cpu_id = AM3517;
+				break;
+			default:
+				cpu_id = AM3505;
+				break;
+			}
+			break;
+
+		case CPU_OMAP36XX:
+			switch (cputype) {
+			case CTRL_OMAP3730:
+				cpu_id = OMAP3730;	/* Same as OMAP3630 */
+				break;
+			default:
+				cpu_id = OMAP3630;
+				break;
+			}
+			break;
+
+		default:
+			/*
+			 * Fall back to most common device
+			 */
+			cpu_id = OMAP3430;
+			break;
+		}
+	}
+}
+
+/**
+ * Perform architecture specific initialization
+ */
+int arch_cpu_init (void)
+{
+	/*
+	 * The identification done in s_init is 'lost' due to
+	 * relocation. The variable contents are not same.
+	 * Function identify_cpu() is called again.
+	 */
+	identify_cpu();
+
+	return 0;
+}
+
+/**
+ * Check if cpu belongs to specific family
+ *
+ * Returns 1 if true, 0 if false.
+ */
+u8 is_cpu_family(u16 family)
+{
+	if (cpu_family == family)
+		return 1;
+
+	return 0;
+}
+
 /*****************************************************************
  * dieid_num_r(void) - read and set die ID
  *****************************************************************/
@@ -70,7 +217,7 @@ void dieid_num_r(void)
 /******************************************
  * get_cpu_type(void) - extract cpu info
  ******************************************/
-u32 get_cpu_type(void)
+static u32 get_cpu_type(void)
 {
 	return readl(&ctrl_base->ctrl_omap_stat);
 }
@@ -78,70 +225,9 @@ u32 get_cpu_type(void)
 /******************************************
  * get_cpu_rev(void) - extract version info
  ******************************************/
-u32 get_cpu_rev(void)
+u8 get_cpu_rev(void)
 {
-	u32 cpuid = 0;
-	struct ctrl_id *id_base;
-
-	/*
-	 * On ES1.0 the IDCODE register is not exposed on L4
-	 * so using CPU ID to differentiate between ES1.0 and > ES1.0.
-	 */
-	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
-	if ((cpuid & 0xf) == 0x0)
-		return CPU_3XX_ES10;
-	else {
-		/* Decode the IDs on > ES1.0 */
-		id_base = (struct ctrl_id *) OMAP34XX_ID_L4_IO_BASE;
-
-		cpuid = (readl(&id_base->idcode) >> CPU_3XX_ID_SHIFT) & 0xf;
-
-		/* Some early ES2.0 seem to report ID 0, fix this */
-		if(cpuid == 0)
-			cpuid = CPU_3XX_ES20;
-
-		return cpuid;
-	}
-}
-
-/****************************************************
- * is_mem_sdr() - return 1 if mem type in use is SDR
- ****************************************************/
-u32 is_mem_sdr(void)
-{
-	if (readl(&sdrc_base->cs[CS0].mr) == SDP_SDRC_MR_0_SDR)
-		return 1;
-	return 0;
-}
-
-/***********************************************************************
- * get_cs0_size() - get size of chip select 0/1
- ************************************************************************/
-u32 get_sdr_cs_size(u32 cs)
-{
-	u32 size;
-
-	/* get ram size field */
-	size = readl(&sdrc_base->cs[cs].mcfg) >> 8;
-	size &= 0x3FF;		/* remove unwanted bits */
-	size <<= 21;		/* multiply by 2 MiB to find size in MB */
-	return size;
-}
-
-/***********************************************************************
- * get_sdr_cs_offset() - get offset of cs from cs0 start
- ************************************************************************/
-u32 get_sdr_cs_offset(u32 cs)
-{
-	u32 offset;
-
-	if (!cs)
-		return 0;
-
-	offset = readl(&sdrc_base->cs_cfg);
-	offset = (offset & 15) << 27 | (offset & 0x30) >> 17;
-
-	return offset;
+	return cpu_revision;
 }
 
 /***************************************************************************
@@ -254,45 +340,60 @@ u32 get_device_type(void)
  */
 int print_cpuinfo (void)
 {
-	char *cpu_s, *sec_s;
+	char cpu_s[16], sec_s[4];
 
-	switch (get_cpu_type()) {
+	switch (cpu_id) {
 	case OMAP3503:
-		cpu_s = "3503";
+		strcpy(cpu_s, "OMAP3503");
 		break;
 	case OMAP3515:
-		cpu_s = "3515";
+		strcpy(cpu_s, "OMAP3515");
 		break;
 	case OMAP3525:
-		cpu_s = "3525";
+		strcpy(cpu_s, "OMAP3503");
 		break;
+	case OMAP3430:
 	case OMAP3530:
-		cpu_s = "3530";
+		strcpy(cpu_s, "OMAP3430/3530");
 		break;
-	default:
-		cpu_s = "35XX";
+	case CTRL_AM3505:
+		strcpy(cpu_s, "AM3505");
+		break;
+	case CTRL_AM3517:
+		strcpy(cpu_s, "AM3517");
 		break;
+
+	default:
+		if (cpu_family == CPU_AM35XX)
+			strcpy(cpu_s, "AM35xx");
+		else
+			strcpy(cpu_s, "OMAP34xx/35xx");
 	}
 
 	switch (get_device_type()) {
 	case TST_DEVICE:
-		sec_s = "TST";
+		strcpy(sec_s, "TST");
 		break;
 	case EMU_DEVICE:
-		sec_s = "EMU";
+		strcpy(sec_s, "EMU");
 		break;
 	case HS_DEVICE:
-		sec_s = "HS";
+		strcpy(sec_s, "HS");
 		break;
 	case GP_DEVICE:
-		sec_s = "GP";
+		strcpy(sec_s, "GP");
 		break;
 	default:
-		sec_s = "?";
+		strcpy(sec_s, "?");
 	}
 
-	printf("OMAP%s-%s ES%s, CPU-OPP2 L3-165MHz\n",
-			cpu_s, sec_s, rev_s[get_cpu_rev()]);
+	/*
+	 * TBD: Revision numbers for AM35x may not be same as OMAP35x.
+	 *      Will need to re-look sometime later.
+	 */
+	printf("%s-%s ES%s,%s L3-165MHz\n",
+			cpu_s, sec_s, rev_s[get_cpu_rev()],
+			(cpu_family == CPU_AM35XX) ? "" : " CPU-OPP2");
 
 	return 0;
 }
diff --git a/cpu/ppc4xx/usbdev.c b/cpu/ppc4xx/usbdev.c
index 5bb4f3c..fe398af 100644
--- a/cpu/ppc4xx/usbdev.c
+++ b/cpu/ppc4xx/usbdev.c
@@ -21,7 +21,7 @@ void process_endpoints(unsigned short usb2d0_intrin)
 {
 	/*will hold the packet received */
 	struct usb_device_descriptor usb_device_packet;
-	struct usb_config_descriptor usb_config_packet;
+	struct usb_configuration_descriptor usb_config_packet;
 	struct usb_string_descriptor usb_string_packet;
 	struct devrequest setup_packet;
 	unsigned int *setup_packet_pt;
@@ -99,7 +99,7 @@ void process_endpoints(unsigned short usb2d0_intrin)
 				usb_config_packet.bConfigurationValue = 1;
 				usb_config_packet.iConfiguration = 0;
 				usb_config_packet.bmAttributes = 0x40;
-				usb_config_packet.MaxPower = 0;
+				usb_config_packet.bMaxPower = 0;
 
 				/*put packet in fifo */
 				packet_pt = (unsigned char *)&usb_config_packet;
diff --git a/drivers/mmc/omap3_mmc.c b/drivers/mmc/omap3_mmc.c
index 513dd25..96c0e65 100644
--- a/drivers/mmc/omap3_mmc.c
+++ b/drivers/mmc/omap3_mmc.c
@@ -63,7 +63,9 @@ unsigned char mmc_board_init(void)
 {
 	t2_t *t2_base = (t2_t *)T2_BASE;
 
+#if defined(CONFIG_TWL4030_POWER)
 	twl4030_power_mmc_init();
+#endif
 
 	writel(readl(&t2_base->pbias_lite) | PBIASLITEPWRDNZ1 |
 		PBIASSPEEDCTRL0 | PBIASLITEPWRDNZ0,
diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index fa8cee4..3f761ed 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -42,10 +42,22 @@
 #include <miiphy.h>
 #include <malloc.h>
 #include <asm/arch/emac_defs.h>
+#include "davinci_emac.h"
 
 unsigned int	emac_dbg = 0;
 #define debug_emac(fmt,args...)	if (emac_dbg) printf(fmt,##args)
 
+#ifdef EMAC_HW_RAM_ADDR
+#warning "Use different address for BD"
+#define BD_TO_HW(x)	\
+	( ( (x) == 0) ? 0 : ( (x) - EMAC_WRAPPER_RAM_ADDR + EMAC_HW_RAM_ADDR ))
+#define HW_TO_BD(x)	\
+	( ( (x) == 0) ? 0 : ( (x) - EMAC_HW_RAM_ADDR + EMAC_WRAPPER_RAM_ADDR ))
+#else
+#define BD_TO_HW(x)	(x)
+#define HW_TO_BD(x)	(x)
+#endif
+
 static void davinci_eth_mdio_enable(void);
 
 static int gen_init_phy(int phy_addr);
@@ -214,16 +226,42 @@ static int gen_get_link_speed(int phy_addr)
 static int gen_auto_negotiate(int phy_addr)
 {
 	u_int16_t	tmp;
+	u_int16_t	val;
+	unsigned int cntr = 0;
 
 	if (!davinci_eth_phy_read(phy_addr, PHY_BMCR, &tmp))
 		return(0);
 
+	val = tmp | PHY_BMCR_DPLX | PHY_BMCR_AUTON
+		| PHY_BMCR_100MB ;
+	davinci_eth_phy_write(phy_addr, PHY_BMCR, val);
+	davinci_eth_phy_read(phy_addr, PHY_BMCR, &val);
+
+	/* advertise 100 Full Duplex */
+	davinci_eth_phy_read(phy_addr,PHY_ANAR, &val);
+	val |= (PHY_ANLPAR_10 | PHY_ANLPAR_10FD | PHY_ANLPAR_TX
+		| PHY_ANLPAR_TXFD);
+	davinci_eth_phy_write(phy_addr,PHY_ANAR, val);
+	davinci_eth_phy_read(phy_addr,PHY_ANAR, &val);
+
+	davinci_eth_phy_read(phy_addr, PHY_BMCR, &tmp);
+
 	/* Restart Auto_negotiation  */
 	tmp |= PHY_BMCR_AUTON;
 	davinci_eth_phy_write(phy_addr, PHY_BMCR, tmp);
 
-	/*check AutoNegotiate complete */
-	udelay (10000);
+	/*check AutoNegotiate complete - it can take upto 3 secs*/
+	do{
+		udelay(40000);
+		cntr++;
+
+		if (davinci_eth_phy_read(phy_addr, PHY_BMSR, &tmp)){
+			if(tmp & PHY_BMSR_AUTN_COMP)
+				break;
+		}
+
+	}while(cntr < 250);
+
 	if (!davinci_eth_phy_read(phy_addr, PHY_BMSR, &tmp))
 		return(0);
 
@@ -255,16 +293,25 @@ static int davinci_eth_open(struct eth_device *dev, bd_t *bis)
 	dv_reg_p		addr;
 	u_int32_t		clkdiv, cnt;
 	volatile emac_desc	*rx_desc;
+	u_int16_t		lpa_val;
 
 	debug_emac("+ emac_open\n");
 
 	/* Reset EMAC module and disable interrupts in wrapper */
 	adap_emac->SOFTRESET = 1;
 	while (adap_emac->SOFTRESET != 0) {;}
+
+#if (defined(CONFIG_SOC_DM646x) || defined(CONFIG_SOC_DM365) || \
+     defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+
+	adap_ewrap->SOFTRST = 1;
+	while (adap_ewrap->SOFTRST != 0) {;}
+#else
 	adap_ewrap->EWCTL = 0;
 	for (cnt = 0; cnt < 5; cnt++) {
 		clkdiv = adap_ewrap->EWCTL;
 	}
+#endif
 
 	rx_desc = emac_rx_desc;
 
@@ -279,9 +326,16 @@ static int davinci_eth_open(struct eth_device *dev, bd_t *bis)
 		(davinci_eth_mac_addr[2] << 16) |
 		(davinci_eth_mac_addr[1] << 8)  |
 		(davinci_eth_mac_addr[0]);
+#if (defined(CONFIG_SOC_DM646x) || defined(CONFIG_SOC_DM365) || \
+     defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+	adap_emac->MACADDRLO =
+		(davinci_eth_mac_addr[5] << 8) |
+		(davinci_eth_mac_addr[4]| (1 << 19) | (1 << 20));
+#else
 	adap_emac->MACADDRLO =
 		(davinci_eth_mac_addr[5] << 8) |
 		(davinci_eth_mac_addr[4]);
+#endif
 
 	adap_emac->MACHASH1 = 0;
 	adap_emac->MACHASH2 = 0;
@@ -300,7 +354,6 @@ static int davinci_eth_open(struct eth_device *dev, bd_t *bis)
 	addr = &adap_emac->TX0HDP;
 	for(cnt = 0; cnt < 16; cnt++)
 		*addr++ = 0;
-
 	addr = &adap_emac->RX0HDP;
 	for(cnt = 0; cnt < 16; cnt++)
 		*addr++ = 0;
@@ -317,7 +370,7 @@ static int davinci_eth_open(struct eth_device *dev, bd_t *bis)
 	/* Create RX queue and set receive process in place */
 	emac_rx_active_head = emac_rx_desc;
 	for (cnt = 0; cnt < EMAC_MAX_RX_BUFFERS; cnt++) {
-		rx_desc->next = (u_int32_t)(rx_desc + 1);
+		rx_desc->next = BD_TO_HW((u_int32_t)(rx_desc + 1));
 		rx_desc->buffer = &emac_rx_buffers[cnt * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
 		rx_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
 		rx_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
@@ -340,18 +393,33 @@ static int davinci_eth_open(struct eth_device *dev, bd_t *bis)
 	/* Enable ch 0 only */
 	adap_emac->RXUNICASTSET = 0x01;
 
-	/* Enable MII interface and Full duplex mode */
-	adap_emac->MACCONTROL = (EMAC_MACCONTROL_MIIEN_ENABLE | EMAC_MACCONTROL_FULLDUPLEX_ENABLE);
-
 	/* Init MDIO & get link state */
 	clkdiv = (EMAC_MDIO_BUS_FREQ / EMAC_MDIO_CLOCK_FREQ) - 1;
 	adap_mdio->CONTROL = ((clkdiv & 0xff) | MDIO_CONTROL_ENABLE | MDIO_CONTROL_FAULT);
 
-	if (!phy.get_link_speed(active_phy_addr))
+	if (!phy.auto_negotiate(active_phy_addr))
 		return(0);
 
+	davinci_eth_phy_read(active_phy_addr,PHY_ANLPAR,&lpa_val);
+	if (lpa_val & (PHY_ANLPAR_10FD | PHY_ANLPAR_TXFD) ) {
+		/* set EMAC for Full Duplex  */
+		adap_emac->MACCONTROL = EMAC_MACCONTROL_MIIEN_ENABLE |
+					 EMAC_MACCONTROL_FULLDUPLEX_ENABLE;
+	}else{
+		/*set EMAC for Half Duplex  */
+		adap_emac->MACCONTROL = EMAC_MACCONTROL_MIIEN_ENABLE;
+	}
+
+#ifdef CONFIG_DRIVER_TI_EMAC_USE_RMII
+	if (lpa_val & (PHY_ANLPAR_TXFD | PHY_ANLPAR_TX) ) {
+		adap_emac->MACCONTROL |= EMAC_MACCONTROL_RMIISPEED_100;
+	} else {
+		adap_emac->MACCONTROL &= ~EMAC_MACCONTROL_RMIISPEED_100;
+	}
+#endif
+
 	/* Start receive process */
-	adap_emac->RX0HDP = (u_int32_t)emac_rx_desc;
+	adap_emac->RX0HDP = BD_TO_HW((u_int32_t)emac_rx_desc);
 
 	debug_emac("- emac_open\n");
 
@@ -411,8 +479,13 @@ static void davinci_eth_close(struct eth_device *dev)
 
 	/* Reset EMAC module and disable interrupts in wrapper */
 	adap_emac->SOFTRESET = 1;
-	adap_ewrap->EWCTL = 0;
 
+#if (defined(CONFIG_SOC_DM646x) || defined(CONFIG_SOC_DM365) ||  \
+     defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+	adap_ewrap->SOFTRST = 1;
+#else
+	adap_ewrap->EWCTL = 0;
+#endif
 	debug_emac("- emac_close\n");
 }
 
@@ -449,7 +522,7 @@ static int davinci_eth_send_packet (struct eth_device *dev,
 				      EMAC_CPPI_OWNERSHIP_BIT |
 				      EMAC_CPPI_EOP_BIT);
 	/* Send the packet */
-	adap_emac->TX0HDP = (unsigned int) emac_tx_desc;
+	adap_emac->TX0HDP = BD_TO_HW((unsigned int) emac_tx_desc);
 
 	/* Wait for packet to complete or link down */
 	while (1) {
@@ -490,15 +563,15 @@ static int davinci_eth_rcv_packet (struct eth_device *dev)
 		}
 
 		/* Ack received packet descriptor */
-		adap_emac->RX0CP = (unsigned int) rx_curr_desc;
+		adap_emac->RX0CP = BD_TO_HW((unsigned int) rx_curr_desc);
 		curr_desc = rx_curr_desc;
 		emac_rx_active_head =
-			(volatile emac_desc *) rx_curr_desc->next;
+			(volatile emac_desc *) (HW_TO_BD(rx_curr_desc->next));
 
 		if (status & EMAC_CPPI_EOQ_BIT) {
 			if (emac_rx_active_head) {
 				adap_emac->RX0HDP =
-					(unsigned int) emac_rx_active_head;
+				BD_TO_HW((unsigned int) emac_rx_active_head);
 			} else {
 				emac_rx_queue_active = 0;
 				printf ("INFO:emac_rcv_packet: RX Queue not active\n");
@@ -516,23 +589,24 @@ static int davinci_eth_rcv_packet (struct eth_device *dev)
 			emac_rx_active_tail = curr_desc;
 			if (emac_rx_queue_active != 0) {
 				adap_emac->RX0HDP =
-					(unsigned int) emac_rx_active_head;
+					BD_TO_HW((unsigned int) emac_rx_active_head);
 				printf ("INFO: emac_rcv_pkt: active queue head = 0, HDP fired\n");
 				emac_rx_queue_active = 1;
 			}
 		} else {
 			tail_desc = emac_rx_active_tail;
 			emac_rx_active_tail = curr_desc;
-			tail_desc->next = (unsigned int) curr_desc;
+			tail_desc->next = BD_TO_HW((unsigned int) curr_desc);
 			status = tail_desc->pkt_flag_len;
 			if (status & EMAC_CPPI_EOQ_BIT) {
-				adap_emac->RX0HDP = (unsigned int) curr_desc;
+				adap_emac->RX0HDP = BD_TO_HW((unsigned int) curr_desc);
 				status &= ~EMAC_CPPI_EOQ_BIT;
 				tail_desc->pkt_flag_len = status;
 			}
 		}
 		return (ret);
 	}
+
 	return (0);
 }
 
@@ -554,6 +628,7 @@ int davinci_emac_initialize(void)
 		return -1;
 
 	memset(dev, 0, sizeof *dev);
+	sprintf(dev->name, "DaVinci EMAC");
 
 	dev->iobase = 0;
 	dev->init = davinci_eth_open;
@@ -596,6 +671,7 @@ int davinci_emac_initialize(void)
 	phy_id |= tmp & 0x0000ffff;
 
 	switch (phy_id) {
+	#if defined(PHY_LXT972)
 		case PHY_LXT972:
 			sprintf(phy.name, "LXT972 @ 0x%02x", active_phy_addr);
 			phy.init = lxt972_init_phy;
@@ -603,6 +679,8 @@ int davinci_emac_initialize(void)
 			phy.get_link_speed = lxt972_get_link_speed;
 			phy.auto_negotiate = lxt972_auto_negotiate;
 			break;
+	#endif
+	#if defined(PHY_DP83848)
 		case PHY_DP83848:
 			sprintf(phy.name, "DP83848 @ 0x%02x", active_phy_addr);
 			phy.init = dp83848_init_phy;
@@ -610,6 +688,7 @@ int davinci_emac_initialize(void)
 			phy.get_link_speed = dp83848_get_link_speed;
 			phy.auto_negotiate = dp83848_auto_negotiate;
 			break;
+	#endif
 		default:
 			sprintf(phy.name, "GENERIC @ 0x%02x", active_phy_addr);
 			phy.init = gen_init_phy;
diff --git a/drivers/net/davinci_emac.h b/drivers/net/davinci_emac.h
new file mode 100644
index 0000000..d1d19e1
--- /dev/null
+++ b/drivers/net/davinci_emac.h
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on:
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+
+#ifndef _DAVINCI_EMAC_H_
+#define _DAVINCI_EMAC_H_
+
+#define REG(addr)       (*(volatile unsigned int *)(addr))
+#define REG_P(addr)     ((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int   dv_reg;
+typedef volatile unsigned int * dv_reg_p;
+
+/* Keep only Arch/Soc Independent definitions here */
+
+/* Ethernet Min/Max packet size */
+#define EMAC_MIN_ETHERNET_PKT_SIZE	60
+#define EMAC_MAX_ETHERNET_PKT_SIZE	1518
+#define EMAC_PKT_ALIGN			18	/* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
+
+/* Number of RX packet buffers
+ * NOTE: Only 1 buffer supported as of now
+ */
+#define EMAC_MAX_RX_BUFFERS		10
+
+
+/***********************************************
+ ******** Internally used macros ***************
+ ***********************************************/
+
+#define EMAC_CH_TX			1
+#define EMAC_CH_RX			0
+
+/* Each descriptor occupies 4 words, lets start RX desc's at 0 and
+ * reserve space for 64 descriptors max
+ */
+#define EMAC_RX_DESC_BASE		0x0
+#define EMAC_TX_DESC_BASE		0x1000
+
+/* EMAC Teardown value */
+#define EMAC_TEARDOWN_VALUE		0xfffffffc
+
+/* MII Status Register */
+#define MII_STATUS_REG			1
+
+/* Number of statistics registers */
+#define EMAC_NUM_STATS			36
+
+
+/* EMAC Descriptor */
+typedef volatile struct _emac_desc
+{
+	u_int32_t	next;		/* Pointer to next descriptor in chain */
+	u_int8_t	*buffer;	/* Pointer to data buffer */
+	u_int32_t	buff_off_len;	/* Buffer Offset(MSW) and Length(LSW) */
+	u_int32_t	pkt_flag_len;	/* Packet Flags(MSW) and Length(LSW) */
+} emac_desc;
+
+/* CPPI bit positions */
+#define EMAC_CPPI_SOP_BIT		(0x80000000)
+#define EMAC_CPPI_EOP_BIT		(0x40000000)
+#define EMAC_CPPI_OWNERSHIP_BIT		(0x20000000)
+#define EMAC_CPPI_EOQ_BIT		(0x10000000)
+#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT	(0x08000000)
+#define EMAC_CPPI_PASS_CRC_BIT		(0x04000000)
+
+#define EMAC_CPPI_RX_ERROR_FRAME	(0x03fc0000)
+
+#define EMAC_MACCONTROL_MIIEN_ENABLE		(0x20)
+#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE	(0x1)
+#define EMAC_MACCONTROL_GIGABIT_ENABLE		(1 << 7)
+#define EMAC_MACCONTROL_GIGFORCE		(1 << 17)
+#define EMAC_MACCONTROL_RMIISPEED_100		(1 << 15)
+
+#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE	(0x200000)
+#define EMAC_RXMBPENABLE_RXBROADEN	(0x2000)
+
+
+#define MDIO_CONTROL_IDLE		(0x80000000)
+#define MDIO_CONTROL_ENABLE		(0x40000000)
+#define MDIO_CONTROL_FAULT_ENABLE	(0x40000)
+#define MDIO_CONTROL_FAULT		(0x80000)
+#define MDIO_USERACCESS0_GO		(0x80000000)
+#define MDIO_USERACCESS0_WRITE_READ	(0x0)
+#define MDIO_USERACCESS0_WRITE_WRITE	(0x40000000)
+#define MDIO_USERACCESS0_ACK		(0x20000000)
+
+/* Ethernet MAC Registers Structure */
+typedef struct  {
+	dv_reg		TXIDVER;
+	dv_reg		TXCONTROL;
+	dv_reg		TXTEARDOWN;
+	u_int8_t	RSVD0[4];
+	dv_reg		RXIDVER;
+	dv_reg		RXCONTROL;
+	dv_reg		RXTEARDOWN;
+	u_int8_t	RSVD1[100];
+	dv_reg		TXINTSTATRAW;
+	dv_reg		TXINTSTATMASKED;
+	dv_reg		TXINTMASKSET;
+	dv_reg		TXINTMASKCLEAR;
+	dv_reg		MACINVECTOR;
+	u_int8_t	RSVD2[12];
+	dv_reg		RXINTSTATRAW;
+	dv_reg		RXINTSTATMASKED;
+	dv_reg		RXINTMASKSET;
+	dv_reg		RXINTMASKCLEAR;
+	dv_reg		MACINTSTATRAW;
+	dv_reg		MACINTSTATMASKED;
+	dv_reg		MACINTMASKSET;
+	dv_reg		MACINTMASKCLEAR;
+	u_int8_t	RSVD3[64];
+	dv_reg		RXMBPENABLE;
+	dv_reg		RXUNICASTSET;
+	dv_reg		RXUNICASTCLEAR;
+	dv_reg		RXMAXLEN;
+	dv_reg		RXBUFFEROFFSET;
+	dv_reg		RXFILTERLOWTHRESH;
+	u_int8_t	RSVD4[8];
+	dv_reg		RX0FLOWTHRESH;
+	dv_reg		RX1FLOWTHRESH;
+	dv_reg		RX2FLOWTHRESH;
+	dv_reg		RX3FLOWTHRESH;
+	dv_reg		RX4FLOWTHRESH;
+	dv_reg		RX5FLOWTHRESH;
+	dv_reg		RX6FLOWTHRESH;
+	dv_reg		RX7FLOWTHRESH;
+	dv_reg		RX0FREEBUFFER;
+	dv_reg		RX1FREEBUFFER;
+	dv_reg		RX2FREEBUFFER;
+	dv_reg		RX3FREEBUFFER;
+	dv_reg		RX4FREEBUFFER;
+	dv_reg		RX5FREEBUFFER;
+	dv_reg		RX6FREEBUFFER;
+	dv_reg		RX7FREEBUFFER;
+	dv_reg		MACCONTROL;
+	dv_reg		MACSTATUS;
+	dv_reg		EMCONTROL;
+	dv_reg		FIFOCONTROL;
+	dv_reg		MACCONFIG;
+	dv_reg		SOFTRESET ;
+	u_int8_t	RSVD5[88];
+	dv_reg		MACSRCADDRLO;
+	dv_reg		MACSRCADDRHI;
+	dv_reg		MACHASH1;
+	dv_reg		MACHASH2;
+	dv_reg		BOFFTEST;
+	dv_reg		TPACETEST;
+	dv_reg		RXPAUSE;
+	dv_reg		TXPAUSE;
+	u_int8_t	RSVD6[16];
+	dv_reg		RXGOODFRAMES;
+	dv_reg		RXBCASTFRAMES;
+	dv_reg		RXMCASTFRAMES;
+	dv_reg		RXPAUSEFRAMES;
+	dv_reg		RXCRCERRORS;
+	dv_reg		RXALIGNCODEERRORS;
+	dv_reg		RXOVERSIZED;
+	dv_reg		RXJABBER;
+	dv_reg		RXUNDERSIZED;
+	dv_reg		RXFRAGMENTS;
+	dv_reg		RXFILTERED;
+	dv_reg		RXQOSFILTERED;
+	dv_reg		RXOCTETS;
+	dv_reg		TXGOODFRAMES;
+	dv_reg		TXBCASTFRAMES;
+	dv_reg		TXMCASTFRAMES;
+	dv_reg		TXPAUSEFRAMES;
+	dv_reg		TXDEFERRED;
+	dv_reg		TXCOLLISION;
+	dv_reg		TXSINGLECOLL;
+	dv_reg		TXMULTICOLL;
+	dv_reg		TXEXCESSIVECOLL;
+	dv_reg		TXLATECOLL;
+	dv_reg		TXUNDERRUN;
+	dv_reg		TXCARRIERSENSE;
+	dv_reg		TXOCTETS;
+	dv_reg		FRAME64;
+	dv_reg		FRAME65T127;
+	dv_reg		FRAME128T255;
+	dv_reg		FRAME256T511;
+	dv_reg		FRAME512T1023;
+	dv_reg		FRAME1024TUP;
+	dv_reg		NETOCTETS;
+	dv_reg		RXSOFOVERRUNS;
+	dv_reg		RXMOFOVERRUNS;
+	dv_reg		RXDMAOVERRUNS;
+	u_int8_t	RSVD7[624];
+	dv_reg		MACADDRLO;
+	dv_reg		MACADDRHI;
+	dv_reg		MACINDEX;
+	u_int8_t	RSVD8[244];
+	dv_reg		TX0HDP;
+	dv_reg		TX1HDP;
+	dv_reg		TX2HDP;
+	dv_reg		TX3HDP;
+	dv_reg		TX4HDP;
+	dv_reg		TX5HDP;
+	dv_reg		TX6HDP;
+	dv_reg		TX7HDP;
+	dv_reg		RX0HDP;
+	dv_reg		RX1HDP;
+	dv_reg		RX2HDP;
+	dv_reg		RX3HDP;
+	dv_reg		RX4HDP;
+	dv_reg		RX5HDP;
+	dv_reg		RX6HDP;
+	dv_reg		RX7HDP;
+	dv_reg		TX0CP;
+	dv_reg		TX1CP;
+	dv_reg		TX2CP;
+	dv_reg		TX3CP;
+	dv_reg		TX4CP;
+	dv_reg		TX5CP;
+	dv_reg		TX6CP;
+	dv_reg		TX7CP;
+	dv_reg		RX0CP;
+	dv_reg		RX1CP;
+	dv_reg		RX2CP;
+	dv_reg		RX3CP;
+	dv_reg		RX4CP;
+	dv_reg		RX5CP;
+	dv_reg		RX6CP;
+	dv_reg		RX7CP;
+} emac_regs;
+
+/* EMAC Wrapper Registers Structure */
+typedef struct  {
+#if (defined(CONFIG_SOC_DM646x) || defined(CONFIG_SOC_DM365) || \
+     defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+	dv_reg		IDVER;
+	dv_reg		SOFTRST;
+	dv_reg		EMCTRL;
+#else
+	u_int8_t	RSVD0[4100];
+	dv_reg		EWCTL;
+	dv_reg		EWINTTCNT;
+#endif
+} ewrap_regs;
+
+/* EMAC MDIO Registers Structure */
+typedef struct  {
+	dv_reg		VERSION;
+	dv_reg		CONTROL;
+	dv_reg		ALIVE;
+	dv_reg		LINK;
+	dv_reg		LINKINTRAW;
+	dv_reg		LINKINTMASKED;
+	u_int8_t	RSVD0[8];
+	dv_reg		USERINTRAW;
+	dv_reg		USERINTMASKED;
+	dv_reg		USERINTMASKSET;
+	dv_reg		USERINTMASKCLEAR;
+	u_int8_t	RSVD1[80];
+	dv_reg		USERACCESS0;
+	dv_reg		USERPHYSEL0;
+	dv_reg		USERACCESS1;
+	dv_reg		USERPHYSEL1;
+} mdio_regs;
+
+int davinci_eth_phy_read(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t *data);
+int davinci_eth_phy_write(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t data);
+
+typedef struct
+{
+	char	name[64];
+	int	(*init)(int phy_addr);
+	int	(*is_phy_connected)(int phy_addr);
+	int	(*get_link_speed)(int phy_addr);
+	int	(*auto_negotiate)(int phy_addr);
+} phy_t;
+
+#endif  /* _DAVINCI_EMAC_H_ */
diff --git a/drivers/serial/usbtty.h b/drivers/serial/usbtty.h
index f746d63..6b6c4a1 100644
--- a/drivers/serial/usbtty.h
+++ b/drivers/serial/usbtty.h
@@ -29,6 +29,8 @@
 #include <usb/mpc8xx_udc.h>
 #elif defined(CONFIG_OMAP1510)
 #include <usb/omap1510_udc.h>
+#elif defined(CONFIG_MUSB_UDC)
+#include <usb/musb_udc.h>
 #elif defined(CONFIG_PXA27X)
 #include <usb/pxa27x_udc.h>
 #endif
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 324c308..ba85991 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -96,7 +96,7 @@ static struct descriptor {
 				 * UE_DIR_IN | EHCI_INTR_ENDPT
 				 */
 		3,		/* bmAttributes: UE_INTERRUPT */
-		8, 0,		/* wMaxPacketSize */
+		8,		/* wMaxPacketSize */
 		255		/* bInterval */
 	},
 };
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 09e0a5f..b433127 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -26,7 +26,10 @@ include $(TOPDIR)/config.mk
 LIB	:= $(obj)libusb_musb.a
 
 COBJS-$(CONFIG_MUSB_HCD) += musb_hcd.o musb_core.o
+COBJS-$(CONFIG_MUSB_UDC) += musb_udc.o musb_core.o
 COBJS-$(CONFIG_USB_DAVINCI) += davinci.o
+COBJS-$(CONFIG_USB_OMAP3) += omap3.o
+COBJS-$(CONFIG_USB_AM3517) += am3517.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/usb/musb/am3517.c b/drivers/usb/musb/am3517.c
new file mode 100644
index 0000000..ab5e76a
--- /dev/null
+++ b/drivers/usb/musb/am3517.c
@@ -0,0 +1,126 @@
+/*
+ * TI's AM3517 platform specific USB wrapper functions.
+ *
+ * Copyright (c) 2009 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Ajay Kumar Gupta ajay.gupta@ti.com, Texas Instruments
+ */
+
+#include <common.h>
+#include "am3517.h"
+
+/* MUSB platform configuration */
+struct musb_config musb_cfg = {
+	(struct	musb_regs *)MENTOR_BASE,
+	MUSB_TIMEOUT,
+	0,
+	0
+};
+
+/* MUSB module register overlay */
+struct am3517_usb_regs *regs;
+
+/*
+ * Enable the USB phy
+ */
+static u8 phy_on(void)
+{
+	u32 cfgchip0;
+	u32 timeout;
+
+	/*
+	 * Start the on-chip PHY and its PLL.
+	 */
+	cfgchip0 = readl(OMAP3517_CONF0);
+
+	cfgchip0 &= ~(0x0000FFFF);
+	writel(cfgchip0, OMAP3517_CONF0);
+	cfgchip0 = readl(OMAP3517_CONF0);
+
+	cfgchip0 &= ~(CONF0_RESET | CONF0_PHYPWRDN | CONF0_OTGPWRDN |
+		      CONF0_OTGMODE | CONF0_REFFREQ | CONF0_PHY_GPIOMODE);
+	cfgchip0 |= CONF0_SESENDEN | CONF0_VBDTCTEN | CONF0_PHY_PLLON |
+		    CONF0_REFFREQ_13MHZ | CONF0_DATPOL;
+	writel(cfgchip0, OMAP3517_CONF0);
+
+	/* Wait until the USB phy is turned on */
+	timeout = musb_cfg.timeout;
+	while (timeout--)
+		if (readl(OMAP3517_CONF0) & CONF0_PHYCLKGD)
+			return 1;
+
+	/* USB phy was not turned on */
+	return 0;
+}
+
+/*
+ * Disable the USB phy
+ */
+static void phy_off(void)
+{
+	u32 cfgchip0;
+
+	/*
+	 * Power down the on-chip PHY.
+	 */
+	cfgchip0 = readl(OMAP3517_CONF0);
+
+	cfgchip0 &= ~CONF0_PHY_PLLON;
+	cfgchip0 |= CONF0_PHYPWRDN | CONF0_OTGPWRDN;
+	writel(cfgchip0, OMAP3517_CONF0);
+}
+
+/*
+ * This function performs platform specific initialization for usb0.
+ */
+int musb_platform_init(void)
+{
+	u32 revision;
+	u32 sw_reset;
+
+	/* global usb reset */
+	sw_reset = readl(OMAP3517_IP_SW_RESET);
+	sw_reset |= (1 << 0);
+	writel(sw_reset, OMAP3517_IP_SW_RESET);
+	sw_reset &= ~(1 << 0);
+	writel(sw_reset, OMAP3517_IP_SW_RESET);
+
+	/* reset the controller */
+	regs = (struct am3517_usb_regs *)MUSB_BASE;
+	writel(USB_SOFT_RESET_MASK, &regs->control);
+	udelay(5000);
+
+	if (!phy_on())
+		return -1;
+
+	/* Returns zero if e.g. not clocked */
+	revision = readl(&regs->revision);
+	if (!revision)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * This function performs platform specific deinitialization for usb0.
+ */
+void musb_platform_deinit(void)
+{
+	/* Turn of the phy */
+	phy_off();
+}
diff --git a/drivers/usb/musb/am3517.h b/drivers/usb/musb/am3517.h
new file mode 100644
index 0000000..0d693ec
--- /dev/null
+++ b/drivers/usb/musb/am3517.h
@@ -0,0 +1,97 @@
+/*
+ * TI's AM3517 platform specific USB wrapper functions.
+ *
+ * Copyright (c) 2009 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Ajay Kumar Gupta ajay.gupta@ti.com, Texas Instruments
+ */
+
+#ifndef __AM3517_USB_H__
+#define __AM3517_USB_H__
+
+#include "musb_core.h"
+
+/* Base address of musb wrapper */
+#define MUSB_BASE 0x5C040000
+
+/* Base address of musb core */
+#define MENTOR_BASE (MUSB_BASE+0x400)
+
+/* Base address of system control register used to program phy */
+#define OMAP3517_CONF0	0x48002580
+#define OMAP3517_IP_SW_RESET	0x48002598
+/*
+ * AM3517 platform USB wrapper register overlay. Note: Only the required
+ * registers are included in this structure. It can be expanded as required.
+ */
+struct am3517_usb_regs {
+	u32	revision;
+	u32	control;
+	u32	status;
+	u32	emulation;
+	u32	reserved0[1];
+	u32	autoreq;
+	u32	srpfixtime;
+	u32	ep_intsrc;
+	u32	ep_intsrcset;
+	u32	ep_intsrcclr;
+	u32	ep_intmsk;
+	u32	ep_intmskset;
+	u32	ep_intmskclr;
+	u32	ep_intsrcmsked;
+	u32	reserved1[1];
+	u32	core_intsrc;
+	u32	core_intsrcset;
+	u32	core_intsrcclr;
+	u32	core_intmsk;
+	u32	core_intmskset;
+	u32	core_intmskclr;
+	u32	core_intsrcmsked;
+	u32	reserved2[1];
+	u32	eoi;
+	u32	mop_sop_en;
+	u32	reserved3[2];
+	u32	txmode;
+	u32	rxmode;
+	u32	epcount_mode;
+};
+
+/* Control register bits */
+#define USB_SOFT_RESET_MASK	1
+
+/* Timeout for MUSB module */
+#define MUSB_TIMEOUT 0x3FFFFFF
+
+/* USB 2.0 PHY Control */
+#define CONF0_PHY_GPIOMODE     (1 << 23)
+#define CONF0_OTGMODE          (3 << 14)
+#define CONF0_SESENDEN         (1 << 13)       /* Vsess_end comparator */
+#define CONF0_VBDTCTEN         (1 << 12)       /* Vbus comparator */
+#define CONF0_REFFREQ_24MHZ    (2 << 8)
+#define CONF0_REFFREQ_26MHZ    (7 << 8)
+#define CONF0_REFFREQ_13MHZ    (6 << 8)
+#define CONF0_REFFREQ          (0xf << 8)
+#define CONF0_PHYCLKGD         (1 << 7)
+#define CONF0_VBUSSENSE        (1 << 6)
+#define CONF0_PHY_PLLON        (1 << 5)        /* override PLL suspend */
+#define CONF0_RESET            (1 << 4)
+#define CONF0_PHYPWRDN         (1 << 3)
+#define CONF0_OTGPWRDN         (1 << 2)
+#define CONF0_DATPOL           (1 << 1)
+
+#endif	/* __AM3517_USB_H__ */
diff --git a/drivers/usb/musb/davinci.c b/drivers/usb/musb/davinci.c
index a7648fc..ee08963 100644
--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -29,6 +29,7 @@
 struct musb_config musb_cfg = {
 	(struct	musb_regs *)MENTOR_USB0_BASE,
 	DAVINCI_USB_TIMEOUT,
+	0,
 	0
 };
 
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index ec57fc8..094ae0f 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -32,7 +32,10 @@ struct musb_regs *musbr;
  */
 void musb_start(void)
 {
+#if defined(CONFIG_MUSB_HCD)
 	u8 devctl;
+	u8 busctl;
+#endif
 
 	/* disable all interrupts */
 	writew(0, &musbr->intrtxe);
@@ -43,6 +46,12 @@ void musb_start(void)
 	/* put into basic highspeed mode and start session */
 	writeb(MUSB_POWER_HSENAB, &musbr->power);
 #if defined(CONFIG_MUSB_HCD)
+	/* Program PHY to use EXT VBUS if required */
+	if (musb_cfg.extvbus == 1) {
+		busctl = readb(&musbr->ulpi_busctl);
+		writeb(busctl | ULPI_USE_EXTVBUS, &musbr->ulpi_busctl);
+	}
+
 	devctl = readb(&musbr->devctl);
 	writeb(devctl | MUSB_DEVCTL_SESSION, &musbr->devctl);
 #endif
@@ -74,9 +83,10 @@ void musb_configure_ep(struct musb_epinfo *epinfo, u8 cnt)
 			/* Configure fifo size and fifo base address */
 			writeb(idx, &musbr->txfifosz);
 			writew(fifoaddr >> 3, &musbr->txfifoadd);
+
+			csr = readw(&musbr->txcsr);
 #if defined(CONFIG_MUSB_HCD)
 			/* clear the data toggle bit */
-			csr = readw(&musbr->txcsr);
 			writew(csr | MUSB_TXCSR_CLRDATATOG, &musbr->txcsr);
 #endif
 			/* Flush fifo if required */
@@ -87,9 +97,10 @@ void musb_configure_ep(struct musb_epinfo *epinfo, u8 cnt)
 			/* Configure fifo size and fifo base address */
 			writeb(idx, &musbr->rxfifosz);
 			writew(fifoaddr >> 3, &musbr->rxfifoadd);
+
+			csr = readw(&musbr->rxcsr);
 #if defined(CONFIG_MUSB_HCD)
 			/* clear the data toggle bit */
-			csr = readw(&musbr->rxcsr);
 			writew(csr | MUSB_RXCSR_CLRDATATOG, &musbr->rxcsr);
 #endif
 			/* Flush fifo if required */
@@ -131,11 +142,33 @@ void write_fifo(u8 ep, u32 length, void *fifo_data)
 void read_fifo(u8 ep, u32 length, void *fifo_data)
 {
 	u8  *data = (u8 *)fifo_data;
+#if (defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+	int i;
+	u32 val;
+#endif
 
 	/* select the endpoint index */
 	writeb(ep, &musbr->index);
 
 	/* read the data to the fifo */
+#if (defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+	/* AM3517 FIFO should be read double word wise as bytewise
+	 * FIFO read corrupts the FIFO
+	 */
+	if (length > 4) {
+		for (i = 0; i < (length >> 2); i++) {
+			val = readl(&musbr->fifox[ep]);
+			memcpy(data, &val, 4);
+			data += 4;
+		}
+		length %= 4;
+	}
+	if (length > 0) {
+		val = readl(&musbr->fifox[ep]);
+		memcpy(data, &val, length);
+	}
+#else
 	while (length--)
 		*data++ = readb(&musbr->fifox[ep]);
+#endif
 }
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f9da3f0..20c8984 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -40,6 +40,36 @@
 
 #define MUSB_EP0_FIFOSIZE	64	/* This is non-configurable */
 
+/* EP0 */
+struct musb_ep0_regs {
+	u16	reserved4;
+	u16	csr0;
+	u16	reserved5;
+	u16	reserved6;
+	u16	count0;
+	u8	host_type0;
+	u8	host_naklimit0;
+	u8	reserved7;
+	u8	reserved8;
+	u8	reserved9;
+	u8	configdata;
+};
+
+/* EP 1-15 */
+struct musb_epN_regs {
+	u16	txmaxp;
+	u16	txcsr;
+	u16	rxmaxp;
+	u16	rxcsr;
+	u16	rxcount;
+	u8	txtype;
+	u8	txinterval;
+	u8	rxtype;
+	u8	rxinterval;
+	u8	reserved0;
+	u8	fifosize;
+};
+
 /* Mentor USB core register overlay structure */
 struct musb_regs {
 	/* common registers */
@@ -77,7 +107,10 @@ struct musb_regs {
 	u16	rxfifoadd;
 	u32	vcontrol;
 	u16	hwvers;
-	u16	reserved2[5];
+	u16	reserved2a[1];
+	u8	ulpi_busctl;
+	u8	reserved2b[1];
+	u16	reserved2[3];
 	u8	epinfo;
 	u8	raminfo;
 	u8	linkinfo;
@@ -97,6 +130,16 @@ struct musb_regs {
 		u8	rxhubaddr;
 		u8	rxhubport;
 	} tar[16];
+	/*
+	 * end point registers
+	 * ep0 elements are valid when array index is 0
+	 * otherwise epN is valid
+	 */
+	union musb_ep_regs {
+		struct musb_ep0_regs ep0;
+		struct musb_epN_regs epN;
+	} ep[16];
+
 } __attribute__((aligned(32)));
 
 /*
@@ -135,6 +178,10 @@ struct musb_regs {
 #define MUSB_DEVCTL_HR		0x02
 #define MUSB_DEVCTL_SESSION	0x01
 
+/* ULPI VBUSCONTROL */
+#define ULPI_USE_EXTVBUS	0x01
+#define ULPI_USE_EXTVBUSIND	0x02
+
 /* TESTMODE */
 #define MUSB_TEST_FORCE_HOST	0x80
 #define MUSB_TEST_FIFO_ACCESS	0x40
@@ -295,6 +342,7 @@ struct musb_config {
 	struct	musb_regs	*regs;
 	u32			timeout;
 	u8			musb_speed;
+	u8			extvbus;
 };
 
 /* externally defined data */
diff --git a/drivers/usb/musb/musb_debug.h b/drivers/usb/musb/musb_debug.h
new file mode 100644
index 0000000..62380ff
--- /dev/null
+++ b/drivers/usb/musb/musb_debug.h
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Define MUSB_DEBUG before including this file to get debug macros */
+#ifdef MUSB_DEBUG
+
+#define MUSB_FLAGS_PRINT(v, x, y)		\
+  if (((v) & MUSB_##x##_##y))			\
+		serial_printf("\t\t"#y"\n")
+
+static inline void musb_print_pwr(u8 b)
+{
+	serial_printf("\tpower   0x%2.2x\n", b);
+	MUSB_FLAGS_PRINT(b, POWER, ISOUPDATE);
+	MUSB_FLAGS_PRINT(b, POWER, SOFTCONN);
+	MUSB_FLAGS_PRINT(b, POWER, HSENAB);
+	MUSB_FLAGS_PRINT(b, POWER, HSMODE);
+	MUSB_FLAGS_PRINT(b, POWER, RESET);
+	MUSB_FLAGS_PRINT(b, POWER, RESUME);
+	MUSB_FLAGS_PRINT(b, POWER, SUSPENDM);
+	MUSB_FLAGS_PRINT(b, POWER, ENSUSPEND);
+}
+
+static inline void musb_print_csr0(u16 w)
+{
+	serial_printf("\tcsr0    0x%4.4x\n", w);
+	MUSB_FLAGS_PRINT(w, CSR0, FLUSHFIFO);
+	MUSB_FLAGS_PRINT(w, CSR0_P, SVDSETUPEND);
+	MUSB_FLAGS_PRINT(w, CSR0_P, SVDRXPKTRDY);
+	MUSB_FLAGS_PRINT(w, CSR0_P, SENDSTALL);
+	MUSB_FLAGS_PRINT(w, CSR0_P, SETUPEND);
+	MUSB_FLAGS_PRINT(w, CSR0_P, DATAEND);
+	MUSB_FLAGS_PRINT(w, CSR0_P, SENTSTALL);
+	MUSB_FLAGS_PRINT(w, CSR0, TXPKTRDY);
+	MUSB_FLAGS_PRINT(w, CSR0, RXPKTRDY);
+}
+
+static inline void musb_print_intrusb(u8 b)
+{
+	serial_printf("\tintrusb 0x%2.2x\n", b);
+	MUSB_FLAGS_PRINT(b, INTR, VBUSERROR);
+	MUSB_FLAGS_PRINT(b, INTR, SESSREQ);
+	MUSB_FLAGS_PRINT(b, INTR, DISCONNECT);
+	MUSB_FLAGS_PRINT(b, INTR, CONNECT);
+	MUSB_FLAGS_PRINT(b, INTR, SOF);
+	MUSB_FLAGS_PRINT(b, INTR, RESUME);
+	MUSB_FLAGS_PRINT(b, INTR, SUSPEND);
+
+	if (b & MUSB_INTR_BABBLE)
+		serial_printf("\t\tMUSB_INTR_RESET or MUSB_INTR_BABBLE\n");
+
+}
+
+static inline void musb_print_intrtx(u16 w)
+{
+	serial_printf("\tintrtx 0x%4.4x\n", w);
+}
+
+static inline void musb_print_intrrx(u16 w)
+{
+	serial_printf("\tintrx 0x%4.4x\n", w);
+}
+
+static inline void musb_print_devctl(u8 b)
+{
+	serial_printf("\tdevctl  0x%2.2x\n", b);
+	if (b & MUSB_DEVCTL_BDEVICE)
+		serial_printf("\t\tB device\n");
+	else
+		serial_printf("\t\tA device\n");
+	if (b & MUSB_DEVCTL_FSDEV)
+		serial_printf("\t\tFast Device -(host mode)\n");
+	if (b & MUSB_DEVCTL_LSDEV)
+		serial_printf("\t\tSlow Device -(host mode)\n");
+	if (b & MUSB_DEVCTL_HM)
+		serial_printf("\t\tHost mode\n");
+	else
+		serial_printf("\t\tPeripherial mode\n");
+	if (b & MUSB_DEVCTL_HR)
+		serial_printf("\t\tHost request started(B device)\n");
+	else
+		serial_printf("\t\tHost request finished(B device)\n");
+	if (b & MUSB_DEVCTL_BDEVICE) {
+		if (b & MUSB_DEVCTL_SESSION)
+			serial_printf("\t\tStart of session(B device)\n");
+		else
+			serial_printf("\t\tEnd of session(B device)\n");
+	} else {
+		if (b & MUSB_DEVCTL_SESSION)
+			serial_printf("\t\tStart of session(A device)\n");
+		else
+			serial_printf("\t\tEnd of session(A device)\n");
+	}
+}
+
+static inline void musb_print_config(u8 b)
+{
+	serial_printf("\tconfig 0x%2.2x\n", b);
+	if (b & MUSB_CONFIGDATA_MPRXE)
+		serial_printf("\t\tAuto combine rx bulk packets\n");
+	if (b & MUSB_CONFIGDATA_MPTXE)
+		serial_printf("\t\tAuto split tx bulk packets\n");
+	if (b & MUSB_CONFIGDATA_BIGENDIAN)
+		serial_printf("\t\tBig Endian ordering\n");
+	else
+		serial_printf("\t\tLittle Endian ordering\n");
+	if (b & MUSB_CONFIGDATA_HBRXE)
+		serial_printf("\t\tHigh speed rx iso endpoint\n");
+	if (b & MUSB_CONFIGDATA_HBTXE)
+		serial_printf("\t\tHigh speed tx iso endpoint\n");
+	if (b & MUSB_CONFIGDATA_DYNFIFO)
+		serial_printf("\t\tDynamic fifo sizing\n");
+	if (b & MUSB_CONFIGDATA_SOFTCONE)
+		serial_printf("\t\tSoft Connect\n");
+	if (b & MUSB_CONFIGDATA_UTMIDW)
+		serial_printf("\t\t16 bit data width\n");
+	else
+		serial_printf("\t\t8 bit data width\n");
+}
+
+static inline void musb_print_rxmaxp(u16 w)
+{
+	serial_printf("\trxmaxp  0x%4.4x\n", w);
+}
+
+static inline void musb_print_rxcsr(u16 w)
+{
+	serial_printf("\trxcsr   0x%4.4x\n", w);
+	MUSB_FLAGS_PRINT(w, RXCSR, AUTOCLEAR);
+	MUSB_FLAGS_PRINT(w, RXCSR, DMAENAB);
+	MUSB_FLAGS_PRINT(w, RXCSR, DISNYET);
+	MUSB_FLAGS_PRINT(w, RXCSR, PID_ERR);
+	MUSB_FLAGS_PRINT(w, RXCSR, DMAMODE);
+	MUSB_FLAGS_PRINT(w, RXCSR, CLRDATATOG);
+	MUSB_FLAGS_PRINT(w, RXCSR, FLUSHFIFO);
+	MUSB_FLAGS_PRINT(w, RXCSR, DATAERROR);
+	MUSB_FLAGS_PRINT(w, RXCSR, FIFOFULL);
+	MUSB_FLAGS_PRINT(w, RXCSR, RXPKTRDY);
+	MUSB_FLAGS_PRINT(w, RXCSR_P, SENTSTALL);
+	MUSB_FLAGS_PRINT(w, RXCSR_P, SENDSTALL);
+	MUSB_FLAGS_PRINT(w, RXCSR_P, OVERRUN);
+
+	if (w & MUSB_RXCSR_P_ISO)
+		serial_printf("\t\tiso mode\n");
+	else
+		serial_printf("\t\tbulk mode\n");
+
+}
+
+static inline void musb_print_txmaxp(u16 w)
+{
+	serial_printf("\ttxmaxp  0x%4.4x\n", w);
+}
+
+static inline void musb_print_txcsr(u16 w)
+{
+	serial_printf("\ttxcsr   0x%4.4x\n", w);
+	MUSB_FLAGS_PRINT(w, TXCSR, TXPKTRDY);
+	MUSB_FLAGS_PRINT(w, TXCSR, FIFONOTEMPTY);
+	MUSB_FLAGS_PRINT(w, TXCSR, FLUSHFIFO);
+	MUSB_FLAGS_PRINT(w, TXCSR, CLRDATATOG);
+	MUSB_FLAGS_PRINT(w, TXCSR_P, UNDERRUN);
+	MUSB_FLAGS_PRINT(w, TXCSR_P, SENTSTALL);
+	MUSB_FLAGS_PRINT(w, TXCSR_P, SENDSTALL);
+
+	if (w & MUSB_TXCSR_MODE)
+		serial_printf("\t\tTX mode\n");
+	else
+		serial_printf("\t\tRX mode\n");
+}
+
+#else
+
+/* stubs */
+
+#define musb_print_pwr(b)
+#define musb_print_csr0(w)
+#define musb_print_intrusb(b)
+#define musb_print_intrtx(w)
+#define musb_print_intrrx(w)
+#define musb_print_devctl(b)
+#define musb_print_config(b)
+#define musb_print_rxmaxp(w)
+#define musb_print_rxcsr(w)
+#define musb_print_txmaxp(w)
+#define musb_print_txcsr(w)
+
+#endif /* MUSB_DEBUG */
diff --git a/drivers/usb/musb/musb_hcd.c b/drivers/usb/musb/musb_hcd.c
index 4ca94cb..555d2dc 100644
--- a/drivers/usb/musb/musb_hcd.c
+++ b/drivers/usb/musb/musb_hcd.c
@@ -803,7 +803,7 @@ void usb_event_poll()
 {
 	struct stdio_dev *dev;
 	struct usb_device *usb_kbd_dev;
-	struct usb_interface_descriptor *iface;
+	struct usb_interface *iface;
 	struct usb_endpoint_descriptor *ep;
 	int pipe;
 	int maxp;
diff --git a/drivers/usb/musb/musb_udc.c b/drivers/usb/musb/musb_udc.c
new file mode 100644
index 0000000..746e0b5
--- /dev/null
+++ b/drivers/usb/musb/musb_udc.c
@@ -0,0 +1,966 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This file is a rewrite of the usb device part of
+ * repository git.omapzoom.org/repo/u-boot.git, branch master,
+ * file cpu/omap3/fastboot.c
+ *
+ * This is the unique part of its copyright :
+ *
+ * -------------------------------------------------------------------------
+ *
+ * (C) Copyright 2008 - 2009
+ * Windriver, <www.windriver.com>
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * -------------------------------------------------------------------------
+ *
+ * The details of connecting the device to the uboot usb device subsystem
+ * came from the old omap3 repository www.sakoman.net/u-boot-omap3.git,
+ * branch omap3-dev-usb, file drivers/usb/usbdcore_musb.c
+ *
+ * This is the unique part of its copyright :
+ *
+ * -------------------------------------------------------------------------
+ *
+ * (C) Copyright 2008 Texas Instruments Incorporated.
+ *
+ * Based on
+ * u-boot OMAP1510 USB drivers (drivers/usbdcore_omap1510.c)
+ * twl4030 init based on linux (drivers/i2c/chips/twl4030_usb.c)
+ *
+ * Author: Diego Dompe (diego.dompe@ridgerun.com)
+ *         Atin Malaviya (atin.malaviya@gmail.com)
+ *
+ * -------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <usb/musb_udc.h>
+#include "../gadget/ep0.h"
+#include "musb_core.h"
+#if defined(CONFIG_USB_OMAP3)
+#include "omap3.h"
+#elif defined(CONFIG_USB_AM3517)
+#include "am3517.h"
+#elif defined(CONFIG_USB_DAVINCI)
+#include "davinci.h"
+#endif
+#include "omap3.h"
+
+/* Define MUSB_DEBUG for debugging */
+/* #define MUSB_DEBUG */
+#include "musb_debug.h"
+
+#define MAX_ENDPOINT 15
+
+#define GET_ENDPOINT(dev,ep)						\
+(((struct usb_device_instance *)(dev))->bus->endpoint_array + ep)
+
+#define SET_EP0_STATE(s)						\
+do {									\
+	if ((0 <= (s)) && (SET_ADDRESS >= (s))) {			\
+		if ((s) != ep0_state) {					\
+			if ((debug_setup) && (debug_level > 1))		\
+				serial_printf("INFO : Changing state "  \
+					      "from %s to %s in %s at " \
+					      "line %d\n",		\
+					      ep0_state_strings[ep0_state],\
+					      ep0_state_strings[s],	\
+					      __PRETTY_FUNCTION__,	\
+					      __LINE__);		\
+			ep0_state = s;					\
+		}							\
+	} else {							\
+		if (debug_level > 0)					\
+			serial_printf("Error at %s %d with setting "	\
+				      "state %d is invalid\n",		\
+				      __PRETTY_FUNCTION__, __LINE__, s); \
+	}								\
+} while (0)
+
+/* static implies these initialized to 0 or NULL */
+static int debug_setup;
+static int debug_level;
+static struct musb_epinfo epinfo[MAX_ENDPOINT * 2];
+static enum ep0_state_enum {
+	IDLE = 0,
+	TX,
+	RX,
+	SET_ADDRESS
+} ep0_state = IDLE;
+static char *ep0_state_strings[4] = {
+	"IDLE",
+	"TX",
+	"RX",
+	"SET_ADDRESS",
+};
+
+static struct urb *ep0_urb;
+struct usb_endpoint_instance *ep0_endpoint;
+static struct usb_device_instance *udc_device;
+static int enabled;
+
+#ifdef MUSB_DEBUG
+static void musb_db_regs(void)
+{
+	u8 b;
+	u16 w;
+
+	b = readb(&musbr->faddr);
+	serial_printf("\tfaddr   0x%2.2x\n", b);
+
+	b = readb(&musbr->power);
+	musb_print_pwr(b);
+
+	w = readw(&musbr->ep[0].ep0.csr0);
+	musb_print_csr0(w);
+
+	b = readb(&musbr->devctl);
+	musb_print_devctl(b);
+
+	b = readb(&musbr->ep[0].ep0.configdata);
+	musb_print_config(b);
+
+	w = readw(&musbr->frame);
+	serial_printf("\tframe   0x%4.4x\n", w);
+
+	b = readb(&musbr->index);
+	serial_printf("\tindex   0x%2.2x\n", b);
+
+	w = readw(&musbr->ep[1].epN.rxmaxp);
+	musb_print_rxmaxp(w);
+
+	w = readw(&musbr->ep[1].epN.rxcsr);
+	musb_print_rxcsr(w);
+
+	w = readw(&musbr->ep[1].epN.txmaxp);
+	musb_print_txmaxp(w);
+
+	w = readw(&musbr->ep[1].epN.txcsr);
+	musb_print_txcsr(w);
+}
+#else
+#define musb_db_regs()
+#endif /* DEBUG_MUSB */
+
+static void musb_peri_softconnect(void)
+{
+	u8 power, devctl;
+	u8 intrusb;
+	u16 intrrx, intrtx;
+
+	/* Power off MUSB */
+	power = readb(&musbr->power);
+	power &= ~MUSB_POWER_SOFTCONN;
+	writeb(power, &musbr->power);
+
+	/* Read intr to clear */
+	intrusb = readb(&musbr->intrusb);
+	intrrx = readw(&musbr->intrrx);
+	intrtx = readw(&musbr->intrtx);
+
+	udelay(1000 * 1000); /* 1 sec */
+
+	/* Power on MUSB */
+	power = readb(&musbr->power);
+	power |= MUSB_POWER_SOFTCONN;
+	/*
+	 * The usb device interface is usb 1.1
+	 * Disable 2.0 high speed by clearring the hsenable bit.
+	 */
+	power &= ~MUSB_POWER_HSENAB;
+	writeb(power, &musbr->power);
+
+	/* Check if device is in b-peripheral mode */
+	devctl = readb(&musbr->devctl);
+	if (!(devctl & MUSB_DEVCTL_BDEVICE) ||
+	    (devctl & MUSB_DEVCTL_HM)) {
+		serial_printf("ERROR : Unsupport USB mode\n");
+		serial_printf("Check that mini-B USB cable is attached "
+			      "to the device\n");
+	}
+
+	if (debug_setup && (debug_level > 1))
+		musb_db_regs();
+}
+
+static void musb_peri_reset(void)
+{
+	if ((debug_setup) && (debug_level > 1))
+		serial_printf("INFO : %s reset\n", __PRETTY_FUNCTION__);
+
+	if (ep0_endpoint)
+		ep0_endpoint->endpoint_address = 0xff;
+
+	/* Sync sw and hw addresses */
+	writeb(udc_device->address, &musbr->faddr);
+
+	SET_EP0_STATE(IDLE);
+}
+
+static void musb_peri_resume(void)
+{
+	/* noop */
+}
+
+static void musb_peri_ep0_stall(void)
+{
+	u16 csr0;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	csr0 |= MUSB_CSR0_P_SENDSTALL;
+	writew(csr0, &musbr->ep[0].ep0.csr0);
+	if ((debug_setup) && (debug_level > 1))
+		serial_printf("INFO : %s stall\n", __PRETTY_FUNCTION__);
+}
+
+static void musb_peri_ep0_ack_req(void)
+{
+	u16 csr0;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	csr0 |= MUSB_CSR0_P_SVDRXPKTRDY;
+	writew(csr0, &musbr->ep[0].ep0.csr0);
+}
+
+static void musb_ep0_tx_ready(void)
+{
+	u16 csr0;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	csr0 |= MUSB_CSR0_TXPKTRDY;
+	writew(csr0, &musbr->ep[0].ep0.csr0);
+}
+
+static void musb_ep0_tx_ready_and_last(void)
+{
+	u16 csr0;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	csr0 |= (MUSB_CSR0_TXPKTRDY | MUSB_CSR0_P_DATAEND);
+	writew(csr0, &musbr->ep[0].ep0.csr0);
+}
+
+static void musb_peri_ep0_last(void)
+{
+	u16 csr0;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	csr0 |= MUSB_CSR0_P_DATAEND;
+	writew(csr0, &musbr->ep[0].ep0.csr0);
+}
+
+static void musb_peri_ep0_set_address(void)
+{
+	u8 faddr;
+	writeb(udc_device->address, &musbr->faddr);
+
+	/* Verify */
+	faddr = readb(&musbr->faddr);
+	if (udc_device->address == faddr) {
+		SET_EP0_STATE(IDLE);
+		usbd_device_event_irq(udc_device, DEVICE_ADDRESS_ASSIGNED, 0);
+		if ((debug_setup) && (debug_level > 1))
+			serial_printf("INFO : %s Address set to %d\n",
+				      __PRETTY_FUNCTION__, udc_device->address);
+	} else {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s Address missmatch "
+				      "sw %d vs hw %d\n",
+				      __PRETTY_FUNCTION__,
+				      udc_device->address, faddr);
+	}
+}
+
+static void musb_peri_rx_ack(unsigned int ep)
+{
+	u16 peri_rxcsr;
+
+	peri_rxcsr = readw(&musbr->ep[ep].epN.rxcsr);
+	peri_rxcsr &= ~MUSB_RXCSR_RXPKTRDY;
+	writew(peri_rxcsr, &musbr->ep[ep].epN.rxcsr);
+}
+
+static void musb_peri_tx_ready(unsigned int ep)
+{
+	u16 peri_txcsr;
+
+	peri_txcsr = readw(&musbr->ep[ep].epN.txcsr);
+	peri_txcsr |= MUSB_TXCSR_TXPKTRDY;
+	writew(peri_txcsr, &musbr->ep[ep].epN.txcsr);
+}
+
+static void musb_peri_ep0_zero_data_request(int err)
+{
+	musb_peri_ep0_ack_req();
+
+	if (err) {
+		musb_peri_ep0_stall();
+		SET_EP0_STATE(IDLE);
+	} else {
+
+		musb_peri_ep0_last();
+
+		/* USBD state */
+		switch (ep0_urb->device_request.bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			if ((debug_setup) && (debug_level > 1))
+				serial_printf("INFO : %s received set "
+					      "address\n", __PRETTY_FUNCTION__);
+			break;
+
+		case USB_REQ_SET_CONFIGURATION:
+			if ((debug_setup) && (debug_level > 1))
+				serial_printf("INFO : %s Configured\n",
+					      __PRETTY_FUNCTION__);
+			usbd_device_event_irq(udc_device, DEVICE_CONFIGURED, 0);
+			break;
+		}
+
+		/* EP0 state */
+		if (USB_REQ_SET_ADDRESS == ep0_urb->device_request.bRequest) {
+			SET_EP0_STATE(SET_ADDRESS);
+		} else {
+			SET_EP0_STATE(IDLE);
+		}
+	}
+}
+
+static void musb_peri_ep0_rx_data_request(void)
+{
+	/*
+	 * This is the completion of the data OUT / RX
+	 *
+	 * Host is sending data to ep0 that is not
+	 * part of setup.  This comes from the cdc_recv_setup
+	 * op that is device specific.
+	 *
+	 */
+	musb_peri_ep0_ack_req();
+
+	ep0_endpoint->rcv_urb = ep0_urb;
+	ep0_urb->actual_length = 0;
+	SET_EP0_STATE(RX);
+}
+
+static void musb_peri_ep0_tx_data_request(int err)
+{
+	if (err) {
+		musb_peri_ep0_stall();
+		SET_EP0_STATE(IDLE);
+	} else {
+		musb_peri_ep0_ack_req();
+
+		ep0_endpoint->tx_urb = ep0_urb;
+		ep0_endpoint->sent = 0;
+		SET_EP0_STATE(TX);
+	}
+}
+
+static void musb_peri_ep0_idle(void)
+{
+	u16 count0;
+	int err;
+	u16 csr0;
+
+	/*
+	 * Verify addresses
+	 * A lot of confusion can be caused if the address
+	 * in software, udc layer, does not agree with the
+	 * hardware.  Since the setting of the hardware address
+	 * must be set after the set address request, the
+	 * usb state machine is out of sync for a few frame.
+	 * It is a good idea to run this check when changes
+	 * are made to the state machine.
+	 */
+	if ((debug_level > 0) &&
+	    (ep0_state != SET_ADDRESS)) {
+		u8 faddr;
+
+		faddr = readb(&musbr->faddr);
+		if (udc_device->address != faddr) {
+			serial_printf("ERROR : %s addresses do not"
+				      "match sw %d vs hw %d\n",
+				      __PRETTY_FUNCTION__,
+				      udc_device->address, faddr);
+			udelay(1000 * 1000);
+			hang();
+		}
+	}
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+
+	if (!(MUSB_CSR0_RXPKTRDY & csr0))
+		goto end;
+
+	count0 = readw(&musbr->ep[0].ep0.count0);
+	if (count0 == 0)
+		goto end;
+
+	if (count0 != 8) {
+		if ((debug_setup) && (debug_level > 1))
+			serial_printf("WARN : %s SETUP incorrect size %d\n",
+				      __PRETTY_FUNCTION__, count0);
+		musb_peri_ep0_stall();
+		goto end;
+	}
+
+	read_fifo(0, count0, &ep0_urb->device_request);
+
+	if (debug_level > 2)
+		print_usb_device_request(&ep0_urb->device_request);
+
+	if (ep0_urb->device_request.wLength == 0) {
+		err = ep0_recv_setup(ep0_urb);
+
+		/* Zero data request */
+		musb_peri_ep0_zero_data_request(err);
+	} else {
+		/* Is data coming or going ? */
+		u8 reqType = ep0_urb->device_request.bmRequestType;
+
+		if (USB_REQ_DEVICE2HOST == (reqType & USB_REQ_DIRECTION_MASK)) {
+			err = ep0_recv_setup(ep0_urb);
+			/* Device to host */
+			musb_peri_ep0_tx_data_request(err);
+		} else {
+			/*
+			 * Host to device
+			 *
+			 * The RX routine will call ep0_recv_setup
+			 * when the data packet has arrived.
+			 */
+			musb_peri_ep0_rx_data_request();
+		}
+	}
+
+end:
+	return;
+}
+
+static void musb_peri_ep0_rx(void)
+{
+	/*
+	 * This is the completion of the data OUT / RX
+	 *
+	 * Host is sending data to ep0 that is not
+	 * part of setup.  This comes from the cdc_recv_setup
+	 * op that is device specific.
+	 *
+	 * Pass the data back to driver ep0_recv_setup which
+	 * should give the cdc_recv_setup the chance to handle
+	 * the rx
+	 */
+	u16 csr0;
+	u16 count0;
+
+	if (debug_level > 3) {
+		if (0 != ep0_urb->actual_length) {
+			serial_printf("%s finished ? %d of %d\n",
+				      __PRETTY_FUNCTION__,
+				      ep0_urb->actual_length,
+				      ep0_urb->device_request.wLength);
+		}
+	}
+
+	if (ep0_urb->device_request.wLength == ep0_urb->actual_length) {
+		musb_peri_ep0_last();
+		SET_EP0_STATE(IDLE);
+		ep0_recv_setup(ep0_urb);
+		return;
+	}
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+	if (!(MUSB_CSR0_RXPKTRDY & csr0))
+		return;
+
+	count0 = readw(&musbr->ep[0].ep0.count0);
+
+	if (count0) {
+		struct usb_endpoint_instance *endpoint;
+		u32 length;
+		u8 *data;
+
+		endpoint = ep0_endpoint;
+		if (endpoint && endpoint->rcv_urb) {
+			struct urb *urb = endpoint->rcv_urb;
+			unsigned int remaining_space = urb->buffer_length -
+				urb->actual_length;
+
+			if (remaining_space) {
+				int urb_bad = 0; /* urb is good */
+
+				if (count0 > remaining_space)
+					length = remaining_space;
+				else
+					length = count0;
+
+				data = (u8 *) urb->buffer_data;
+				data += urb->actual_length;
+
+				/* The common musb fifo reader */
+				read_fifo(0, length, data);
+
+				musb_peri_ep0_ack_req();
+
+				/*
+				 * urb's actual_length is updated in
+				 * usbd_rcv_complete
+				 */
+				usbd_rcv_complete(endpoint, length, urb_bad);
+
+			} else {
+				if (debug_level > 0)
+					serial_printf("ERROR : %s no space in "
+						      "rcv buffer\n",
+						      __PRETTY_FUNCTION__);
+			}
+		} else {
+			if (debug_level > 0)
+				serial_printf("ERROR : %s problem with "
+					      "endpoint\n",
+					      __PRETTY_FUNCTION__);
+		}
+	} else {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s with nothing to do\n",
+				      __PRETTY_FUNCTION__);
+	}
+}
+
+static void musb_peri_ep0_tx(void)
+{
+	u16 csr0;
+	int transfer_size = 0;
+	unsigned int p, pm;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+
+	/* Check for pending tx */
+	if (csr0 & MUSB_CSR0_TXPKTRDY)
+		goto end;
+
+	/* Check if this is the last packet sent */
+	if (ep0_endpoint->sent >= ep0_urb->actual_length) {
+		SET_EP0_STATE(IDLE);
+		goto end;
+	}
+
+	transfer_size = ep0_urb->actual_length - ep0_endpoint->sent;
+	/* Is the transfer size negative ? */
+	if (transfer_size <= 0) {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s problem with the"
+				      " transfer size %d\n",
+				      __PRETTY_FUNCTION__,
+				      transfer_size);
+		SET_EP0_STATE(IDLE);
+		goto end;
+	}
+
+	/* Truncate large transfers to the fifo size */
+	if (transfer_size > ep0_endpoint->tx_packetSize)
+		transfer_size = ep0_endpoint->tx_packetSize;
+
+	write_fifo(0, transfer_size, &ep0_urb->buffer[ep0_endpoint->sent]);
+	ep0_endpoint->sent += transfer_size;
+
+	/* Done or more to send ? */
+	if (ep0_endpoint->sent >= ep0_urb->actual_length)
+		musb_ep0_tx_ready_and_last();
+	else
+		musb_ep0_tx_ready();
+
+	/* Wait a bit */
+	pm = 10;
+	for (p = 0; p < pm; p++) {
+		csr0 = readw(&musbr->ep[0].ep0.csr0);
+		if (!(csr0 & MUSB_CSR0_TXPKTRDY))
+			break;
+
+		/* Double the delay. */
+		udelay(1 << pm);
+	}
+
+	if ((ep0_endpoint->sent >= ep0_urb->actual_length) && (p < pm))
+		SET_EP0_STATE(IDLE);
+
+end:
+	return;
+}
+
+static void musb_peri_ep0(void)
+{
+	u16 csr0;
+
+	if (SET_ADDRESS == ep0_state)
+		return;
+
+	csr0 = readw(&musbr->ep[0].ep0.csr0);
+
+	/* Error conditions */
+	if (MUSB_CSR0_P_SENTSTALL & csr0) {
+		csr0 &= ~MUSB_CSR0_P_SENTSTALL;
+		writew(csr0, &musbr->ep[0].ep0.csr0);
+		SET_EP0_STATE(IDLE);
+	}
+	if (MUSB_CSR0_P_SETUPEND & csr0) {
+		csr0 |= MUSB_CSR0_P_SVDSETUPEND;
+		writew(csr0, &musbr->ep[0].ep0.csr0);
+		SET_EP0_STATE(IDLE);
+		if ((debug_setup) && (debug_level > 1))
+			serial_printf("WARN: %s SETUPEND\n",
+				      __PRETTY_FUNCTION__);
+	}
+
+	/* Normal states */
+	if (IDLE == ep0_state)
+		musb_peri_ep0_idle();
+
+	if (TX == ep0_state)
+		musb_peri_ep0_tx();
+
+	if (RX == ep0_state)
+		musb_peri_ep0_rx();
+}
+
+static void musb_peri_rx_ep(unsigned int ep)
+{
+	u16 peri_rxcount = readw(&musbr->ep[ep].epN.rxcount);
+
+	if (peri_rxcount) {
+		struct usb_endpoint_instance *endpoint;
+		u32 length;
+		u8 *data;
+
+		endpoint = GET_ENDPOINT(udc_device, ep);
+		if (endpoint && endpoint->rcv_urb) {
+			struct urb *urb = endpoint->rcv_urb;
+			unsigned int remaining_space = urb->buffer_length -
+				urb->actual_length;
+
+			if (remaining_space) {
+				int urb_bad = 0; /* urb is good */
+
+				if (peri_rxcount > remaining_space)
+					length = remaining_space;
+				else
+					length = peri_rxcount;
+
+				data = (u8 *) urb->buffer_data;
+				data += urb->actual_length;
+
+				/* The common musb fifo reader */
+				read_fifo(ep, length, data);
+
+				musb_peri_rx_ack(ep);
+
+				/*
+				 * urb's actual_length is updated in
+				 * usbd_rcv_complete
+				 */
+				usbd_rcv_complete(endpoint, length, urb_bad);
+
+			} else {
+				if (debug_level > 0)
+					serial_printf("ERROR : %s %d no space "
+						      "in rcv buffer\n",
+						      __PRETTY_FUNCTION__, ep);
+			}
+		} else {
+			if (debug_level > 0)
+				serial_printf("ERROR : %s %d problem with "
+					      "endpoint\n",
+					      __PRETTY_FUNCTION__, ep);
+		}
+
+	} else {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s %d with nothing to do\n",
+				      __PRETTY_FUNCTION__, ep);
+	}
+}
+
+static void musb_peri_rx(u16 intr)
+{
+	unsigned int ep;
+
+	/* Check for EP0 */
+	if (0x01 & intr)
+		musb_peri_ep0();
+
+	for (ep = 1; ep < 16; ep++) {
+		if ((1 << ep) & intr)
+			musb_peri_rx_ep(ep);
+	}
+}
+
+static void musb_peri_tx(u16 intr)
+{
+	/* Check for EP0 */
+	if (0x01 & intr)
+		musb_peri_ep0_tx();
+
+	/*
+	 * Use this in the future when handling epN tx
+	 *
+	 * u8 ep;
+	 *
+	 * for (ep = 1; ep < 16; ep++) {
+	 *	if ((1 << ep) & intr) {
+	 *		/ * handle tx for this endpoint * /
+	 *	}
+	 * }
+	 */
+}
+
+void udc_irq(void)
+{
+	/* This is a high freq called function */
+	if (enabled) {
+		u8 intrusb;
+
+		intrusb = readb(&musbr->intrusb);
+
+		/*
+		 * See drivers/usb/gadget/mpc8xx_udc.c for
+		 * state diagram going from detached through
+		 * configuration.
+		 */
+		if (MUSB_INTR_RESUME & intrusb) {
+			usbd_device_event_irq(udc_device,
+					      DEVICE_BUS_ACTIVITY, 0);
+			musb_peri_resume();
+		}
+
+		musb_peri_ep0();
+
+		if (MUSB_INTR_RESET & intrusb) {
+			usbd_device_event_irq(udc_device, DEVICE_RESET, 0);
+			musb_peri_reset();
+		}
+
+		if (MUSB_INTR_DISCONNECT & intrusb) {
+			/* cable unplugged from hub/host */
+			usbd_device_event_irq(udc_device, DEVICE_RESET, 0);
+			musb_peri_reset();
+			usbd_device_event_irq(udc_device, DEVICE_HUB_RESET, 0);
+		}
+
+		if (MUSB_INTR_SOF & intrusb) {
+			usbd_device_event_irq(udc_device,
+					      DEVICE_BUS_ACTIVITY, 0);
+			musb_peri_resume();
+		}
+
+		if (MUSB_INTR_SUSPEND & intrusb) {
+			usbd_device_event_irq(udc_device,
+					      DEVICE_BUS_INACTIVE, 0);
+		}
+
+		if (ep0_state != SET_ADDRESS) {
+			u16 intrrx, intrtx;
+
+			intrrx = readw(&musbr->intrrx);
+			intrtx = readw(&musbr->intrtx);
+
+			if (intrrx)
+				musb_peri_rx(intrrx);
+
+			if (intrtx)
+				musb_peri_tx(intrtx);
+		} else {
+			if (MUSB_INTR_SOF & intrusb) {
+				u8 faddr;
+				faddr = readb(&musbr->faddr);
+				/*
+				 * Setting of the address can fail.
+				 * Normally it succeeds the second time.
+				 */
+				if (udc_device->address != faddr)
+					musb_peri_ep0_set_address();
+			}
+		}
+	}
+}
+
+void udc_set_nak(int ep_num)
+{
+	/* noop */
+}
+
+void udc_unset_nak(int ep_num)
+{
+	/* noop */
+}
+
+int udc_endpoint_write(struct usb_endpoint_instance *endpoint)
+{
+	int ret = 0;
+
+	/* Transmit only if the hardware is available */
+	if (endpoint->tx_urb && endpoint->state == 0) {
+		unsigned int ep = endpoint->endpoint_address &
+			USB_ENDPOINT_NUMBER_MASK;
+
+		u16 peri_txcsr = readw(&musbr->ep[ep].epN.txcsr);
+
+		/* Error conditions */
+		if (peri_txcsr & MUSB_TXCSR_P_UNDERRUN) {
+			peri_txcsr &= ~MUSB_TXCSR_P_UNDERRUN;
+			writew(peri_txcsr, &musbr->ep[ep].epN.txcsr);
+		}
+
+		if (debug_level > 1)
+			musb_print_txcsr(peri_txcsr);
+
+		/* Check if a packet is waiting to be sent */
+		if (!(peri_txcsr & MUSB_TXCSR_TXPKTRDY)) {
+			u32 length;
+			u8 *data;
+			struct urb *urb = endpoint->tx_urb;
+			unsigned int remaining_packet = urb->actual_length -
+				endpoint->sent;
+
+			if (endpoint->tx_packetSize < remaining_packet)
+				length = endpoint->tx_packetSize;
+			else
+				length = remaining_packet;
+
+			data = (u8 *) urb->buffer;
+			data += endpoint->sent;
+
+			/* common musb fifo function */
+			write_fifo(ep, length, data);
+
+			musb_peri_tx_ready(ep);
+
+			endpoint->last = length;
+			/* usbd_tx_complete will take care of updating 'sent' */
+			usbd_tx_complete(endpoint);
+		}
+	} else {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s Problem with urb %p "
+				      "or ep state %d\n",
+				      __PRETTY_FUNCTION__,
+				      endpoint->tx_urb, endpoint->state);
+	}
+
+	return ret;
+}
+
+void udc_setup_ep(struct usb_device_instance *device, unsigned int id,
+		  struct usb_endpoint_instance *endpoint)
+{
+	if (0 == id) {
+		/* EP0 */
+		ep0_endpoint = endpoint;
+		ep0_endpoint->endpoint_address = 0xff;
+		ep0_urb = usbd_alloc_urb(device, endpoint);
+	} else if (MAX_ENDPOINT >= id) {
+		int ep_addr;
+
+		/* Check the direction */
+		ep_addr = endpoint->endpoint_address;
+		if (USB_DIR_IN == (ep_addr & USB_ENDPOINT_DIR_MASK)) {
+			/* IN */
+			epinfo[(id * 2) + 1].epsize = endpoint->tx_packetSize;
+		} else {
+			/* OUT */
+			epinfo[id * 2].epsize = endpoint->rcv_packetSize;
+		}
+
+		musb_configure_ep(&epinfo[0],
+				  sizeof(epinfo) / sizeof(struct musb_epinfo));
+	} else {
+		if (debug_level > 0)
+			serial_printf("ERROR : %s endpoint request %d "
+				      "exceeds maximum %d\n",
+				      __PRETTY_FUNCTION__, id, MAX_ENDPOINT);
+	}
+}
+
+void udc_connect(void)
+{
+	/* noop */
+}
+
+void udc_disconnect(void)
+{
+	/* noop */
+}
+
+void udc_enable(struct usb_device_instance *device)
+{
+	/* Save the device structure pointer */
+	udc_device = device;
+
+	enabled = 1;
+}
+
+void udc_disable(void)
+{
+	enabled = 0;
+}
+
+void udc_startup_events(struct usb_device_instance *device)
+{
+	/* The DEVICE_INIT event puts the USB device in the state STATE_INIT. */
+	usbd_device_event_irq(device, DEVICE_INIT, 0);
+
+	/*
+	 * The DEVICE_CREATE event puts the USB device in the state
+	 * STATE_ATTACHED.
+	 */
+	usbd_device_event_irq(device, DEVICE_CREATE, 0);
+
+	/* Resets the address to 0 */
+	usbd_device_event_irq(device, DEVICE_RESET, 0);
+
+	udc_enable(device);
+}
+
+int udc_init(void)
+{
+	int ret;
+	int ep_loop;
+
+	ret = musb_platform_init();
+	if (ret < 0)
+		goto end;
+
+	/* Configure all the endpoint FIFO's and start usb controller */
+	musbr = musb_cfg.regs;
+
+	/* Initialize the endpoints */
+	for (ep_loop = 0; ep_loop < MAX_ENDPOINT * 2; ep_loop++) {
+		epinfo[ep_loop].epnum = (ep_loop / 2) + 1;
+		epinfo[ep_loop].epdir = ep_loop % 2; /* OUT, IN */
+		epinfo[ep_loop].epsize = 0;
+	}
+
+	musb_peri_softconnect();
+
+	ret = 0;
+end:
+
+	return ret;
+}
diff --git a/drivers/usb/musb/omap3.c b/drivers/usb/musb/omap3.c
new file mode 100644
index 0000000..9bf1a85
--- /dev/null
+++ b/drivers/usb/musb/omap3.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This is file is based on
+ * repository git.gitorious.org/u-boot-omap3/mainline.git,
+ * branch omap3-dev-usb, file drivers/usb/host/omap3530_usb.c
+ *
+ * This is the unique part of its copyright :
+ *
+ * ------------------------------------------------------------------------
+ *
+ * Copyright (c) 2009 Texas Instruments
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <twl4030.h>
+#include "omap3.h"
+
+static int platform_needs_initialization = 1;
+
+struct musb_config musb_cfg = {
+	(struct	musb_regs *)MENTOR_USB0_BASE,
+	OMAP3_USB_TIMEOUT,
+	0,
+	0
+};
+
+/*
+ * OMAP3 USB OTG registers.
+ */
+struct omap3_otg_regs {
+	u32	revision;
+	u32	sysconfig;
+	u32	sysstatus;
+	u32	interfsel;
+	u32	simenable;
+	u32	forcestdby;
+};
+
+static struct omap3_otg_regs *otg;
+
+#define OMAP3_OTG_SYSCONFIG_SMART_STANDBY_MODE		0x2000
+#define OMAP3_OTG_SYSCONFIG_NO_STANDBY_MODE		0x1000
+#define OMAP3_OTG_SYSCONFIG_SMART_IDLE_MODE		0x0010
+#define OMAP3_OTG_SYSCONFIG_NO_IDLE_MODE		0x0008
+#define OMAP3_OTG_SYSCONFIG_ENABLEWAKEUP		0x0004
+#define OMAP3_OTG_SYSCONFIG_SOFTRESET			0x0002
+#define OMAP3_OTG_SYSCONFIG_AUTOIDLE			0x0001
+
+#define OMAP3_OTG_SYSSTATUS_RESETDONE			0x0001
+
+#define OMAP3_OTG_INTERFSEL_OMAP			0x0001
+
+#define OMAP3_OTG_FORCESTDBY_STANDBY			0x0001
+
+
+#ifdef DEBUG_MUSB_OMAP3
+static void musb_db_otg_regs(void)
+{
+	u32 l;
+	l = readl(&otg->revision);
+	serial_printf("OTG_REVISION 0x%x\n", l);
+	l = readl(&otg->sysconfig);
+	serial_printf("OTG_SYSCONFIG 0x%x\n", l);
+	l = readl(&otg->sysstatus);
+	serial_printf("OTG_SYSSTATUS 0x%x\n", l);
+	l = readl(&otg->interfsel);
+	serial_printf("OTG_INTERFSEL 0x%x\n", l);
+	l = readl(&otg->forcestdby);
+	serial_printf("OTG_FORCESTDBY 0x%x\n", l);
+}
+#endif
+
+int musb_platform_init(void)
+{
+	int ret = -1;
+
+	if (platform_needs_initialization) {
+		u32 stdby;
+
+		/*
+		 * OMAP3EVM uses ISP1504 phy and so
+		 * twl4030 related init is not required.
+		 */
+#ifdef CONFIG_TWL4030_USB
+		if (twl4030_usb_ulpi_init()) {
+			serial_printf("ERROR: %s Could not initialize PHY\n",
+				__PRETTY_FUNCTION__);
+			goto end;
+		}
+#endif
+		otg = (struct omap3_otg_regs *)OMAP3_OTG_BASE;
+
+		/* Set OTG to always be on */
+		writel(OMAP3_OTG_SYSCONFIG_NO_STANDBY_MODE |
+		       OMAP3_OTG_SYSCONFIG_NO_IDLE_MODE, &otg->sysconfig);
+
+		/* Set the interface */
+		writel(OMAP3_OTG_INTERFSEL_OMAP, &otg->interfsel);
+
+		/* Clear force standby */
+		stdby = readl(&otg->forcestdby);
+		stdby &= ~OMAP3_OTG_FORCESTDBY_STANDBY;
+		writel(stdby, &otg->forcestdby);
+
+#ifdef CONFIG_OMAP3_EVM
+		if (get_omap3_evm_rev() >= OMAP3EVM_BOARD_GEN_2)
+			musb_cfg.extvbus = 1;
+#endif
+		platform_needs_initialization = 0;
+	}
+
+	ret = platform_needs_initialization;
+#ifdef CONFIG_TWL4030_USB
+end:
+#endif
+	return ret;
+
+}
+
+void musb_platform_deinit(void)
+{
+	/* noop */
+}
diff --git a/drivers/usb/musb/omap3.h b/drivers/usb/musb/omap3.h
new file mode 100644
index 0000000..756b069
--- /dev/null
+++ b/drivers/usb/musb/omap3.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This file is based on the file drivers/usb/musb/davinci.h
+ *
+ * This is the unique part of its copyright:
+ *
+ * --------------------------------------------------------------------
+ *
+ * Copyright (c) 2008 Texas Instruments
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ *
+ * --------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _MUSB_OMAP3_H_
+#define _MUSB_OMAP3_H_
+
+#include "musb_core.h"
+
+/* Base address of MUSB registers */
+#define MENTOR_USB0_BASE (OMAP34XX_CORE_L4_IO_BASE + 0xAB000)
+
+/* Base address of OTG registers */
+#define OMAP3_OTG_BASE (MENTOR_USB0_BASE + 0x400)
+
+/* Timeout for USB module */
+#define OMAP3_USB_TIMEOUT 0x3FFFFFF
+
+int musb_platform_init(void);
+
+#ifdef CONFIG_OMAP3_EVM
+extern u8 get_omap3_evm_rev(void);
+enum {
+       OMAP3EVM_BOARD_GEN_1 = 0, /* EVM Rev between  A - D*/
+       OMAP3EVM_BOARD_GEN_2,   /* EVM Rev >= Rev E*/
+};
+#endif
+
+#endif /* _MUSB_OMAP3_H */
+
diff --git a/drivers/usb/phy/Makefile b/drivers/usb/phy/Makefile
new file mode 100644
index 0000000..200b907
--- /dev/null
+++ b/drivers/usb/phy/Makefile
@@ -0,0 +1,44 @@
+#
+# Copyright (c) 2009 Wind River Systems, Inc.
+# Tom Rix <Tom.Rix@windriver.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libusb_phy.a
+
+COBJS-$(CONFIG_TWL4030_USB) += twl4030.o
+COBJS-y := twl4030.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/usb/phy/twl4030.c b/drivers/usb/phy/twl4030.c
new file mode 100644
index 0000000..54d2e61
--- /dev/null
+++ b/drivers/usb/phy/twl4030.c
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This is file is based on
+ * repository git.gitorious.org/u-boot-omap3/mainline.git,
+ * branch omap3-dev-usb, file drivers/usb/gadget/twl4030_usb.c
+ *
+ * This is the unique part of its copyright :
+ *
+ * ------------------------------------------------------------------------
+ *
+ *  * (C) Copyright 2009 Atin Malaviya (atin.malaviya@gmail.com)
+ *
+ * Based on: twl4030_usb.c in linux 2.6 (drivers/i2c/chips/twl4030_usb.c)
+ * Copyright (C) 2004-2007 Texas Instruments
+ * Copyright (C) 2008 Nokia Corporation
+ * Contact: Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * Author: Atin Malaviya (atin.malaviya@gmail.com)
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <twl4030.h>
+
+/* Defines for bits in registers */
+#define OPMODE_MASK		(3 << 3)
+#define XCVRSELECT_MASK		(3 << 0)
+#define CARKITMODE		(1 << 2)
+#define OTG_ENAB		(1 << 5)
+#define PHYPWD			(1 << 0)
+#define CLOCKGATING_EN		(1 << 2)
+#define CLK32K_EN		(1 << 1)
+#define REQ_PHY_DPLL_CLK	(1 << 0)
+#define PHY_DPLL_CLK		(1 << 0)
+
+static int twl4030_usb_write(u8 address, u8 data)
+{
+	int ret;
+
+	ret = twl4030_i2c_write_u8(TWL4030_CHIP_USB, data, address);
+	if (ret != 0)
+		printf("TWL4030:USB:Write[0x%x] Error %d\n", address, ret);
+
+	return ret;
+}
+
+static int twl4030_usb_read(u8 address)
+{
+	u8 data;
+	int ret;
+
+	ret = twl4030_i2c_read_u8(TWL4030_CHIP_USB, &data, address);
+	if (ret == 0)
+		ret = data;
+	else
+		printf("TWL4030:USB:Read[0x%x] Error %d\n", address, ret);
+
+	return ret;
+}
+
+static void twl4030_usb_ldo_init(void)
+{
+	/* Enable writing to power configuration registers */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_MASTER, 0xC0,
+			     TWL4030_PM_MASTER_PROTECT_KEY);
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_MASTER, 0x0C,
+			     TWL4030_PM_MASTER_PROTECT_KEY);
+
+	/* put VUSB3V1 LDO in active state */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x00,
+			     TWL4030_PM_RECEIVER_VUSB_DEDICATED2);
+
+	/* input to VUSB3V1 LDO is from VBAT, not VBUS */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x14,
+			     TWL4030_PM_RECEIVER_VUSB_DEDICATED1);
+
+	/* turn on 3.1V regulator */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x20,
+			     TWL4030_PM_RECEIVER_VUSB3V1_DEV_GRP);
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x00,
+			     TWL4030_PM_RECEIVER_VUSB3V1_TYPE);
+
+	/* turn on 1.5V regulator */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x20,
+			     TWL4030_PM_RECEIVER_VUSB1V5_DEV_GRP);
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x00,
+			     TWL4030_PM_RECEIVER_VUSB1V5_TYPE);
+
+	/* turn on 1.8V regulator */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x20,
+			     TWL4030_PM_RECEIVER_VUSB1V8_DEV_GRP);
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_RECEIVER, 0x00,
+			     TWL4030_PM_RECEIVER_VUSB1V8_TYPE);
+
+	/* disable access to power configuration registers */
+	twl4030_i2c_write_u8(TWL4030_CHIP_PM_MASTER, 0x00,
+			     TWL4030_PM_MASTER_PROTECT_KEY);
+}
+
+static void twl4030_phy_power(void)
+{
+	u8 pwr, clk;
+
+	/* Power the PHY */
+	pwr = twl4030_usb_read(TWL4030_USB_PHY_PWR_CTRL);
+	pwr &= ~PHYPWD;
+	twl4030_usb_write(TWL4030_USB_PHY_PWR_CTRL, pwr);
+	/* Enable clocks */
+	clk = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL);
+	clk |= CLOCKGATING_EN | CLK32K_EN;
+	twl4030_usb_write(TWL4030_USB_PHY_CLK_CTRL, clk);
+}
+
+/*
+ * Initiaze the ULPI interface
+ * ULPI : Universal Transceiver Macrocell Low Pin Interface
+ * An interface between the USB link controller like musb and the
+ * the PHY or transceiver that drives the actual bus.
+ */
+int twl4030_usb_ulpi_init(void)
+{
+	long timeout = 1000 * 1000; /* 1 sec */;
+	u8 clk, sts, pwr;
+
+	/* twl4030 ldo init */
+	twl4030_usb_ldo_init();
+
+	/* Enable the twl4030 phy */
+	twl4030_phy_power();
+
+	/* Enable DPLL to access PHY registers over I2C */
+	clk = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL);
+	clk |= REQ_PHY_DPLL_CLK;
+	twl4030_usb_write(TWL4030_USB_PHY_CLK_CTRL, clk);
+
+	/* Check if the PHY DPLL is locked */
+	sts = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL_STS);
+	while (!(sts & PHY_DPLL_CLK) && 0 < timeout) {
+		udelay(10);
+		sts = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL_STS);
+		timeout -= 10;
+	}
+
+	/* Final check */
+	sts = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL_STS);
+	if (!(sts & PHY_DPLL_CLK)) {
+		printf("Error:TWL4030:USB Timeout setting PHY DPLL clock\n");
+		return -1;
+	}
+
+	/*
+	 * There are two circuit blocks attached to the PHY,
+	 * Carkit and USB OTG.  Disable Carkit and enable USB OTG
+	 */
+	twl4030_usb_write(TWL4030_USB_IFC_CTRL_CLR, CARKITMODE);
+	pwr = twl4030_usb_read(TWL4030_USB_POWER_CTRL);
+	pwr |= OTG_ENAB;
+	twl4030_usb_write(TWL4030_USB_POWER_CTRL_SET, pwr);
+
+	/* Clear the opmode bits to ensure normal encode */
+	twl4030_usb_write(TWL4030_USB_FUNC_CTRL_CLR, OPMODE_MASK);
+
+	/* Clear the xcvrselect bits to enable the high speed transeiver */
+	twl4030_usb_write(TWL4030_USB_FUNC_CTRL_CLR, XCVRSELECT_MASK);
+
+	/* Let ULPI control the DPLL clock */
+	clk = twl4030_usb_read(TWL4030_USB_PHY_CLK_CTRL);
+	clk &= ~REQ_PHY_DPLL_CLK;
+	twl4030_usb_write(TWL4030_USB_PHY_CLK_CTRL, clk);
+
+	return 0;
+}
diff --git a/include/asm-arm/arch-davinci/emac_defs.h b/include/asm-arm/arch-davinci/emac_defs.h
index 96bc80e..3624c44 100644
--- a/include/asm-arm/arch-davinci/emac_defs.h
+++ b/include/asm-arm/arch-davinci/emac_defs.h
@@ -71,271 +71,15 @@
 #define EMAC_MDIO_PHY_NUM           1
 #define EMAC_MDIO_PHY_MASK          (1 << EMAC_MDIO_PHY_NUM)
 
-/* Ethernet Min/Max packet size */
-#define EMAC_MIN_ETHERNET_PKT_SIZE	60
-#define EMAC_MAX_ETHERNET_PKT_SIZE	1518
-#define EMAC_PKT_ALIGN			18	/* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
-
-/* Number of RX packet buffers
- * NOTE: Only 1 buffer supported as of now
- */
-#define EMAC_MAX_RX_BUFFERS		10
-
-
-/***********************************************
- ******** Internally used macros ***************
- ***********************************************/
-
-#define EMAC_CH_TX			1
-#define EMAC_CH_RX			0
-
-/* Each descriptor occupies 4 words, lets start RX desc's at 0 and
- * reserve space for 64 descriptors max
- */
-#define EMAC_RX_DESC_BASE		0x0
-#define EMAC_TX_DESC_BASE		0x1000
-
-/* EMAC Teardown value */
-#define EMAC_TEARDOWN_VALUE		0xfffffffc
-
-/* MII Status Register */
-#define MII_STATUS_REG			1
-
-/* Number of statistics registers */
-#define EMAC_NUM_STATS			36
-
-
-/* EMAC Descriptor */
-typedef volatile struct _emac_desc
-{
-	u_int32_t	next;		/* Pointer to next descriptor in chain */
-	u_int8_t	*buffer;	/* Pointer to data buffer */
-	u_int32_t	buff_off_len;	/* Buffer Offset(MSW) and Length(LSW) */
-	u_int32_t	pkt_flag_len;	/* Packet Flags(MSW) and Length(LSW) */
-} emac_desc;
-
-/* CPPI bit positions */
-#define EMAC_CPPI_SOP_BIT		(0x80000000)
-#define EMAC_CPPI_EOP_BIT		(0x40000000)
-#define EMAC_CPPI_OWNERSHIP_BIT		(0x20000000)
-#define EMAC_CPPI_EOQ_BIT		(0x10000000)
-#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT	(0x08000000)
-#define EMAC_CPPI_PASS_CRC_BIT		(0x04000000)
-
-#define EMAC_CPPI_RX_ERROR_FRAME	(0x03fc0000)
-
-#define EMAC_MACCONTROL_MIIEN_ENABLE		(0x20)
-#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE	(0x1)
-#define EMAC_MACCONTROL_GIGABIT_ENABLE		(1 << 7)
-#define EMAC_MACCONTROL_GIGFORCE		(1 << 17)
-
-#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE	(0x200000)
-#define EMAC_RXMBPENABLE_RXBROADEN	(0x2000)
-
-
-#define MDIO_CONTROL_IDLE		(0x80000000)
-#define MDIO_CONTROL_ENABLE		(0x40000000)
-#define MDIO_CONTROL_FAULT_ENABLE	(0x40000)
-#define MDIO_CONTROL_FAULT		(0x80000)
-#define MDIO_USERACCESS0_GO		(0x80000000)
-#define MDIO_USERACCESS0_WRITE_READ	(0x0)
-#define MDIO_USERACCESS0_WRITE_WRITE	(0x40000000)
-#define MDIO_USERACCESS0_ACK		(0x20000000)
-
-/* Ethernet MAC Registers Structure */
-typedef struct  {
-	dv_reg		TXIDVER;
-	dv_reg		TXCONTROL;
-	dv_reg		TXTEARDOWN;
-	u_int8_t	RSVD0[4];
-	dv_reg		RXIDVER;
-	dv_reg		RXCONTROL;
-	dv_reg		RXTEARDOWN;
-	u_int8_t	RSVD1[100];
-	dv_reg		TXINTSTATRAW;
-	dv_reg		TXINTSTATMASKED;
-	dv_reg		TXINTMASKSET;
-	dv_reg		TXINTMASKCLEAR;
-	dv_reg		MACINVECTOR;
-	u_int8_t	RSVD2[12];
-	dv_reg		RXINTSTATRAW;
-	dv_reg		RXINTSTATMASKED;
-	dv_reg		RXINTMASKSET;
-	dv_reg		RXINTMASKCLEAR;
-	dv_reg		MACINTSTATRAW;
-	dv_reg		MACINTSTATMASKED;
-	dv_reg		MACINTMASKSET;
-	dv_reg		MACINTMASKCLEAR;
-	u_int8_t	RSVD3[64];
-	dv_reg		RXMBPENABLE;
-	dv_reg		RXUNICASTSET;
-	dv_reg		RXUNICASTCLEAR;
-	dv_reg		RXMAXLEN;
-	dv_reg		RXBUFFEROFFSET;
-	dv_reg		RXFILTERLOWTHRESH;
-	u_int8_t	RSVD4[8];
-	dv_reg		RX0FLOWTHRESH;
-	dv_reg		RX1FLOWTHRESH;
-	dv_reg		RX2FLOWTHRESH;
-	dv_reg		RX3FLOWTHRESH;
-	dv_reg		RX4FLOWTHRESH;
-	dv_reg		RX5FLOWTHRESH;
-	dv_reg		RX6FLOWTHRESH;
-	dv_reg		RX7FLOWTHRESH;
-	dv_reg		RX0FREEBUFFER;
-	dv_reg		RX1FREEBUFFER;
-	dv_reg		RX2FREEBUFFER;
-	dv_reg		RX3FREEBUFFER;
-	dv_reg		RX4FREEBUFFER;
-	dv_reg		RX5FREEBUFFER;
-	dv_reg		RX6FREEBUFFER;
-	dv_reg		RX7FREEBUFFER;
-	dv_reg		MACCONTROL;
-	dv_reg		MACSTATUS;
-	dv_reg		EMCONTROL;
-	dv_reg		FIFOCONTROL;
-	dv_reg		MACCONFIG;
-	dv_reg		SOFTRESET;
-	u_int8_t	RSVD5[88];
-	dv_reg		MACSRCADDRLO;
-	dv_reg		MACSRCADDRHI;
-	dv_reg		MACHASH1;
-	dv_reg		MACHASH2;
-	dv_reg		BOFFTEST;
-	dv_reg		TPACETEST;
-	dv_reg		RXPAUSE;
-	dv_reg		TXPAUSE;
-	u_int8_t	RSVD6[16];
-	dv_reg		RXGOODFRAMES;
-	dv_reg		RXBCASTFRAMES;
-	dv_reg		RXMCASTFRAMES;
-	dv_reg		RXPAUSEFRAMES;
-	dv_reg		RXCRCERRORS;
-	dv_reg		RXALIGNCODEERRORS;
-	dv_reg		RXOVERSIZED;
-	dv_reg		RXJABBER;
-	dv_reg		RXUNDERSIZED;
-	dv_reg		RXFRAGMENTS;
-	dv_reg		RXFILTERED;
-	dv_reg		RXQOSFILTERED;
-	dv_reg		RXOCTETS;
-	dv_reg		TXGOODFRAMES;
-	dv_reg		TXBCASTFRAMES;
-	dv_reg		TXMCASTFRAMES;
-	dv_reg		TXPAUSEFRAMES;
-	dv_reg		TXDEFERRED;
-	dv_reg		TXCOLLISION;
-	dv_reg		TXSINGLECOLL;
-	dv_reg		TXMULTICOLL;
-	dv_reg		TXEXCESSIVECOLL;
-	dv_reg		TXLATECOLL;
-	dv_reg		TXUNDERRUN;
-	dv_reg		TXCARRIERSENSE;
-	dv_reg		TXOCTETS;
-	dv_reg		FRAME64;
-	dv_reg		FRAME65T127;
-	dv_reg		FRAME128T255;
-	dv_reg		FRAME256T511;
-	dv_reg		FRAME512T1023;
-	dv_reg		FRAME1024TUP;
-	dv_reg		NETOCTETS;
-	dv_reg		RXSOFOVERRUNS;
-	dv_reg		RXMOFOVERRUNS;
-	dv_reg		RXDMAOVERRUNS;
-	u_int8_t	RSVD7[624];
-	dv_reg		MACADDRLO;
-	dv_reg		MACADDRHI;
-	dv_reg		MACINDEX;
-	u_int8_t	RSVD8[244];
-	dv_reg		TX0HDP;
-	dv_reg		TX1HDP;
-	dv_reg		TX2HDP;
-	dv_reg		TX3HDP;
-	dv_reg		TX4HDP;
-	dv_reg		TX5HDP;
-	dv_reg		TX6HDP;
-	dv_reg		TX7HDP;
-	dv_reg		RX0HDP;
-	dv_reg		RX1HDP;
-	dv_reg		RX2HDP;
-	dv_reg		RX3HDP;
-	dv_reg		RX4HDP;
-	dv_reg		RX5HDP;
-	dv_reg		RX6HDP;
-	dv_reg		RX7HDP;
-	dv_reg		TX0CP;
-	dv_reg		TX1CP;
-	dv_reg		TX2CP;
-	dv_reg		TX3CP;
-	dv_reg		TX4CP;
-	dv_reg		TX5CP;
-	dv_reg		TX6CP;
-	dv_reg		TX7CP;
-	dv_reg		RX0CP;
-	dv_reg		RX1CP;
-	dv_reg		RX2CP;
-	dv_reg		RX3CP;
-	dv_reg		RX4CP;
-	dv_reg		RX5CP;
-	dv_reg		RX6CP;
-	dv_reg		RX7CP;
-} emac_regs;
-
-/* EMAC Wrapper Registers Structure */
-typedef struct  {
-#if defined(CONFIG_SOC_DM646X) || defined(CONFIG_SOC_DM365)
-	dv_reg		IDVER;
-	dv_reg		SOFTRST;
-	dv_reg		EMCTRL;
-#else
-	u_int8_t	RSVD0[4100];
-	dv_reg		EWCTL;
-	dv_reg		EWINTTCNT;
-#endif
-} ewrap_regs;
-
-/* EMAC MDIO Registers Structure */
-typedef struct  {
-	dv_reg		VERSION;
-	dv_reg		CONTROL;
-	dv_reg		ALIVE;
-	dv_reg		LINK;
-	dv_reg		LINKINTRAW;
-	dv_reg		LINKINTMASKED;
-	u_int8_t	RSVD0[8];
-	dv_reg		USERINTRAW;
-	dv_reg		USERINTMASKED;
-	dv_reg		USERINTMASKSET;
-	dv_reg		USERINTMASKCLEAR;
-	u_int8_t	RSVD1[80];
-	dv_reg		USERACCESS0;
-	dv_reg		USERPHYSEL0;
-	dv_reg		USERACCESS1;
-	dv_reg		USERPHYSEL1;
-} mdio_regs;
-
-int davinci_eth_phy_read(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t *data);
-int davinci_eth_phy_write(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t data);
-
-typedef struct
-{
-	char	name[64];
-	int	(*init)(int phy_addr);
-	int	(*is_phy_connected)(int phy_addr);
-	int	(*get_link_speed)(int phy_addr);
-	int	(*auto_negotiate)(int phy_addr);
-} phy_t;
-
-#define PHY_LXT972	(0x001378e2)
+#define PHY_LXT972      (0x001378e2)
 int lxt972_is_phy_connected(int phy_addr);
 int lxt972_get_link_speed(int phy_addr);
 int lxt972_init_phy(int phy_addr);
 int lxt972_auto_negotiate(int phy_addr);
 
-#define PHY_DP83848	(0x20005c90)
+#define PHY_DP83848     (0x20005c90)
 int dp83848_is_phy_connected(int phy_addr);
 int dp83848_get_link_speed(int phy_addr);
 int dp83848_init_phy(int phy_addr);
 int dp83848_auto_negotiate(int phy_addr);
-
 #endif  /* _DM644X_EMAC_H_ */
diff --git a/include/asm-arm/arch-omap3/clocks.h b/include/asm-arm/arch-omap3/clocks.h
index 71a0cb6..cceedd2 100644
--- a/include/asm-arm/arch-omap3/clocks.h
+++ b/include/asm-arm/arch-omap3/clocks.h
@@ -31,9 +31,15 @@
 #define S38_4M		38400000
 
 #define FCK_IVA2_ON	0x00000001
+#if (defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+#define FCK_CORE1_ON    0x037ffe00
+#define ICK_CORE1_ON    0x037ffe42
+#define ICK_CORE2_ON    0x00000000
+#else
 #define FCK_CORE1_ON	0x03fffe29
 #define ICK_CORE1_ON	0x3ffffffb
 #define ICK_CORE2_ON	0x0000001f
+#endif
 #define FCK_WKUP_ON	0x000000e9
 #define ICK_WKUP_ON	0x0000003f
 #define FCK_DSS_ON	0x00000005
@@ -51,12 +57,29 @@ typedef struct {
 	unsigned int m2;
 } dpll_param;
 
+struct dpll_per_36x_param {
+        unsigned int sys_clk;
+        unsigned int m;
+        unsigned int n;
+        unsigned int m2;
+        unsigned int m3;
+        unsigned int m4;
+        unsigned int m5;
+        unsigned int m6;
+        unsigned int m2div;
+};
+
 /* Following functions are exported from lowlevel_init.S */
 extern dpll_param *get_mpu_dpll_param(void);
 extern dpll_param *get_iva_dpll_param(void);
 extern dpll_param *get_core_dpll_param(void);
 extern dpll_param *get_per_dpll_param(void);
 
+extern dpll_param *get_36x_mpu_dpll_param(void);
+extern dpll_param *get_36x_iva_dpll_param(void);
+extern dpll_param *get_36x_core_dpll_param(void);
+extern dpll_param *get_36x_per_dpll_param(void);
+
 extern void *_end_vect, *_start;
 
 #endif
diff --git a/include/asm-arm/arch-omap3/clocks_omap3.h b/include/asm-arm/arch-omap3/clocks_omap3.h
index 661407b..e9784f0 100644
--- a/include/asm-arm/arch-omap3/clocks_omap3.h
+++ b/include/asm-arm/arch-omap3/clocks_omap3.h
@@ -38,7 +38,10 @@
 #define CORE_FUSB_DIV	2	/* 41.5MHz: */
 #define CORE_L4_DIV	2	/* 83MHz  : L4 */
 #define CORE_L3_DIV	2	/* 166MHz : L3 {DDR} */
-#define GFX_DIV		2	/* 83MHz  : CM_CLKSEL_GFX */
+#define GFX_DIV_34X	3	/* 96MHz  : CM_CLKSEL_GFX */
+#define GFX_DIV_36X	5	/* 200MHz : CM_CLKSEL_GFX */
+/* Default would be 96Mhz*/
+#define GFX_DIV		GFX_DIV_34X	/* 96MHz  : CM_CLKSEL_GFX */
 #define WKUP_RSM	2	/* 41.5MHz: CM_CLKSEL_WKUP */
 
 /* PER DPLL */
@@ -282,4 +285,31 @@
 #define PER_FSEL_38P4		0x07
 #define PER_M2_38P4		0x09
 
+/* 36XX PER DPLL */
+
+#define PER_36XX_M_12		0x1B0
+#define PER_36XX_N_12		0x05
+#define PER_36XX_FSEL_12	0x07
+#define PER_36XX_M2_12		0x09
+
+#define PER_36XX_M_13		0x360
+#define PER_36XX_N_13		0x0C
+#define PER_36XX_FSEL_13	0x03
+#define PER_36XX_M2_13		0x09
+
+#define PER_36XX_M_19P2		0x1C2
+#define PER_36XX_N_19P2		0x09
+#define PER_36XX_FSEL_19P2	0x07
+#define PER_36XX_M2_19P2	0x09
+
+#define PER_36XX_M_26		0x1B0
+#define PER_36XX_N_26		0x0C
+#define PER_36XX_FSEL_26	0x07
+#define PER_36XX_M2_26		0x09
+
+#define PER_36XX_M_38P4		0x1C2
+#define PER_36XX_N_38P4		0x13
+#define PER_36XX_FSEL_38P4	0x07
+#define PER_36XX_M2_38P4	0x09
+
 #endif	/* endif _CLOCKS_OMAP3_H_ */
diff --git a/include/asm-arm/arch-omap3/cpu.h b/include/asm-arm/arch-omap3/cpu.h
index 8ab2e39..6d60f5a 100644
--- a/include/asm-arm/arch-omap3/cpu.h
+++ b/include/asm-arm/arch-omap3/cpu.h
@@ -60,12 +60,6 @@ struct ctrl {
 #endif /* __ASSEMBLY__ */
 #endif /* __KERNEL_STRICT_NAMES */
 
-/* cpu type */
-#define OMAP3503		0x5c00
-#define OMAP3515		0x1c00
-#define OMAP3525		0x4c00
-#define OMAP3530		0x0c00
-
 #ifndef __KERNEL_STRICT_NAMES
 #ifndef __ASSEMBLY__
 struct ctrl_id {
@@ -214,6 +208,32 @@ struct sdrc {
 #endif /* __ASSEMBLY__ */
 #endif /* __KERNEL_STRICT_NAMES */
 
+/* EMIF4 */
+#ifndef __ASSEMBLY__
+typedef struct emif4 {
+	unsigned int sdram_sts;
+	unsigned int sdram_config;
+	unsigned int res1;
+	unsigned int sdram_refresh_ctrl;
+	unsigned int sdram_refresh_ctrl_shdw;
+	unsigned int sdram_time1;
+	unsigned int sdram_time1_shdw;
+	unsigned int sdram_time2;
+	unsigned int sdram_time2_shdw;
+	unsigned int sdram_time3;
+	unsigned int sdram_time3_shdw;
+	unsigned char res2[8];
+	unsigned int sdram_pwr_mgmt;
+	unsigned int sdram_pwr_mgmt_shdw;
+	unsigned char res3[32];
+	unsigned int sdram_iodft_tlgc;
+	unsigned char res4[128];
+	unsigned int ddr_phyctrl1;
+	unsigned int ddr_phyctrl1_shdw;
+	unsigned int ddr_phyctrl2;
+} emif4_t;
+#endif /* __ASSEMBLY__ */
+
 #define DLLPHASE_90		(0x1 << 1)
 #define LOADDLL			(0x1 << 2)
 #define ENADLL			(0x1 << 3)
diff --git a/include/asm-arm/arch-omap3/emac_defs.h b/include/asm-arm/arch-omap3/emac_defs.h
new file mode 100644
index 0000000..dc1781d
--- /dev/null
+++ b/include/asm-arm/arch-omap3/emac_defs.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on:
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+
+#ifndef _AM3517_EMAC_H_
+#define _AM3517_EMAC_H_
+
+#define EMAC_BASE_ADDR                 0x5C010000
+#define EMAC_WRAPPER_BASE_ADDR         0x5C000000
+#define EMAC_WRAPPER_RAM_ADDR          0x5C020000
+#define EMAC_MDIO_BASE_ADDR            0x5C030000
+#define EMAC_HW_RAM_ADDR               0x01E20000
+
+#define EMAC_MDIO_BUS_FREQ             166000000       /* 166 MHZ check */
+#define EMAC_MDIO_CLOCK_FREQ           1000000         /* 2.0 MHz */
+
+/* PHY mask - set only those phy number bits where phy is/can be connected */
+#define EMAC_MDIO_PHY_NUM           1
+#define EMAC_MDIO_PHY_MASK          (1 << EMAC_MDIO_PHY_NUM)
+
+
+/* SOFTRESET macro definition interferes with emac_regs structure definition */
+#undef SOFTRESET
+
+#endif  /* _AM3517_EMAC_H_ */
diff --git a/include/asm-arm/arch-omap3/emif4.h b/include/asm-arm/arch-omap3/emif4.h
new file mode 100644
index 0000000..e1a8808
--- /dev/null
+++ b/include/asm-arm/arch-omap3/emif4.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _EMIF_H_
+#define _EMIF_H_
+
+/*
+ * Configuration values
+ */
+#define EMIF4_TIM1_T_RP		(0x3 << 25)
+#define EMIF4_TIM1_T_RCD	(0x3 << 21)
+#define EMIF4_TIM1_T_WR		(0x3 << 17)
+#define EMIF4_TIM1_T_RAS	(0x8 << 12)
+#define EMIF4_TIM1_T_RC		(0xA << 6)
+#define EMIF4_TIM1_T_RRD	(0x2 << 3)
+#define EMIF4_TIM1_T_WTR	(0x2)
+
+#define EMIF4_TIM2_T_XP		(0x2 << 28)
+#define EMIF4_TIM2_T_ODT	(0x0 << 25)
+#define EMIF4_TIM2_T_XSNR	(0x1C << 16)
+#define EMIF4_TIM2_T_XSRD	(0xC8 << 6)
+#define EMIF4_TIM2_T_RTP	(0x1 << 3)
+#define EMIF4_TIM2_T_CKE	(0x2)
+
+#define EMIF4_TIM3_T_RFC	(0x25 << 4)
+#define EMIF4_TIM3_T_RAS_MAX	(0x7)
+
+#define EMIF4_PWR_IDLE_MODE	(0x2 << 30)
+#define EMIF4_PWR_DPD_DIS	(0x0 << 10)
+#define EMIF4_PWR_DPD_EN	(0x1 << 10)
+#define EMIF4_PWR_LP_MODE	(0x0 << 8)
+#define EMIF4_PWR_PM_TIM	(0x0)
+
+#define EMIF4_INITREF_DIS	(0x0 << 31)
+#define EMIF4_REFRESH_RATE	(0x50F)
+
+#define EMIF4_CFG_SDRAM_TYP	(0x2 << 29)
+#define EMIF4_CFG_IBANK_POS	(0x0 << 27)
+#define EMIF4_CFG_DDR_TERM	(0x0 << 24)
+#define EMIF4_CFG_DDR2_DDQS	(0x1 << 23)
+#define EMIF4_CFG_DDR_DIS_DLL	(0x0 << 20)
+#define EMIF4_CFG_SDR_DRV	(0x0 << 18)
+#define EMIF4_CFG_NARROW_MD	(0x0 << 14)
+#define EMIF4_CFG_CL		(0x5 << 10)
+#define EMIF4_CFG_ROWSIZE	(0x0 << 7)
+#define EMIF4_CFG_IBANK		(0x3 << 4)
+#define EMIF4_CFG_EBANK		(0x0 << 3)
+#define EMIF4_CFG_PGSIZE	(0x2)
+
+/*
+ * EMIF4 PHY Control 1 register configuration
+ */
+#define EMIF4_DDR1_EXT_STRB_EN	(0x1 << 7)
+#define EMIF4_DDR1_EXT_STRB_DIS	(0x0 << 7)
+#define EMIF4_DDR1_PWRDN_DIS	(0x0 << 6)
+#define EMIF4_DDR1_PWRDN_EN	(0x1 << 6)
+#define EMIF4_DDR1_READ_LAT	(0x6 << 0)
+
+#endif /* endif _EMIF_H_ */
diff --git a/include/asm-arm/arch-omap3/mem.h b/include/asm-arm/arch-omap3/mem.h
index 5b9ac75..fd14f3f 100644
--- a/include/asm-arm/arch-omap3/mem.h
+++ b/include/asm-arm/arch-omap3/mem.h
@@ -40,8 +40,8 @@ enum {
 #define EARLY_INIT	1
 
 /* Slower full frequency range default timings for x32 operation*/
-#define SDP_SDRC_SHARING	0x00000100
-#define SDP_SDRC_MR_0_SDR	0x00000031
+#define SDRC_SHARING	0x00000100
+#define SDRC_MR_0_SDR	0x00000031
 
 /* optimized timings good for current shipping parts */
 #define SDP_3430_SDRC_RFR_CTRL_165MHz	0x0004e201 /* 7.8us/6ns - 50=0x4e2 */
@@ -95,6 +95,47 @@ enum {
 #define SDP_SDRC_ACTIM_CTRLB_0	V_ACTIMB_165
 #define SDP_SDRC_RFR_CTRL	SDP_3430_SDRC_RFR_CTRL_165MHz
 
+
+/* Hynix part of AM/DM37xEVM (200MHz optimized)
+ *   ACTIMA
+ *	TDAL		= 6
+ *	TDPL (Twr)	= 3
+ *	TRRD		= 2
+ *	TRCD		= 4
+ *	TRP		= 3
+ *	TRAS		= 8
+ *	TRC		= 11
+ *	TRFC		= 18
+ *   ACTIMB
+ *	TWTR		= 2
+ *	TCKE		= 2
+ *	TXP		= 1
+ *	TXSR		= 28
+ */
+#define TDAL_200	6
+#define TDPL_200	3
+#define TRRD_200	2
+#define TRCD_200	4
+#define TRP_200		3
+#define TRAS_200	8
+#define TRC_200		11
+#define TRFC_200	18
+#define V_ACTIMA_200	((TRFC_200 << 27) | (TRC_200 << 22) | \
+			(TRAS_200 << 18) | (TRP_200 << 15) |  \
+			(TRCD_200 << 12) | (TRRD_200 << 9) |  \
+			(TDPL_200 << 6) | (TDAL_200))
+
+#define TWTR_200	2
+#define TCKE_200	1
+#define TXP_200		1
+#define XSR_200		28
+#define V_ACTIMB_200	(((TCKE_200 << 12) | (XSR_200 << 0)) |	\
+			(TXP_200 << 8) | (TWTR_200 << 16))
+
+#define EVM_SDRC_ACTIM_CTRLA_0	V_ACTIMA_200
+#define EVM_SDRC_ACTIM_CTRLB_0	V_ACTIMB_200
+
+
 /*
  * GPMC settings -
  * Definitions is as per the following format
@@ -145,6 +186,15 @@ enum {
 #define SMNAND_GPMC_CONFIG6	0x1F0F0A80
 #define SMNAND_GPMC_CONFIG7	0x00000C44
 
+#if (defined(CONFIG_OMAP3_AM3517EVM) || defined(CONFIG_OMAP3_AM3517CRANE))
+#define M_NAND_GPMC_CONFIG1	0x00001800
+#define M_NAND_GPMC_CONFIG2	0x00080800
+#define M_NAND_GPMC_CONFIG3	0x00080800
+#define M_NAND_GPMC_CONFIG4	0x06000600
+#define M_NAND_GPMC_CONFIG5	0x00080808
+#define M_NAND_GPMC_CONFIG6	0x000003cf
+#define M_NAND_GPMC_CONFIG7	0x00000848
+#else	/* CONFIG_OMAP3_AM3517EVM or CONFIG_OMAP3_AM3517CRANE */
 #define M_NAND_GPMC_CONFIG1	0x00001800
 #define M_NAND_GPMC_CONFIG2	0x00141400
 #define M_NAND_GPMC_CONFIG3	0x00141400
@@ -152,6 +202,7 @@ enum {
 #define M_NAND_GPMC_CONFIG5	0x010C1414
 #define M_NAND_GPMC_CONFIG6	0x1f0f0A80
 #define M_NAND_GPMC_CONFIG7	0x00000C44
+#endif	/* CONFIG_OMAP3_AM3517EVM or CONFIG_OMAP3_AM3517CRANE */
 
 #define STNOR_GPMC_CONFIG1	0x3
 #define STNOR_GPMC_CONFIG2	0x00151501
@@ -224,4 +275,18 @@ enum {
 #define PISMO1_ONEN_BASE	ONENAND_MAP
 #define DBG_MPDB_BASE		DEBUG_BASE
 
+#ifndef __ASSEMBLY__
+/*
+ * Function prototypes
+ */
+void mem_init(void);
+
+u32 is_mem_sdr(void);
+u32 mem_ok(u32 cs);
+
+u32 get_sdr_cs_size(u32);
+u32 get_sdr_cs_offset(u32);
+
+#endif /* __ASSEMBLY__ */
+
 #endif /* endif _MEM_H_ */
diff --git a/include/asm-arm/arch-omap3/mux.h b/include/asm-arm/arch-omap3/mux.h
index 0c01c73..aec2948 100644
--- a/include/asm-arm/arch-omap3/mux.h
+++ b/include/asm-arm/arch-omap3/mux.h
@@ -284,6 +284,7 @@
 #define CONTROL_PADCONF_SYS_32K		0x0A04
 #define CONTROL_PADCONF_SYS_CLKREQ	0x0A06
 #define CONTROL_PADCONF_SYS_NIRQ	0x01E0
+#define CONTROL_PADCONF_SYS_NRESWARM    0x0A08
 #define CONTROL_PADCONF_SYS_BOOT0	0x0A0A
 #define CONTROL_PADCONF_SYS_BOOT1	0x0A0C
 #define CONTROL_PADCONF_SYS_BOOT2	0x0A0E
@@ -403,6 +404,41 @@
 #define CONTROL_PADCONF_D2D_SBUSFLAG	0x0260
 #define CONTROL_PADCONF_SDRC_CKE0	0x0262
 #define CONTROL_PADCONF_SDRC_CKE1	0x0264
+/* AM3517 specific */
+#define CONTROL_PADCONF_CCDC_PCLK       0x01E4
+#define CONTROL_PADCONF_CCDC_FIELD      0x01E6
+#define CONTROL_PADCONF_CCDC_HD         0x01E8
+#define CONTROL_PADCONF_CCDC_VD         0x01EA
+#define CONTROL_PADCONF_CCDC_WEN        0x01EC
+#define CONTROL_PADCONF_CCDC_DATA0      0x01EE
+#define CONTROL_PADCONF_CCDC_DATA1      0x01F0
+#define CONTROL_PADCONF_CCDC_DATA2      0x01F2
+#define CONTROL_PADCONF_CCDC_DATA3      0x01F4
+#define CONTROL_PADCONF_CCDC_DATA4      0x01F6
+#define CONTROL_PADCONF_CCDC_DATA5      0x01F8
+#define CONTROL_PADCONF_CCDC_DATA6      0x01FA
+#define CONTROL_PADCONF_CCDC_DATA7      0x01FC
+#define CONTROL_PADCONF_RMII_MDIO_DATA  0x01FE
+#define CONTROL_PADCONF_RMII_MDIO_CLK   0x0200
+#define CONTROL_PADCONF_RMII_RXD0       0x0202
+#define CONTROL_PADCONF_RMII_RXD1       0x0204
+#define CONTROL_PADCONF_RMII_CRS_DV     0x0206
+#define CONTROL_PADCONF_RMII_RXER       0x0208
+#define CONTROL_PADCONF_RMII_TXD0       0x020A
+#define CONTROL_PADCONF_RMII_TXD1       0x020C
+#define CONTROL_PADCONF_RMII_TXEN       0x020E
+#define CONTROL_PADCONF_RMII_50MHZ_CLK  0x0210
+#define CONTROL_PADCONF_USB0_DRVBUS     0x0212
+#define CONTROL_PADCONF_HECC1_TXD       0x0214
+#define CONTROL_PADCONF_HECC1_RXD       0x0216
+#define CONTROL_PADCONF_SYS_BOOT7       0x0218
+#define CONTROL_PADCONF_SDRC_DQS0N      0x021A
+#define CONTROL_PADCONF_SDRC_DQS1N      0x021C
+#define CONTROL_PADCONF_SDRC_DQS2N      0x021E
+#define CONTROL_PADCONF_SDRC_DQS3N      0x0220
+#define CONTROL_PADCONF_STRBEN_DLY0     0x0222
+#define CONTROL_PADCONF_STRBEN_DLY1     0x0224
+#define CONTROL_PADCONF_SYS_BOOT8       0x0226
 
 #define MUX_VAL(OFFSET,VALUE)\
 	writew((VALUE), OMAP34XX_CTRL_BASE + (OFFSET));
diff --git a/include/asm-arm/arch-omap3/omap3.h b/include/asm-arm/arch-omap3/omap3.h
index 12815f6..3299695 100644
--- a/include/asm-arm/arch-omap3/omap3.h
+++ b/include/asm-arm/arch-omap3/omap3.h
@@ -161,8 +161,6 @@ struct gpio {
 #define DDR_133		133	/* most combo, some mem d-boards */
 #define DDR_165		165	/* future parts */
 
-#define CPU_3430	0x3430
-
 /*
  * 343x real hardware:
  *  ES1     = rev 0
@@ -183,4 +181,48 @@ struct gpio {
 #define WIDTH_8BIT		0x0000
 #define WIDTH_16BIT		0x1000	/* bit pos for 16 bit in gpmc */
 
+/*
+ * Hawkeye values
+ */
+#define HAWKEYE_OMAP34XX	0xb7ae
+#define HAWKEYE_AM35XX		0xb868
+#define HAWKEYE_OMAP36XX	0xb891
+
+#define HAWKEYE_SHIFT		12
+
+/*
+ * Define CPU families
+ */
+#define CPU_OMAP34XX		0x3400	/* OMAP34xx/OMAP35 devices */
+#define CPU_AM35XX		0x3500	/* AM35xx devices          */
+#define CPU_OMAP36XX		0x3600	/* OMAP36xx devices        */
+
+/*
+ * Define CPUs
+ */
+#define OMAP3430		0x3430
+
+#define OMAP3503		0x3503
+#define OMAP3515		0x3515
+#define OMAP3525		0x3525
+#define OMAP3530		0x3530
+
+#define AM3505			0x3505
+#define AM3517			0x3517
+
+#define OMAP3630		0x3630
+#define OMAP3730		0x3730
+/*
+ * Control status register values corresponding to cpu variants
+ */
+#define CTRL_OMAP3503		0x5c00
+#define CTRL_OMAP3515		0x1c00
+#define CTRL_OMAP3525		0x4c00
+#define CTRL_OMAP3530		0x0c00
+
+#define CTRL_AM3505		0x5c00
+#define CTRL_AM3517		0x1c00
+
+#define CTRL_OMAP3730		0x0c00
+
 #endif
diff --git a/include/asm-arm/arch-omap3/omap3_flash.h b/include/asm-arm/arch-omap3/omap3_flash.h
new file mode 100644
index 0000000..d881ee9
--- /dev/null
+++ b/include/asm-arm/arch-omap3/omap3_flash.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Sanjeev Premi <premi@ti.com>
+ *
+ * Contents moved from existing configurations for OMAP3 based boards.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_OMAP3_FLASH_H
+#define __ASM_ARCH_OMAP3_FLASH_H
+
+#ifndef __ASSEMBLY__
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+#endif /* __ASM_ARCH_OMAP3_FLASH_H */
diff --git a/include/asm-arm/arch-omap3/omap_gpmc.h b/include/asm-arm/arch-omap3/omap_gpmc.h
index bd22bce..d986343 100644
--- a/include/asm-arm/arch-omap3/omap_gpmc.h
+++ b/include/asm-arm/arch-omap3/omap_gpmc.h
@@ -80,4 +80,9 @@
 }
 #endif
 
+#ifndef __ASSEMBLY__
+extern struct gpmc *gpmc_cfg;
+#endif
+
 #endif /* __ASM_ARCH_OMAP_GPMC_H */
+
diff --git a/include/asm-arm/arch-omap3/sys_proto.h b/include/asm-arm/arch-omap3/sys_proto.h
index 34bd515..8840ebe 100644
--- a/include/asm-arm/arch-omap3/sys_proto.h
+++ b/include/asm-arm/arch-omap3/sys_proto.h
@@ -31,8 +31,13 @@ void prcm_init(void);
 void per_clocks_enable(void);
 
 void memif_init(void);
+#if defined(CONFIG_SDRC)
 void sdrc_init(void);
 void do_sdrc_init(u32, u32);
+#endif
+#if defined(CONFIG_EMIF4)
+void emif4_init(void);
+#endif
 void gpmc_init(void);
 void enable_gpmc_cs_config(const u32 *gpmc_config, struct gpmc_cs *cs, u32 base,
 			u32 size);
@@ -40,14 +45,14 @@ void enable_gpmc_cs_config(const u32 *gpmc_config, struct gpmc_cs *cs, u32 base,
 void watchdog_init(void);
 void set_muxconf_regs(void);
 
-u32 get_cpu_rev(void);
+void identify_cpu(void);
+u8 is_cpu_family(u16);
+u8 get_cpu_rev(void);
 u32 get_mem_type(void);
 u32 get_sysboot_value(void);
 u32 is_gpmc_muxed(void);
 u32 get_gpmc0_type(void);
 u32 get_gpmc0_width(void);
-u32 get_sdr_cs_size(u32);
-u32 get_sdr_cs_offset(u32);
 u32 is_running_in_sdram(void);
 u32 is_running_in_sram(void);
 u32 is_running_in_flash(void);
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
index 6c1f5ac..c7d6f66 100644
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -1,9 +1,6 @@
 /*
- * This was automagically generated from mach-types!
+ * This was automagically generated from arch/arm/tools/mach-types!
  * Do NOT edit
- *
- * Last update: Fri Sep 4 22:16:22 2009
- *
  */
 
 #ifndef __ASM_ARM_MACH_TYPE_H
@@ -1637,7 +1634,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_AML_M8050            1644
 #define MACH_TYPE_MX35_3DS             1645
 #define MACH_TYPE_MARS                 1646
-#define MACH_TYPE_NTOSD_644XA          1647
+#define MACH_TYPE_NEUROS_OSD2          1647
 #define MACH_TYPE_BADGER               1648
 #define MACH_TYPE_TRIZEPS4WL           1649
 #define MACH_TYPE_TRIZEPS5             1650
@@ -1653,7 +1650,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_ZORAN43XX            1660
 #define MACH_TYPE_SONIX926             1661
 #define MACH_TYPE_CELESTIALSEMI        1662
-#define MACH_TYPE_CC9M2443             1663
+#define MACH_TYPE_CC9M2443JS           1663
 #define MACH_TYPE_TW5334               1664
 #define MACH_TYPE_HTCARTEMIS           1665
 #define MACH_TYPE_NAL_HLITE            1666
@@ -1801,7 +1798,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_RD88F5181L_GE        1812
 #define MACH_TYPE_SIFMAIN              1813
 #define MACH_TYPE_SAM9_L9261           1814
-#define MACH_TYPE_CC9M2443JS           1815
+#define MACH_TYPE_CC9M2443             1815
 #define MACH_TYPE_XARIA300             1816
 #define MACH_TYPE_IT9200               1817
 #define MACH_TYPE_RD88F5181L_FXO       1818
@@ -2401,6 +2398,141 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_MULTIBUS_MASTER      2416
 #define MACH_TYPE_MULTIBUS_PBK         2417
 #define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_SNAKE                2419
+#define MACH_TYPE_CWMX27               2420
+#define MACH_TYPE_SCH_M480             2421
+#define MACH_TYPE_PLATYPUS             2422
+#define MACH_TYPE_PSS2                 2423
+#define MACH_TYPE_DAVINCI_APM150       2424
+#define MACH_TYPE_STR9100              2425
+#define MACH_TYPE_NET5BIG              2426
+#define MACH_TYPE_SEABED9263           2427
+#define MACH_TYPE_MX51_M2ID            2428
+#define MACH_TYPE_OCTVOCPLUS_EB        2429
+#define MACH_TYPE_KLK_FIREFOX          2430
+#define MACH_TYPE_KLK_WIRMA_MODULE     2431
+#define MACH_TYPE_KLK_WIRMA_MMI        2432
+#define MACH_TYPE_SUPERSONIC           2433
+#define MACH_TYPE_LIBERTY              2434
+#define MACH_TYPE_MH355                2435
+#define MACH_TYPE_PC7802               2436
+#define MACH_TYPE_GNET_SGC             2437
+#define MACH_TYPE_EINSTEIN15           2438
+#define MACH_TYPE_CMPD                 2439
+#define MACH_TYPE_DAVINCI_HASE1        2440
+#define MACH_TYPE_LGEINCITEPHONE       2441
+#define MACH_TYPE_EA313X               2442
+#define MACH_TYPE_FWBD_39064           2443
+#define MACH_TYPE_FWBD_390128          2444
+#define MACH_TYPE_PELCO_MOE            2445
+#define MACH_TYPE_MINIMIX27            2446
+#define MACH_TYPE_OMAP3_THUNDER        2447
+#define MACH_TYPE_PASSIONC             2448
+#define MACH_TYPE_MX27AMATA            2449
+#define MACH_TYPE_BGAT1                2450
+#define MACH_TYPE_BUZZ                 2451
+#define MACH_TYPE_MB9G20               2452
+#define MACH_TYPE_YUSHAN               2453
+#define MACH_TYPE_LIZARD               2454
+#define MACH_TYPE_OMAP3POLYCOM         2455
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_BRAVO                2457
+#define MACH_TYPE_SIOGENTOO1           2458
+#define MACH_TYPE_SIOGENTOO2           2459
+#define MACH_TYPE_SM3K                 2460
+#define MACH_TYPE_ACER_TEMPO_F900      2461
+#define MACH_TYPE_SST61VC010_DEV       2462
+#define MACH_TYPE_GLITTERTIND          2463
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_CYBOOK2440           2466
+#define MACH_TYPE_TORINO_S             2467
+#define MACH_TYPE_HAVANA               2468
+#define MACH_TYPE_BEAUMONT_11          2469
+#define MACH_TYPE_VANGUARD             2470
+#define MACH_TYPE_S5PC110_DRACO        2471
+#define MACH_TYPE_CARTESIO_TWO         2472
+#define MACH_TYPE_ASTER                2473
+#define MACH_TYPE_VOGUESV210           2474
+#define MACH_TYPE_ACM500X              2475
+#define MACH_TYPE_KM9260               2476
+#define MACH_TYPE_NIDEFLEXG1           2477
+#define MACH_TYPE_CTERA_PLUG_IO        2478
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_AT91SAM9G10EK2       2480
+#define MACH_TYPE_ASUSP527             2481
+#define MACH_TYPE_AT91SAM9G20MPM2      2482
+#define MACH_TYPE_TOPASA900            2483
+#define MACH_TYPE_ELECTRUM_100         2484
+#define MACH_TYPE_MX51GRB              2485
+#define MACH_TYPE_XEA300               2486
+#define MACH_TYPE_HTCSTARTREK          2487
+#define MACH_TYPE_LIMA                 2488
+#define MACH_TYPE_CSB740               2489
+#define MACH_TYPE_USB_S8815            2490
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_MILKYWAY             2492
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_PICOMOD6             2494
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_IP6000               2496
+#define MACH_TYPE_IP6010               2497
+#define MACH_TYPE_UTM400               2498
+#define MACH_TYPE_OMAP3_ZYBEX          2499
+#define MACH_TYPE_WIRELESS_SPACE       2500
+#define MACH_TYPE_SX560                2501
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_ELPHEL10373          2503
+#define MACH_TYPE_RHOBOT               2504
+#define MACH_TYPE_MX51_REFRESH         2505
+#define MACH_TYPE_LS9260               2506
+#define MACH_TYPE_SHANK                2507
+#define MACH_TYPE_QSD8X50_ST1          2508
+#define MACH_TYPE_AT91SAM9M10EKES      2509
+#define MACH_TYPE_HIRAM                2510
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_EA3250               2512
+#define MACH_TYPE_FDI3250              2513
+#define MACH_TYPE_WHITESTONE           2514
+#define MACH_TYPE_AT91SAM9263NIT       2515
+#define MACH_TYPE_CCMX51               2516
+#define MACH_TYPE_CCMX51JS             2517
+#define MACH_TYPE_CCWMX51              2518
+#define MACH_TYPE_CCWMX51JS            2519
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_TINY6410             2521
+#define MACH_TYPE_NANO6410             2522
+#define MACH_TYPE_AT572D940HFNLDB      2523
+#define MACH_TYPE_HTCLEO               2524
+#define MACH_TYPE_AVP13                2525
+#define MACH_TYPE_XXSVIDEOD            2526
+#define MACH_TYPE_VPNEXT               2527
+#define MACH_TYPE_SWARCO_ITC3          2528
+#define MACH_TYPE_TX51                 2529
+#define MACH_TYPE_DOLBY_CAT1021        2530
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_PHOENIX260           2532
+#define MACH_TYPE_UVACA_STORK          2533
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_ALL3078              2535
+#define MACH_TYPE_CTERA_2BAY_DS        2536
+#define MACH_TYPE_SIOGENTOO3           2537
+#define MACH_TYPE_EPB5000              2538
+#define MACH_TYPE_HY9263               2539
+#define MACH_TYPE_ACER_TEMPO_M900      2540
+#define MACH_TYPE_ACER_TEMPO_DX900     2541
+#define MACH_TYPE_ACER_TEMPO_X960      2542
+#define MACH_TYPE_ACER_ETEN_V900       2543
+#define MACH_TYPE_ACER_ETEN_X900       2544
+#define MACH_TYPE_BONNELL              2545
+#define MACH_TYPE_OHT_MX27             2546
+#define MACH_TYPE_HTCQUARTZ            2547
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_C3AX03               2549
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_ESYX                 2551
+#define MACH_TYPE_BULLDOG              2553
+#define MACH_TYPE_CRANEBOARD           2932
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -13353,9 +13485,9 @@ extern unsigned int __machine_arch_type;
 # else
 #  define machine_arch_type	MACH_TYPE_REA_2D
 # endif
-# define machine_is_rea_2d()	(machine_arch_type == MACH_TYPE_REA_2D)
+# define machine_is_rea_cpu2()	(machine_arch_type == MACH_TYPE_REA_2D)
 #else
-# define machine_is_rea_2d()	(0)
+# define machine_is_rea_cpu2()	(0)
 #endif
 
 #ifdef CONFIG_MACH_TI3E524
@@ -21866,16 +21998,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_mars()	(0)
 #endif
 
-#ifdef CONFIG_MACH_NTOSD_644XA
+#ifdef CONFIG_MACH_NEUROS_OSD2
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_NTOSD_644XA
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
 # endif
-# define machine_is_ntosd_644xa()	(machine_arch_type == MACH_TYPE_NTOSD_644XA)
+# define machine_is_neuros_osd2() (machine_arch_type == MACH_TYPE_NEUROS_OSD2)
 #else
-# define machine_is_ntosd_644xa()	(0)
+# define machine_is_neuros_osd2()	(0)
 #endif
 
 #ifdef CONFIG_MACH_BADGER
@@ -22058,16 +22190,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_celestialsemi()	(0)
 #endif
 
-#ifdef CONFIG_MACH_CC9M2443
+#ifdef CONFIG_MACH_CC9M2443JS
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_CC9M2443
+#  define machine_arch_type	MACH_TYPE_CC9M2443JS
 # endif
-# define machine_is_cc9m2443()	(machine_arch_type == MACH_TYPE_CC9M2443)
+# define machine_is_cc9m2443js() (machine_arch_type == MACH_TYPE_CC9M2443JS)
 #else
-# define machine_is_cc9m2443()	(0)
+# define machine_is_cc9m2443js()	(0)
 #endif
 
 #ifdef CONFIG_MACH_TW5334
@@ -23834,16 +23966,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_sam9_l9261()	(0)
 #endif
 
-#ifdef CONFIG_MACH_CC9M2443JS
+#ifdef CONFIG_MACH_CC9M2443
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_CC9M2443JS
+#  define machine_arch_type	MACH_TYPE_CC9M2443
 # endif
-# define machine_is_cc9m2443js()	(machine_arch_type == MACH_TYPE_CC9M2443JS)
+# define machine_is_cc9m2443()	(machine_arch_type == MACH_TYPE_CC9M2443)
 #else
-# define machine_is_cc9m2443js()	(0)
+# define machine_is_cc9m2443()	(0)
 #endif
 
 #ifdef CONFIG_MACH_XARIA300
@@ -31034,6 +31166,1661 @@ extern unsigned int __machine_arch_type;
 # define machine_is_tnetv107x()	(0)
 #endif
 
+#ifdef CONFIG_MACH_SNAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAKE
+# endif
+# define machine_is_snake()	(machine_arch_type == MACH_TYPE_SNAKE)
+#else
+# define machine_is_snake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX27
+# endif
+# define machine_is_cwmx27()	(machine_arch_type == MACH_TYPE_CWMX27)
+#else
+# define machine_is_cwmx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCH_M480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCH_M480
+# endif
+# define machine_is_sch_m480()	(machine_arch_type == MACH_TYPE_SCH_M480)
+#else
+# define machine_is_sch_m480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLATYPUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLATYPUS
+# endif
+# define machine_is_platypus()	(machine_arch_type == MACH_TYPE_PLATYPUS)
+#else
+# define machine_is_platypus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSS2
+# endif
+# define machine_is_pss2()	(machine_arch_type == MACH_TYPE_PSS2)
+#else
+# define machine_is_pss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_APM150
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_APM150
+# endif
+# define machine_is_davinci_apm150() \
+			(machine_arch_type == MACH_TYPE_DAVINCI_APM150)
+#else
+# define machine_is_davinci_apm150()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR9100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR9100
+# endif
+# define machine_is_str9100()	(machine_arch_type == MACH_TYPE_STR9100)
+#else
+# define machine_is_str9100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG
+# endif
+# define machine_is_net5big()	(machine_arch_type == MACH_TYPE_NET5BIG)
+#else
+# define machine_is_net5big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABED9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABED9263
+# endif
+# define machine_is_seabed9263() (machine_arch_type == MACH_TYPE_SEABED9263)
+#else
+# define machine_is_seabed9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_M2ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_M2ID
+# endif
+# define machine_is_mx51_m2id()	(machine_arch_type == MACH_TYPE_MX51_M2ID)
+#else
+# define machine_is_mx51_m2id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCTVOCPLUS_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCTVOCPLUS_EB
+# endif
+# define machine_is_octvocplus_eb() \
+				(machine_arch_type == MACH_TYPE_OCTVOCPLUS_EB)
+#else
+# define machine_is_octvocplus_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_FIREFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_FIREFOX
+# endif
+# define machine_is_klk_firefox() (machine_arch_type == MACH_TYPE_KLK_FIREFOX)
+#else
+# define machine_is_klk_firefox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_WIRMA_MODULE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_WIRMA_MODULE
+# endif
+# define machine_is_klk_wirma_module() \
+			(machine_arch_type == MACH_TYPE_KLK_WIRMA_MODULE)
+#else
+# define machine_is_klk_wirma_module()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_WIRMA_MMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_WIRMA_MMI
+# endif
+# define machine_is_klk_wirma_mmi() \
+				(machine_arch_type == MACH_TYPE_KLK_WIRMA_MMI)
+#else
+# define machine_is_klk_wirma_mmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUPERSONIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUPERSONIC
+# endif
+# define machine_is_supersonic() (machine_arch_type == MACH_TYPE_SUPERSONIC)
+#else
+# define machine_is_supersonic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBERTY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBERTY
+# endif
+# define machine_is_liberty()	(machine_arch_type == MACH_TYPE_LIBERTY)
+#else
+# define machine_is_liberty()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MH355
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MH355
+# endif
+# define machine_is_mh355()	(machine_arch_type == MACH_TYPE_MH355)
+#else
+# define machine_is_mh355()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7802
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7802
+# endif
+# define machine_is_pc7802()	(machine_arch_type == MACH_TYPE_PC7802)
+#else
+# define machine_is_pc7802()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGC
+# endif
+# define machine_is_gnet_sgc()	(machine_arch_type == MACH_TYPE_GNET_SGC)
+#else
+# define machine_is_gnet_sgc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EINSTEIN15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EINSTEIN15
+# endif
+# define machine_is_einstein15() (machine_arch_type == MACH_TYPE_EINSTEIN15)
+#else
+# define machine_is_einstein15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPD
+# endif
+# define machine_is_cmpd()	(machine_arch_type == MACH_TYPE_CMPD)
+#else
+# define machine_is_cmpd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_HASE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_HASE1
+# endif
+# define machine_is_davinci_hase1() \
+			 (machine_arch_type == MACH_TYPE_DAVINCI_HASE1)
+#else
+# define machine_is_davinci_hase1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LGEINCITEPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LGEINCITEPHONE
+# endif
+# define machine_is_lgeincitephone() \
+			(machine_arch_type == MACH_TYPE_LGEINCITEPHONE)
+#else
+# define machine_is_lgeincitephone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA313X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA313X
+# endif
+# define machine_is_ea313x()	(machine_arch_type == MACH_TYPE_EA313X)
+#else
+# define machine_is_ea313x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_39064
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_39064
+# endif
+# define machine_is_fwbd_39064() (machine_arch_type == MACH_TYPE_FWBD_39064)
+#else
+# define machine_is_fwbd_39064()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_390128
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_390128
+# endif
+# define machine_is_fwbd_390128() (machine_arch_type == MACH_TYPE_FWBD_390128)
+#else
+# define machine_is_fwbd_390128()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MOE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MOE
+# endif
+# define machine_is_pelco_moe()	(machine_arch_type == MACH_TYPE_PELCO_MOE)
+#else
+# define machine_is_pelco_moe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIMIX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIMIX27
+# endif
+# define machine_is_minimix27()	(machine_arch_type == MACH_TYPE_MINIMIX27)
+#else
+# define machine_is_minimix27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_THUNDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_THUNDER
+# endif
+# define machine_is_omap3_thunder() \
+				(machine_arch_type == MACH_TYPE_OMAP3_THUNDER)
+#else
+# define machine_is_omap3_thunder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSIONC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSIONC
+# endif
+# define machine_is_passionc()	(machine_arch_type == MACH_TYPE_PASSIONC)
+#else
+# define machine_is_passionc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27AMATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27AMATA
+# endif
+# define machine_is_mx27amata()	(machine_arch_type == MACH_TYPE_MX27AMATA)
+#else
+# define machine_is_mx27amata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BGAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BGAT1
+# endif
+# define machine_is_bgat1()	(machine_arch_type == MACH_TYPE_BGAT1)
+#else
+# define machine_is_bgat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUZZ
+# endif
+# define machine_is_buzz()	(machine_arch_type == MACH_TYPE_BUZZ)
+#else
+# define machine_is_buzz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9G20
+# endif
+# define machine_is_mb9g20()	(machine_arch_type == MACH_TYPE_MB9G20)
+#else
+# define machine_is_mb9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YUSHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YUSHAN
+# endif
+# define machine_is_yushan()	(machine_arch_type == MACH_TYPE_YUSHAN)
+#else
+# define machine_is_yushan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIZARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIZARD
+# endif
+# define machine_is_lizard()	(machine_arch_type == MACH_TYPE_LIZARD)
+#else
+# define machine_is_lizard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3POLYCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3POLYCOM
+# endif
+# define machine_is_omap3polycom() \
+				(machine_arch_type == MACH_TYPE_OMAP3POLYCOM)
+#else
+# define machine_is_omap3polycom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BRAVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRAVO
+# endif
+# define machine_is_bravo()	(machine_arch_type == MACH_TYPE_BRAVO)
+#else
+# define machine_is_bravo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO1
+# endif
+# define machine_is_siogentoo1() (machine_arch_type == MACH_TYPE_SIOGENTOO1)
+#else
+# define machine_is_siogentoo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO2
+# endif
+# define machine_is_siogentoo2() (machine_arch_type == MACH_TYPE_SIOGENTOO2)
+#else
+# define machine_is_siogentoo2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM3K
+# endif
+# define machine_is_sm3k()	(machine_arch_type == MACH_TYPE_SM3K)
+#else
+# define machine_is_sm3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_F900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_F900
+# endif
+# define machine_is_acer_tempo_f900() \
+			(machine_arch_type == MACH_TYPE_ACER_TEMPO_F900)
+#else
+# define machine_is_acer_tempo_f900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SST61VC010_DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SST61VC010_DEV
+# endif
+# define machine_is_sst61vc010_dev() \
+			(machine_arch_type == MACH_TYPE_SST61VC010_DEV)
+#else
+# define machine_is_sst61vc010_dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLITTERTIND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLITTERTIND
+# endif
+# define machine_is_glittertind() (machine_arch_type == MACH_TYPE_GLITTERTIND)
+#else
+# define machine_is_glittertind()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3() (machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp() \
+			 (machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBOOK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBOOK2440
+# endif
+# define machine_is_cybook2440() (machine_arch_type == MACH_TYPE_CYBOOK2440)
+#else
+# define machine_is_cybook2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORINO_S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORINO_S
+# endif
+# define machine_is_torino_s()	(machine_arch_type == MACH_TYPE_TORINO_S)
+#else
+# define machine_is_torino_s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAVANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAVANA
+# endif
+# define machine_is_havana()	(machine_arch_type == MACH_TYPE_HAVANA)
+#else
+# define machine_is_havana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEAUMONT_11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEAUMONT_11
+# endif
+# define machine_is_beaumont_11() (machine_arch_type == MACH_TYPE_BEAUMONT_11)
+#else
+# define machine_is_beaumont_11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGUARD
+# endif
+# define machine_is_vanguard()	(machine_arch_type == MACH_TYPE_VANGUARD)
+#else
+# define machine_is_vanguard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5PC110_DRACO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5PC110_DRACO
+# endif
+# define machine_is_s5pc110_draco() \
+			(machine_arch_type == MACH_TYPE_S5PC110_DRACO)
+#else
+# define machine_is_s5pc110_draco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARTESIO_TWO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARTESIO_TWO
+# endif
+# define machine_is_cartesio_two() \
+				(machine_arch_type == MACH_TYPE_CARTESIO_TWO)
+#else
+# define machine_is_cartesio_two()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTER
+# endif
+# define machine_is_aster()	(machine_arch_type == MACH_TYPE_ASTER)
+#else
+# define machine_is_aster()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOGUESV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOGUESV210
+# endif
+# define machine_is_voguesv210() (machine_arch_type == MACH_TYPE_VOGUESV210)
+#else
+# define machine_is_voguesv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACM500X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACM500X
+# endif
+# define machine_is_acm500x()	(machine_arch_type == MACH_TYPE_ACM500X)
+#else
+# define machine_is_acm500x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KM9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KM9260
+# endif
+# define machine_is_km9260()	(machine_arch_type == MACH_TYPE_KM9260)
+#else
+# define machine_is_km9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIDEFLEXG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIDEFLEXG1
+# endif
+# define machine_is_nideflexg1() (machine_arch_type == MACH_TYPE_NIDEFLEXG1)
+#else
+# define machine_is_nideflexg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_IO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_IO
+# endif
+# define machine_is_ctera_plug_io() \
+				(machine_arch_type == MACH_TYPE_CTERA_PLUG_IO)
+#else
+# define machine_is_ctera_plug_io()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK2
+# endif
+# define machine_is_at91sam9g10ek2() \
+			(machine_arch_type == MACH_TYPE_AT91SAM9G10EK2)
+#else
+# define machine_is_at91sam9g10ek2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP527
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP527
+# endif
+# define machine_is_asusp527()	(machine_arch_type == MACH_TYPE_ASUSP527)
+#else
+# define machine_is_asusp527()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20MPM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20MPM2
+# endif
+# define machine_is_at91sam9g20mpm2() \
+			(machine_arch_type == MACH_TYPE_AT91SAM9G20MPM2)
+#else
+# define machine_is_at91sam9g20mpm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPASA900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPASA900
+# endif
+# define machine_is_topasa900()	(machine_arch_type == MACH_TYPE_TOPASA900)
+#else
+# define machine_is_topasa900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELECTRUM_100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELECTRUM_100
+# endif
+# define machine_is_electrum_100() \
+			(machine_arch_type == MACH_TYPE_ELECTRUM_100)
+#else
+# define machine_is_electrum_100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51GRB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51GRB
+# endif
+# define machine_is_mx51grb()	(machine_arch_type == MACH_TYPE_MX51GRB)
+#else
+# define machine_is_mx51grb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XEA300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XEA300
+# endif
+# define machine_is_xea300()	(machine_arch_type == MACH_TYPE_XEA300)
+#else
+# define machine_is_xea300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCSTARTREK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCSTARTREK
+# endif
+# define machine_is_htcstartrek() (machine_arch_type == MACH_TYPE_HTCSTARTREK)
+#else
+# define machine_is_htcstartrek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIMA
+# endif
+# define machine_is_lima()	(machine_arch_type == MACH_TYPE_LIMA)
+#else
+# define machine_is_lima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB740
+# endif
+# define machine_is_csb740()	(machine_arch_type == MACH_TYPE_CSB740)
+#else
+# define machine_is_csb740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_S8815
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_S8815
+# endif
+# define machine_is_usb_s8815()	(machine_arch_type == MACH_TYPE_USB_S8815)
+#else
+# define machine_is_usb_s8815()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin() \
+			(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILKYWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILKYWAY
+# endif
+# define machine_is_milkyway()	(machine_arch_type == MACH_TYPE_MILKYWAY)
+#else
+# define machine_is_milkyway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOMOD6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOMOD6
+# endif
+# define machine_is_picomod6()	(machine_arch_type == MACH_TYPE_PICOMOD6)
+#else
+# define machine_is_picomod6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()\
+			(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP6000
+# endif
+# define machine_is_ip6000()	(machine_arch_type == MACH_TYPE_IP6000)
+#else
+# define machine_is_ip6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP6010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP6010
+# endif
+# define machine_is_ip6010()	(machine_arch_type == MACH_TYPE_IP6010)
+#else
+# define machine_is_ip6010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UTM400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UTM400
+# endif
+# define machine_is_utm400()	(machine_arch_type == MACH_TYPE_UTM400)
+#else
+# define machine_is_utm400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_ZYBEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_ZYBEX
+# endif
+# define machine_is_omap3_zybex() (machine_arch_type == MACH_TYPE_OMAP3_ZYBEX)
+#else
+# define machine_is_omap3_zybex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WIRELESS_SPACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WIRELESS_SPACE
+# endif
+# define machine_is_wireless_space() \
+			(machine_arch_type == MACH_TYPE_WIRELESS_SPACE)
+#else
+# define machine_is_wireless_space()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX560
+# endif
+# define machine_is_sx560()	(machine_arch_type == MACH_TYPE_SX560)
+#else
+# define machine_is_sx560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELPHEL10373
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELPHEL10373
+# endif
+# define machine_is_elphel10373() (machine_arch_type == MACH_TYPE_ELPHEL10373)
+#else
+# define machine_is_elphel10373()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHOBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHOBOT
+# endif
+# define machine_is_rhobot()	(machine_arch_type == MACH_TYPE_RHOBOT)
+#else
+# define machine_is_rhobot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_REFRESH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_REFRESH
+# endif
+# define machine_is_mx51_refresh() \
+			(machine_arch_type == MACH_TYPE_MX51_REFRESH)
+#else
+# define machine_is_mx51_refresh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LS9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LS9260
+# endif
+# define machine_is_ls9260()	(machine_arch_type == MACH_TYPE_LS9260)
+#else
+# define machine_is_ls9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANK
+# endif
+# define machine_is_shank()	(machine_arch_type == MACH_TYPE_SHANK)
+#else
+# define machine_is_shank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_ST1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_ST1
+# endif
+# define machine_is_qsd8x50_st1() (machine_arch_type == MACH_TYPE_QSD8X50_ST1)
+#else
+# define machine_is_qsd8x50_st1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10EKES
+# endif
+# define machine_is_at91sam9m10ekes() \
+			(machine_arch_type == MACH_TYPE_AT91SAM9M10EKES)
+#else
+# define machine_is_at91sam9m10ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIRAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIRAM
+# endif
+# define machine_is_hiram()	(machine_arch_type == MACH_TYPE_HIRAM)
+#else
+# define machine_is_hiram()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA3250
+# endif
+# define machine_is_ea3250()	(machine_arch_type == MACH_TYPE_EA3250)
+#else
+# define machine_is_ea3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FDI3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FDI3250
+# endif
+# define machine_is_fdi3250()	(machine_arch_type == MACH_TYPE_FDI3250)
+#else
+# define machine_is_fdi3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHITESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITESTONE
+# endif
+# define machine_is_whitestone() (machine_arch_type == MACH_TYPE_WHITESTONE)
+#else
+# define machine_is_whitestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263NIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263NIT
+# endif
+# define machine_is_at91sam9263nit() \
+			(machine_arch_type == MACH_TYPE_AT91SAM9263NIT)
+#else
+# define machine_is_at91sam9263nit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX51
+# endif
+# define machine_is_ccmx51()	(machine_arch_type == MACH_TYPE_CCMX51)
+#else
+# define machine_is_ccmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX51JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX51JS
+# endif
+# define machine_is_ccmx51js()	(machine_arch_type == MACH_TYPE_CCMX51JS)
+#else
+# define machine_is_ccmx51js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51
+# endif
+# define machine_is_ccwmx51()	(machine_arch_type == MACH_TYPE_CCWMX51)
+#else
+# define machine_is_ccwmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51JS
+# endif
+# define machine_is_ccwmx51js()	(machine_arch_type == MACH_TYPE_CCWMX51JS)
+#else
+# define machine_is_ccwmx51js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINY6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINY6410
+# endif
+# define machine_is_tiny6410()	(machine_arch_type == MACH_TYPE_TINY6410)
+#else
+# define machine_is_tiny6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANO6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANO6410
+# endif
+# define machine_is_nano6410()	(machine_arch_type == MACH_TYPE_NANO6410)
+#else
+# define machine_is_nano6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFNLDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFNLDB
+# endif
+# define machine_is_at572d940hfnldb() \
+			(machine_arch_type == MACH_TYPE_AT572D940HFNLDB)
+#else
+# define machine_is_at572d940hfnldb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCLEO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCLEO
+# endif
+# define machine_is_htcleo()	(machine_arch_type == MACH_TYPE_HTCLEO)
+#else
+# define machine_is_htcleo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVP13
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVP13
+# endif
+# define machine_is_avp13()	(machine_arch_type == MACH_TYPE_AVP13)
+#else
+# define machine_is_avp13()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XXSVIDEOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XXSVIDEOD
+# endif
+# define machine_is_xxsvideod()	(machine_arch_type == MACH_TYPE_XXSVIDEOD)
+#else
+# define machine_is_xxsvideod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPNEXT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPNEXT
+# endif
+# define machine_is_vpnext()	(machine_arch_type == MACH_TYPE_VPNEXT)
+#else
+# define machine_is_vpnext()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_ITC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_ITC3
+# endif
+# define machine_is_swarco_itc3() \
+			(machine_arch_type == MACH_TYPE_SWARCO_ITC3)
+#else
+# define machine_is_swarco_itc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX51
+# endif
+# define machine_is_tx51()	(machine_arch_type == MACH_TYPE_TX51)
+#else
+# define machine_is_tx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOLBY_CAT1021
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOLBY_CAT1021
+# endif
+# define machine_is_dolby_cat1021() \
+				(machine_arch_type == MACH_TYPE_DOLBY_CAT1021)
+#else
+# define machine_is_dolby_cat1021()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX260
+# endif
+# define machine_is_phoenix260() \
+			(machine_arch_type == MACH_TYPE_PHOENIX260)
+#else
+# define machine_is_phoenix260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UVACA_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UVACA_STORK
+# endif
+# define machine_is_uvaca_stork() \
+				(machine_arch_type == MACH_TYPE_UVACA_STORK)
+#else
+# define machine_is_uvaca_stork()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALL3078
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALL3078
+# endif
+# define machine_is_all3078()	(machine_arch_type == MACH_TYPE_ALL3078)
+#else
+# define machine_is_all3078()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_DS
+# endif
+# define machine_is_ctera_2bay_ds() \
+				(machine_arch_type == MACH_TYPE_CTERA_2BAY_DS)
+#else
+# define machine_is_ctera_2bay_ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO3
+# endif
+# define machine_is_siogentoo3() (machine_arch_type == MACH_TYPE_SIOGENTOO3)
+#else
+# define machine_is_siogentoo3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPB5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPB5000
+# endif
+# define machine_is_epb5000()	(machine_arch_type == MACH_TYPE_EPB5000)
+#else
+# define machine_is_epb5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY9263
+# endif
+# define machine_is_hy9263()	(machine_arch_type == MACH_TYPE_HY9263)
+#else
+# define machine_is_hy9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_M900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_M900
+# endif
+# define machine_is_acer_tempo_m900() \
+			(machine_arch_type == MACH_TYPE_ACER_TEMPO_M900)
+#else
+# define machine_is_acer_tempo_m900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_DX900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_DX900
+# endif
+# define machine_is_acer_tempo_dx650() \
+			(machine_arch_type == MACH_TYPE_ACER_TEMPO_DX900)
+#else
+# define machine_is_acer_tempo_dx650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_X960
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_X960
+# endif
+# define machine_is_acer_tempo_x960() \
+			(machine_arch_type == MACH_TYPE_ACER_TEMPO_X960)
+#else
+# define machine_is_acer_tempo_x960()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_ETEN_V900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_ETEN_V900
+# endif
+# define machine_is_acer_eten_v900() \
+			(machine_arch_type == MACH_TYPE_ACER_ETEN_V900)
+#else
+# define machine_is_acer_eten_v900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_ETEN_X900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_ETEN_X900
+# endif
+# define machine_is_acer_eten_x900() \
+			(machine_arch_type == MACH_TYPE_ACER_ETEN_X900)
+#else
+# define machine_is_acer_eten_x900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONNELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONNELL
+# endif
+# define machine_is_bonnell()	(machine_arch_type == MACH_TYPE_BONNELL)
+#else
+# define machine_is_bonnell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OHT_MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OHT_MX27
+# endif
+# define machine_is_oht_mx27()	(machine_arch_type == MACH_TYPE_OHT_MX27)
+#else
+# define machine_is_oht_mx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCQUARTZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCQUARTZ
+# endif
+# define machine_is_htcquartz()	(machine_arch_type == MACH_TYPE_HTCQUARTZ)
+#else
+# define machine_is_htcquartz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm() \
+			(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C3AX03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C3AX03
+# endif
+# define machine_is_c3ax03()	(machine_arch_type == MACH_TYPE_C3AX03)
+#else
+# define machine_is_c3ax03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESYX
+# endif
+# define machine_is_esyx()	(machine_arch_type == MACH_TYPE_ESYX)
+#else
+# define machine_is_esyx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BULLDOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BULLDOG
+# endif
+# define machine_is_bulldog()	(machine_arch_type == MACH_TYPE_BULLDOG)
+#else
+# define machine_is_bulldog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRANEBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRANEBOARD
+# endif
+# define machine_is_craneboard() (machine_arch_type == MACH_TYPE_CRANEBOARD)
+#else
+# define machine_is_craneboard()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/include/configs/am3517_crane.h b/include/configs/am3517_crane.h
new file mode 100644
index 0000000..f260e72
--- /dev/null
+++ b/include/configs/am3517_crane.h
@@ -0,0 +1,352 @@
+/*
+ * am3517_crane.h - Default configuration for AM3517/05 Craneboard.
+ *
+ * Author: Srinath.R <srinath@mistralsolutions.com>
+ *
+ * Based on include/configs/am3517evm.h
+ *
+ * Copyright (C) 2010 Mistral Solutions pvt Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_EMIF4		1	/* The chip has EMIF4 controller */
+
+/* working with AM3517/05 Craneboard */
+#define CONFIG_OMAP3_AM3517CRANE	1
+
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/*
+ * Display CPU and Board information
+ */
+#define CONFIG_DISPLAY_CPUINFO		1
+#define CONFIG_DISPLAY_BOARDINFO	1
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ				/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128 KiB sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128 << 10))
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+/*
+ * DDR related
+ */
+#define CONFIG_OMAP3_MICRON_DDR		1	/* Micron DDR */
+#define CONFIG_SYS_CS0_SIZE		(256 * 1024 * 1024)
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3	/* UART3 on AM3517 CRANE */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+#define CONFIG_USB_AM3517		1
+#define CONFIG_MUSB_HCD			1
+#define CONFIG_MUSB_UDC			1
+
+#ifdef CONFIG_USB_AM3517
+
+#ifdef CONFIG_MUSB_HCD
+#define CONFIG_CMD_USB
+
+#define CONFIG_USB_STORAGE
+#define CONGIG_CMD_STORAGE
+#define CONFIG_CMD_FAT
+
+#ifdef CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_PREBOOT "usb start"
+#endif /* CONFIG_USB_KEYBOARD */
+
+#endif /* CONFIG_MUSB_HCD */
+
+#ifdef CONFIG_MUSB_UDC
+/* USB device configuration */
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+/* Change these to suit your needs */
+#define CONFIG_USBD_VENDORID		0x0451
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Texas Instruments"
+#define CONFIG_USBD_PRODUCT_NAME	"CRANE"
+#endif /* CONFIG_MUSB_UDC */
+
+#endif /* CONFIG_USB_AM3517 */
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_HARD_I2C			1
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+#define CONFIG_CMD_NET
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access */
+							/* nand at CS0 */
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of */
+							/* NAND devices */
+#define CONFIG_SYS_64BIT_VSPRINTF		/* needed for nand_util.c */
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* sz of jffs2 part */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY	10
+
+#define CONFIG_BOOTFILE		uImage
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait eth=${ethaddr} ip=dhcp\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2 eth=${ethaddr} ip=dhcp\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc init; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE	1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT			"AM3517_CRANE # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		32	/* max number of command */
+						/* args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0) /* default load */
+								/* address */
+
+/*
+ * AM3517 has 12 GP timers, they can be driven by the system clock
+ * (12/13/16.8/19.2/38.4MHz) or by 32KHz clock. We use 13MHz (V_SCLK).
+ * This rate is divided by a local divisor.
+ */
+#define CONFIG_SYS_TIMERBASE		OMAP34XX_GPT2
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 << 10)	/* regular stack 128 KiB */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4 << 10)	/* IRQ stack 4 KiB */
+#define CONFIG_STACKSIZE_FIQ	(4 << 10)	/* FIQ stack 4 KiB */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	(32 << 20)	/* at least 32 MiB */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors */
+						/* on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_ENV_IS_IN_NAND		1
+#define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			boot_flash_env_addr
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
+
+
+
+/*-----------------------------------------------------
+ * ethernet support for AM3517/05 Craneboard
+ *------------------------------------------------
+ */
+#if defined(CONFIG_CMD_NET)
+#define CONFIG_DRIVER_TI_EMAC
+#define CONFIG_DRIVER_TI_EMAC_USE_RMII
+#define CONFIG_MII
+#define	CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_NET_RETRY_COUNT 10
+#define CONFIG_NET_MULTI
+#endif
+
+#endif /* __CONFIG_H */
+
diff --git a/include/configs/am3517_evm.h b/include/configs/am3517_evm.h
new file mode 100644
index 0000000..221a572
--- /dev/null
+++ b/include/configs/am3517_evm.h
@@ -0,0 +1,350 @@
+/*
+ * am3517_evm.h - Default configuration for AM3517 EVM board.
+ *
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Based on omap3_evm_config.h
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3_AM3517EVM	1	/* working with AM3517EVM */
+
+#define CONFIG_EMIF4		1	/* The chip has EMIF4 controller */
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/*
+ * Display CPU and Board information
+ */
+#define CONFIG_DISPLAY_CPUINFO		1
+#define CONFIG_DISPLAY_BOARDINFO	1
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ				/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128 KiB sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128 << 10))
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+/*
+ * DDR related
+ */
+#define CONFIG_OMAP3_MICRON_DDR		1	/* Micron DDR */
+#define CONFIG_SYS_CS0_SIZE		(256 * 1024 * 1024)
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3	/* UART3 on AM3517 EVM */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+#define CONFIG_USB_AM3517		1
+#define CONFIG_MUSB_HCD			1
+/*#define CONFIG_MUSB_UDC		1*/
+
+#ifdef CONFIG_USB_AM3517
+
+#ifdef CONFIG_MUSB_HCD
+#define CONFIG_CMD_USB
+
+#define CONFIG_USB_STORAGE
+#define CONGIG_CMD_STORAGE
+#define CONFIG_CMD_FAT
+
+#ifdef CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_PREBOOT "usb start"
+#endif /* CONFIG_USB_KEYBOARD */
+
+#endif /* CONFIG_MUSB_HCD */
+
+#ifdef CONFIG_MUSB_UDC
+/* USB device configuration */
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+/* Change these to suit your needs */
+#define CONFIG_USBD_VENDORID		0x0451
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Texas Instruments"
+#define CONFIG_USBD_PRODUCT_NAME	"EVM"
+#endif /* CONFIG_MUSB_UDC */
+
+#endif /* CONFIG_USB_AM3517 */
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_HARD_I2C			1
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+#define CONFIG_CMD_NET
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access */
+							/* nand at CS0 */
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of */
+							/* NAND devices */
+#define CONFIG_SYS_64BIT_VSPRINTF		/* needed for nand_util.c */
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* sz of jffs2 part */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY	10
+
+#define CONFIG_BOOTFILE		uImage
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc init; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE	1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT			"AM3517_EVM # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		32	/* max number of command */
+						/* args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0) /* default load */
+								/* address */
+
+/*
+ * AM3517 has 12 GP timers, they can be driven by the system clock
+ * (12/13/16.8/19.2/38.4MHz) or by 32KHz clock. We use 13MHz (V_SCLK).
+ * This rate is divided by a local divisor.
+ */
+#define CONFIG_SYS_TIMERBASE		OMAP34XX_GPT2
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 << 10)	/* regular stack 128 KiB */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4 << 10)	/* IRQ stack 4 KiB */
+#define CONFIG_STACKSIZE_FIQ	(4 << 10)	/* FIQ stack 4 KiB */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	(32 << 20)	/* at least 32 MiB */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors */
+						/* on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_ENV_IS_IN_NAND		1
+#define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			boot_flash_env_addr
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
+
+
+
+/*-----------------------------------------------------
+ * ethernet support for AM3517 EVM
+ *------------------------------------------------
+ */
+#if defined(CONFIG_CMD_NET)
+#define CONFIG_DRIVER_TI_EMAC
+#define CONFIG_DRIVER_TI_EMAC_USE_RMII
+#define CONFIG_MII
+#define	CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_NET_RETRY_COUNT 10
+#define CONFIG_NET_MULTI
+#endif
+
+#endif /* __CONFIG_H */
+
diff --git a/include/configs/omap3_beagle.h b/include/configs/omap3_beagle.h
index 19a5ec9..4a2b487 100644
--- a/include/configs/omap3_beagle.h
+++ b/include/configs/omap3_beagle.h
@@ -28,6 +28,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -37,6 +39,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_BEAGLE	1	/* working with BEAGLE */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>		/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -219,11 +223,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
 
@@ -310,13 +314,9 @@
 #define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
 #define CONFIG_SYS_JFFS2_NUM_BANKS	1
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
 
 #endif /* __CONFIG_H */
diff --git a/include/configs/omap3_evm.h b/include/configs/omap3_evm.h
index a5514ae..73a5c98 100644
--- a/include/configs/omap3_evm.h
+++ b/include/configs/omap3_evm.h
@@ -33,6 +33,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -42,6 +44,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_EVM	1	/* working with EVM */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>	/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -101,6 +105,44 @@
 #define CONFIG_OMAP3_MMC		1
 #define CONFIG_DOS_PARTITION		1
 
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+#define CONFIG_USB_OMAP3		1
+#define CONFIG_MUSB_HCD			1
+/* #define CONFIG_MUSB_UDC		1 */
+
+#ifdef CONFIG_USB_OMAP3
+
+#ifdef CONFIG_MUSB_HCD
+#define CONFIG_CMD_USB
+
+#define CONFIG_USB_STORAGE
+#define CONGIG_CMD_STORAGE
+#define CONFIG_CMD_FAT
+
+#ifdef CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_PREBOOT "usb start"
+#endif /* CONFIG_USB_KEYBOARD */
+
+#endif /* CONFIG_MUSB_HCD */
+
+#ifdef CONFIG_MUSB_UDC
+/* USB device configuration */
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+/* Change these to suit your needs */
+#define CONFIG_USBD_VENDORID		0x0451
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Texas Instruments"
+#define CONFIG_USBD_PRODUCT_NAME	"EVM"
+#endif /* CONFIG_MUSB_UDC */
+
+#endif /* CONFIG_USB_OMAP3 */
+
 /* commands to include */
 #include <config_cmd_default.h>
 
@@ -110,7 +152,8 @@
 
 #define CONFIG_CMD_I2C		/* I2C serial bus support	*/
 #define CONFIG_CMD_MMC		/* MMC support			*/
-#define CONFIG_CMD_ONENAND	/* ONENAND support		*/
+#undef CONFIG_CMD_ONENAND	/* ONENAND support		*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_PING
 
@@ -159,6 +202,7 @@
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"loadaddr=0x82000000\0" \
+	"usbtty=cdc_acm\0" \
 	"console=ttyS2,115200n8\0" \
 	"mmcargs=setenv bootargs console=${console} " \
 		"root=/dev/mmcblk0p2 rw " \
@@ -200,11 +244,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command */
 						/* args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
@@ -268,7 +312,13 @@
 #define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
 #define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
 
+#if defined(CONFIG_CMD_NAND)
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_ENV_IS_IN_NAND		1
+#elif defined(CONFIG_CMD_ONENAND)
 #define CONFIG_ENV_IS_IN_ONENAND	1
+#endif
 #define ONENAND_ENV_OFFSET		0x260000 /* environment starts here */
 #define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
 
@@ -291,15 +341,6 @@
 #define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
 #define CONFIG_SYS_JFFS2_NUM_BANKS	1
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
-
 /*----------------------------------------------------------------------------
  * SMSC9115 Ethernet from SMSC9118 family
  *----------------------------------------------------------------------------
@@ -322,4 +363,9 @@ extern unsigned int boot_flash_type;
 #define CONFIG_BOOTP_HOSTNAME		0x00000004
 #define CONFIG_BOOTP_BOOTPATH		0x00000010
 
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
+
 #endif /* __CONFIG_H */
diff --git a/include/configs/omap3_overo.h b/include/configs/omap3_overo.h
index ffb515d..c99b99a 100644
--- a/include/configs/omap3_overo.h
+++ b/include/configs/omap3_overo.h
@@ -20,6 +20,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -29,6 +31,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_OVERO	1	/* working with overo */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>	/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -205,11 +209,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command */
 						/* args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
@@ -295,15 +299,6 @@
 #define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
 #define CONFIG_SYS_JFFS2_NUM_BANKS	1
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
-
 #if defined(CONFIG_CMD_NET)
 /*----------------------------------------------------------------------------
  * SMSC9211 Ethernet from SMSC9118 family
@@ -317,4 +312,9 @@ extern unsigned int boot_flash_type;
 
 #endif /* (CONFIG_CMD_NET) */
 
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
+
 #endif				/* __CONFIG_H */
diff --git a/include/configs/omap3_pandora.h b/include/configs/omap3_pandora.h
index 6f21af3..f1692ef 100644
--- a/include/configs/omap3_pandora.h
+++ b/include/configs/omap3_pandora.h
@@ -23,6 +23,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -32,6 +34,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_PANDORA	1	/* working with pandora */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>	/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -197,11 +201,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command */
 						/* args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
@@ -288,13 +292,9 @@
 #define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
 #define CONFIG_SYS_JFFS2_NUM_BANKS	1
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
 
 #endif				/* __CONFIG_H */
diff --git a/include/configs/omap3_sdp3430.h b/include/configs/omap3_sdp3430.h
index 229dc5e..3d9b178 100644
--- a/include/configs/omap3_sdp3430.h
+++ b/include/configs/omap3_sdp3430.h
@@ -42,6 +42,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_3430SDP	1	/* working with SDP Rev2 */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>		/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -269,11 +271,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
 
@@ -355,15 +357,10 @@
  *  - rest for filesystem
  */
 
-/*--------------------------------------------------------------------------*/
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
 
 #endif				/* __CONFIG_H */
diff --git a/include/configs/omap3_zoom1.h b/include/configs/omap3_zoom1.h
index da4b677..7221dcb 100644
--- a/include/configs/omap3_zoom1.h
+++ b/include/configs/omap3_zoom1.h
@@ -29,6 +29,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -38,6 +40,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_ZOOM1	1	/* working with Zoom MDK Rev1 */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>		/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -205,11 +209,11 @@
 #define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #define CONFIG_SYS_PROMPT		V_PROMPT
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_MAXARGS		32	/* max number of command args */
 /* Boot Argument Buffer Size */
 #define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
 
@@ -296,13 +300,10 @@
 #define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
 #define CONFIG_SYS_JFFS2_NUM_BANKS	1
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
+
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
 
 #endif				/* __CONFIG_H */
diff --git a/include/configs/omap3_zoom2.h b/include/configs/omap3_zoom2.h
index 32cd6fd..330c52b 100644
--- a/include/configs/omap3_zoom2.h
+++ b/include/configs/omap3_zoom2.h
@@ -30,6 +30,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_ARCH_CPU_INIT	1
+
 /*
  * High Level Configuration Options
  */
@@ -39,6 +41,8 @@
 #define CONFIG_OMAP3430		1	/* which is in a 3430 */
 #define CONFIG_OMAP3_ZOOM2	1	/* working with Zoom II */
 
+#define CONFIG_SDRC		1	/* The chip has SDRC controller */
+
 #include <asm/arch/cpu.h>	/* get chip and board defs */
 #include <asm/arch/omap3.h>
 
@@ -175,10 +179,10 @@
 
 #define CONFIG_SYS_PROMPT		"OMAP3 Zoom2 # "
 #define CONFIG_SYS_LONGHELP
-#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_CBSIZE		512
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
 					 sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_MAXARGS		32
 #define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
 /* Memtest from start of memory to 31MB */
 #define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
@@ -251,13 +255,10 @@
 #define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
 #define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
 
-#ifndef __ASSEMBLY__
-extern struct gpmc *gpmc_cfg;
-extern unsigned int boot_flash_base;
-extern volatile unsigned int boot_flash_env_addr;
-extern unsigned int boot_flash_off;
-extern unsigned int boot_flash_sec;
-extern unsigned int boot_flash_type;
-#endif
+
+/*
+ * Include flash related variables
+ */
+#include <asm/arch/omap3_flash.h>
 
 #endif /* __CONFIG_H */
diff --git a/include/twl4030.h b/include/twl4030.h
index f260ecb..feaec47 100644
--- a/include/twl4030.h
+++ b/include/twl4030.h
@@ -342,21 +342,129 @@
 #define TWL4030_KEYPAD_CTRL_SOFT_NRST			(1 << 0)
 
 /* USB */
-#define TWL4030_USB_FUNC_CTRL				(0x04)
-#define TWL4030_USB_OPMODE_MASK				(3 << 3)
-#define TWL4030_USB_XCVRSELECT_MASK			(3 << 0)
-#define TWL4030_USB_IFC_CTRL				(0x07)
-#define TWL4030_USB_CARKITMODE				(1 << 2)
-#define TWL4030_USB_POWER_CTRL				(0xAC)
-#define TWL4030_USB_OTG_ENAB				(1 << 5)
-#define TWL4030_USB_PHY_PWR_CTRL			(0xFD)
-#define TWL4030_USB_PHYPWD				(1 << 0)
-#define TWL4030_USB_PHY_CLK_CTRL			(0xFE)
-#define TWL4030_USB_CLOCKGATING_EN			(1 << 2)
-#define TWL4030_USB_CLK32K_EN				(1 << 1)
-#define TWL4030_USB_REQ_PHY_DPLL_CLK			(1 << 0)
-#define TWL4030_USB_PHY_CLK_CTRL_STS			(0xFF)
-#define TWL4030_USB_PHY_DPLL_CLK			(1 << 0)
+#define TWL4030_USB_VENDOR_ID_LO			0x00
+#define TWL4030_USB_VENDOR_ID_HI			0x01
+#define TWL4030_USB_PRODUCT_ID_LO			0x02
+#define TWL4030_USB_PRODUCT_ID_HI			0x03
+#define TWL4030_USB_FUNC_CTRL				0x04
+#define TWL4030_USB_FUNC_CTRL_SET			0x05
+#define TWL4030_USB_FUNC_CTRL_CLR			0x06
+#define TWL4030_USB_IFC_CTRL				0x07
+#define TWL4030_USB_IFC_CTRL_SET			0x08
+#define TWL4030_USB_IFC_CTRL_CLR			0x09
+#define TWL4030_USB_OTG_CTRL				0x0A
+#define TWL4030_USB_OTG_CTRL_SET			0x0B
+#define TWL4030_USB_OTG_CTRL_CLR			0x0C
+#define TWL4030_USB_USB_INT_EN_RISE			0x0D
+#define TWL4030_USB_USB_INT_EN_RISE_SET			0x0E
+#define TWL4030_USB_USB_INT_EN_RISE_CLR			0x0F
+#define TWL4030_USB_USB_INT_EN_FALL			0x10
+#define TWL4030_USB_USB_INT_EN_FALL_SET			0x11
+#define TWL4030_USB_USB_INT_EN_FALL_CLR			0x12
+#define TWL4030_USB_USB_INT_STS				0x13
+#define TWL4030_USB_USB_INT_LATCH			0x14
+#define TWL4030_USB_DEBUG				0x15
+#define TWL4030_USB_SCRATCH_REG				0x16
+#define TWL4030_USB_SCRATCH_REG_SET			0x17
+#define TWL4030_USB_SCRATCH_REG_CLR			0x18
+#define TWL4030_USB_CARKIT_CTRL				0x19
+#define TWL4030_USB_CARKIT_CTRL_SET			0x1A
+#define TWL4030_USB_CARKIT_CTRL_CLR			0x1B
+#define TWL4030_USB_CARKIT_INT_DELAY			0x1C
+#define TWL4030_USB_CARKIT_INT_EN			0x1D
+#define TWL4030_USB_CARKIT_INT_EN_SET			0x1E
+#define TWL4030_USB_CARKIT_INT_EN_CLR			0x1F
+#define TWL4030_USB_CARKIT_INT_STS			0x20
+#define TWL4030_USB_CARKIT_INT_LATCH			0x21
+#define TWL4030_USB_CARKIT_PLS_CTRL			0x22
+#define TWL4030_USB_CARKIT_PLS_CTRL_SET			0x23
+#define TWL4030_USB_CARKIT_PLS_CTRL_CLR			0x24
+#define TWL4030_USB_TRANS_POS_WIDTH			0x25
+#define TWL4030_USB_TRANS_NEG_WIDTH			0x26
+#define TWL4030_USB_RCV_PLTY_RECOVERY			0x27
+#define TWL4030_USB_MCPC_CTRL				0x30
+#define TWL4030_USB_MCPC_CTRL_SET			0x31
+#define TWL4030_USB_MCPC_CTRL_CLR			0x32
+#define TWL4030_USB_MCPC_IO_CTRL			0x33
+#define TWL4030_USB_MCPC_IO_CTRL_SET			0x34
+#define TWL4030_USB_MCPC_IO_CTRL_CLR			0x35
+#define TWL4030_USB_MCPC_CTRL2				0x36
+#define TWL4030_USB_MCPC_CTRL2_SET			0x37
+#define TWL4030_USB_MCPC_CTRL2_CLR			0x38
+#define TWL4030_USB_OTHER_FUNC_CTRL			0x80
+#define TWL4030_USB_OTHER_FUNC_CTRL_SET			0x81
+#define TWL4030_USB_OTHER_FUNC_CTRL_CLR			0x82
+#define TWL4030_USB_OTHER_IFC_CTRL			0x83
+#define TWL4030_USB_OTHER_IFC_CTRL_SET			0x84
+#define TWL4030_USB_OTHER_IFC_CTRL_CLR			0x85
+#define TWL4030_USB_OTHER_INT_EN_RISE_SET		0x87
+#define TWL4030_USB_OTHER_INT_EN_RISE_CLR		0x88
+#define TWL4030_USB_OTHER_INT_EN_FALL			0x89
+#define TWL4030_USB_OTHER_INT_EN_FALL_SET		0x8A
+#define TWL4030_USB_OTHER_INT_EN_FALL_CLR		0x8B
+#define TWL4030_USB_OTHER_INT_STS			0x8C
+#define TWL4030_USB_OTHER_INT_LATCH			0x8D
+#define TWL4030_USB_ID_STATUS				0x96
+#define TWL4030_USB_CARKIT_SM_1_INT_EN			0x97
+#define TWL4030_USB_CARKIT_SM_1_INT_EN_SET		0x98
+#define TWL4030_USB_CARKIT_SM_1_INT_EN_CLR		0x99
+#define TWL4030_USB_CARKIT_SM_1_INT_STS			0x9A
+#define TWL4030_USB_CARKIT_SM_1_INT_LATCH		0x9B
+#define TWL4030_USB_CARKIT_SM_2_INT_EN			0x9C
+#define TWL4030_USB_CARKIT_SM_2_INT_EN_SET		0x9D
+#define TWL4030_USB_CARKIT_SM_2_INT_EN_CLR		0x9E
+#define TWL4030_USB_CARKIT_SM_2_INT_STS			0x9F
+#define TWL4030_USB_CARKIT_SM_2_INT_LATCH		0xA0
+#define TWL4030_USB_CARKIT_SM_CTRL			0xA1
+#define TWL4030_USB_CARKIT_SM_CTRL_SET			0xA2
+#define TWL4030_USB_CARKIT_SM_CTRL_CLR			0xA3
+#define TWL4030_USB_CARKIT_SM_CMD			0xA4
+#define TWL4030_USB_CARKIT_SM_CMD_SET			0xA5
+#define TWL4030_USB_CARKIT_SM_CMD_CLR			0xA6
+#define TWL4030_USB_CARKIT_SM_CMD_STS			0xA7
+#define TWL4030_USB_CARKIT_SM_STATUS			0xA8
+#define TWL4030_USB_CARKIT_SM_ERR_STATUS		0xAA
+#define TWL4030_USB_CARKIT_SM_CTRL_STATE		0xAB
+#define TWL4030_USB_POWER_CTRL				0xAC
+#define TWL4030_USB_POWER_CTRL_SET			0xAD
+#define TWL4030_USB_POWER_CTRL_CLR			0xAE
+#define TWL4030_USB_OTHER_IFC_CTRL2			0xAF
+#define TWL4030_USB_OTHER_IFC_CTRL2_SET			0xB0
+#define TWL4030_USB_OTHER_IFC_CTRL2_CLR			0xB1
+#define TWL4030_USB_REG_CTRL_EN				0xB2
+#define TWL4030_USB_REG_CTRL_EN_SET			0xB3
+#define TWL4030_USB_REG_CTRL_EN_CLR			0xB4
+#define TWL4030_USB_REG_CTRL_ERROR			0xB5
+#define TWL4030_USB_OTHER_FUNC_CTRL2			0xB8
+#define TWL4030_USB_OTHER_FUNC_CTRL2_SET		0xB9
+#define TWL4030_USB_OTHER_FUNC_CTRL2_CLR		0xBA
+#define TWL4030_USB_CARKIT_ANA_CTRL			0xBB
+#define TWL4030_USB_CARKIT_ANA_CTRL_SET			0xBC
+#define TWL4030_USB_CARKIT_ANA_CTRL_CLR			0xBD
+#define TWL4030_USB_VBUS_DEBOUNCE			0xC0
+#define TWL4030_USB_ID_DEBOUNCE				0xC1
+#define TWL4030_USB_TPH_DP_CON_MIN			0xC2
+#define TWL4030_USB_TPH_DP_CON_MAX			0xC3
+#define TWL4030_USB_TCR_DP_CON_MIN			0xC4
+#define TWL4030_USB_TCR_DP_CON_MAX			0xC5
+#define TWL4030_USB_TPH_DP_PD_SHORT			0xC6
+#define TWL4030_USB_TPH_CMD_DLY				0xC7
+#define TWL4030_USB_TPH_DET_RST				0xC8
+#define TWL4030_USB_TPH_AUD_BIAS			0xC9
+#define TWL4030_USB_TCR_UART_DET_MIN			0xCA
+#define TWL4030_USB_TCR_UART_DET_MAX			0xCB
+#define TWL4030_USB_TPH_ID_INT_PW			0xCD
+#define TWL4030_USB_TACC_ID_INT_WAIT			0xCE
+#define TWL4030_USB_TACC_ID_INT_PW			0xCF
+#define TWL4030_USB_TPH_CMD_WAIT			0xD0
+#define TWL4030_USB_TPH_ACK_WAIT			0xD1
+#define TWL4030_USB_TPH_DP_DISC_DET			0xD2
+#define TWL4030_USB_VBAT_TIMER				0xD3
+#define TWL4030_USB_CARKIT_4W_DEBUG			0xE0
+#define TWL4030_USB_CARKIT_5W_DEBUG			0xE1
+#define TWL4030_USB_PHY_PWR_CTRL			0xFD
+#define TWL4030_USB_PHY_CLK_CTRL			0xFE
+#define TWL4030_USB_PHY_CLK_CTRL_STS			0xFF
 
 /*
  * Convience functions to read and write from TWL4030
@@ -398,4 +506,9 @@ void twl4030_power_mmc_init(void);
  */
 void twl4030_led_init(void);
 
+/*
+ * USB
+ */
+int twl4030_usb_ulpi_init(void);
+
 #endif /* TWL4030_H */
diff --git a/include/usb.h b/include/usb.h
index 7c47098..d98d340 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -27,6 +27,7 @@
 #define _USB_H_
 
 #include <usb_defs.h>
+#include <usbdescriptors.h>
 
 /* Everything is aribtrary */
 #define USB_ALTSETTINGALLOC		4
@@ -41,13 +42,6 @@
 
 #define USB_CNTL_TIMEOUT 100 /* 100ms timeout */
 
-/* String descriptor */
-struct usb_string_descriptor {
-	unsigned char	bLength;
-	unsigned char	bDescriptorType;
-	unsigned short	wData[1];
-} __attribute__ ((packed));
-
 /* device request (setup) */
 struct devrequest {
 	unsigned char	requesttype;
@@ -63,47 +57,9 @@ struct usb_descriptor_header {
 	unsigned char	bDescriptorType;
 } __attribute__ ((packed));
 
-/* Device descriptor */
-struct usb_device_descriptor {
-	unsigned char	bLength;
-	unsigned char	bDescriptorType;
-	unsigned short	bcdUSB;
-	unsigned char	bDeviceClass;
-	unsigned char	bDeviceSubClass;
-	unsigned char	bDeviceProtocol;
-	unsigned char	bMaxPacketSize0;
-	unsigned short	idVendor;
-	unsigned short	idProduct;
-	unsigned short	bcdDevice;
-	unsigned char	iManufacturer;
-	unsigned char	iProduct;
-	unsigned char	iSerialNumber;
-	unsigned char	bNumConfigurations;
-} __attribute__ ((packed));
-
-/* Endpoint descriptor */
-struct usb_endpoint_descriptor {
-	unsigned char	bLength;
-	unsigned char	bDescriptorType;
-	unsigned char	bEndpointAddress;
-	unsigned char	bmAttributes;
-	unsigned short	wMaxPacketSize;
-	unsigned char	bInterval;
-	unsigned char	bRefresh;
-	unsigned char	bSynchAddress;
-} __attribute__ ((packed)) __attribute__ ((aligned(2)));
-
-/* Interface descriptor */
-struct usb_interface_descriptor {
-	unsigned char	bLength;
-	unsigned char	bDescriptorType;
-	unsigned char	bInterfaceNumber;
-	unsigned char	bAlternateSetting;
-	unsigned char	bNumEndpoints;
-	unsigned char	bInterfaceClass;
-	unsigned char	bInterfaceSubClass;
-	unsigned char	bInterfaceProtocol;
-	unsigned char	iInterface;
+/* Interface */
+struct usb_interface {
+	struct usb_interface_descriptor desc;
 
 	unsigned char	no_of_ep;
 	unsigned char	num_altsetting;
@@ -112,20 +68,12 @@ struct usb_interface_descriptor {
 	struct usb_endpoint_descriptor ep_desc[USB_MAXENDPOINTS];
 } __attribute__ ((packed));
 
-
-/* Configuration descriptor information.. */
-struct usb_config_descriptor {
-	unsigned char	bLength;
-	unsigned char	bDescriptorType;
-	unsigned short	wTotalLength;
-	unsigned char	bNumInterfaces;
-	unsigned char	bConfigurationValue;
-	unsigned char	iConfiguration;
-	unsigned char	bmAttributes;
-	unsigned char	MaxPower;
+/* Configuration information.. */
+struct usb_config {
+	struct usb_configuration_descriptor desc;
 
 	unsigned char	no_of_if;	/* number of interfaces */
-	struct usb_interface_descriptor if_desc[USB_MAXINTERFACES];
+	struct usb_interface if_desc[USB_MAXINTERFACES];
 } __attribute__ ((packed));
 
 enum {
@@ -156,7 +104,7 @@ struct usb_device {
 
 	int configno;			/* selected config number */
 	struct usb_device_descriptor descriptor; /* Device Descriptor */
-	struct usb_config_descriptor config; /* config descriptor */
+	struct usb_config config; /* config descriptor */
 
 	int have_langid;		/* whether string_langid is valid yet */
 	int string_langid;		/* language ID for strings */
@@ -183,7 +131,8 @@ struct usb_device {
 #if defined(CONFIG_USB_UHCI) || defined(CONFIG_USB_OHCI) || \
 	defined(CONFIG_USB_EHCI) || defined(CONFIG_USB_OHCI_NEW) || \
 	defined(CONFIG_USB_SL811HS) || defined(CONFIG_USB_ISP116X_HCD) || \
-	defined(CONFIG_USB_R8A66597_HCD) || defined(CONFIG_USB_DAVINCI)
+	defined(CONFIG_USB_R8A66597_HCD) || defined(CONFIG_USB_DAVINCI) || \
+	defined(CONFIG_USB_OMAP3) || defined(CONFIG_USB_AM3517)
 
 int usb_lowlevel_init(void);
 int usb_lowlevel_stop(void);
diff --git a/include/usb/musb_udc.h b/include/usb/musb_udc.h
new file mode 100644
index 0000000..ef37dbb
--- /dev/null
+++ b/include/usb/musb_udc.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __MUSB_UDC_H__
+#define __MUSB_UDC_H__
+
+#include <usbdevice.h>
+
+/* UDC level routines */
+void udc_irq(void);
+void udc_set_nak(int ep_num);
+void udc_unset_nak(int ep_num);
+int udc_endpoint_write(struct usb_endpoint_instance *endpoint);
+void udc_setup_ep(struct usb_device_instance *device, unsigned int id,
+		  struct usb_endpoint_instance *endpoint);
+void udc_connect(void);
+void udc_disconnect(void);
+void udc_enable(struct usb_device_instance *device);
+void udc_disable(void);
+void udc_startup_events(struct usb_device_instance *device);
+int udc_init(void);
+
+/* usbtty */
+#ifdef CONFIG_USB_TTY
+
+#define EP0_MAX_PACKET_SIZE	64 /* MUSB_EP0_FIFOSIZE */
+#define UDC_INT_ENDPOINT	1
+#define UDC_INT_PACKET_SIZE	64
+#define UDC_OUT_ENDPOINT	2
+#define UDC_OUT_PACKET_SIZE	64
+#define UDC_IN_ENDPOINT		3
+#define UDC_IN_PACKET_SIZE	64
+#define UDC_BULK_PACKET_SIZE	64
+
+#endif /* CONFIG_USB_TTY */
+
+#endif /* __MUSB_UDC_H__ */
+
diff --git a/include/usbdescriptors.h b/include/usbdescriptors.h
index a752097..2dec3b9 100644
--- a/include/usbdescriptors.h
+++ b/include/usbdescriptors.h
@@ -504,4 +504,30 @@ struct usb_class_descriptor {
 
 } __attribute__ ((packed));
 
+#ifdef DEBUG
+static inline void print_device_descriptor(struct usb_device_descriptor *d)
+{
+	serial_printf("usb device descriptor \n");
+	serial_printf("\tbLength %2.2x\n", d->bLength);
+	serial_printf("\tbDescriptorType %2.2x\n", d->bDescriptorType);
+	serial_printf("\tbcdUSB %4.4x\n", d->bcdUSB);
+	serial_printf("\tbDeviceClass %2.2x\n", d->bDeviceClass);
+	serial_printf("\tbDeviceSubClass %2.2x\n", d->bDeviceSubClass);
+	serial_printf("\tbDeviceProtocol %2.2x\n", d->bDeviceProtocol);
+	serial_printf("\tbMaxPacketSize0 %2.2x\n", d->bMaxPacketSize0);
+	serial_printf("\tidVendor %4.4x\n", d->idVendor);
+	serial_printf("\tidProduct %4.4x\n", d->idProduct);
+	serial_printf("\tbcdDevice %4.4x\n", d->bcdDevice);
+	serial_printf("\tiManufacturer %2.2x\n", d->iManufacturer);
+	serial_printf("\tiProduct %2.2x\n", d->iProduct);
+	serial_printf("\tiSerialNumber %2.2x\n", d->iSerialNumber);
+	serial_printf("\tbNumConfigurations %2.2x\n", d->bNumConfigurations);
+}
+
+#else
+
+/* stubs */
+#define print_device_descriptor(d)
+
+#endif /* DEBUG */
 #endif
diff --git a/include/usbdevice.h b/include/usbdevice.h
index 206dbbc..4171636 100644
--- a/include/usbdevice.h
+++ b/include/usbdevice.h
@@ -663,4 +663,107 @@ int usbd_endpoint_halted (struct usb_device_instance *device, int endpoint);
 void usbd_rcv_complete(struct usb_endpoint_instance *endpoint, int len, int urb_bad);
 void usbd_tx_complete (struct usb_endpoint_instance *endpoint);
 
+/* These are macros used in debugging */
+#ifdef DEBUG
+static inline void print_urb(struct urb *u)
+{
+	serial_printf("urb %p\n", (u));
+	serial_printf("\tendpoint %p\n", u->endpoint);
+	serial_printf("\tdevice %p\n", u->device);
+	serial_printf("\tbuffer %p\n", u->buffer);
+	serial_printf("\tbuffer_length %d\n", u->buffer_length);
+	serial_printf("\tactual_length %d\n", u->actual_length);
+	serial_printf("\tstatus %d\n", u->status);
+	serial_printf("\tdata %d\n", u->data);
+}
+
+static inline void print_usb_device_request(struct usb_device_request *r)
+{
+	serial_printf("usb request\n");
+	serial_printf("\tbmRequestType 0x%2.2x\n", r->bmRequestType);
+	if ((r->bmRequestType & USB_REQ_DIRECTION_MASK) == 0)
+		serial_printf("\t\tDirection : To device\n");
+	else
+		serial_printf("\t\tDirection : To host\n");
+	if ((r->bmRequestType & USB_TYPE_STANDARD) == USB_TYPE_STANDARD)
+		serial_printf("\t\tType      : Standard\n");
+	if ((r->bmRequestType & USB_TYPE_CLASS) == USB_TYPE_CLASS)
+		serial_printf("\t\tType      : Standard\n");
+	if ((r->bmRequestType & USB_TYPE_VENDOR) == USB_TYPE_VENDOR)
+		serial_printf("\t\tType      : Standard\n");
+	if ((r->bmRequestType & USB_TYPE_RESERVED) == USB_TYPE_RESERVED)
+		serial_printf("\t\tType      : Standard\n");
+	if ((r->bmRequestType & USB_REQ_RECIPIENT_MASK) ==
+	    USB_REQ_RECIPIENT_DEVICE)
+		serial_printf("\t\tRecipient : Device\n");
+	if ((r->bmRequestType & USB_REQ_RECIPIENT_MASK) ==
+	    USB_REQ_RECIPIENT_INTERFACE)
+		serial_printf("\t\tRecipient : Interface\n");
+	if ((r->bmRequestType & USB_REQ_RECIPIENT_MASK) ==
+	    USB_REQ_RECIPIENT_ENDPOINT)
+		serial_printf("\t\tRecipient : Endpoint\n");
+	if ((r->bmRequestType & USB_REQ_RECIPIENT_MASK) ==
+	    USB_REQ_RECIPIENT_OTHER)
+		serial_printf("\t\tRecipient : Other\n");
+	serial_printf("\tbRequest      0x%2.2x\n", r->bRequest);
+	if (r->bRequest == USB_REQ_GET_STATUS)
+		serial_printf("\t\tGET_STATUS\n");
+	else if (r->bRequest == USB_REQ_SET_ADDRESS)
+		serial_printf("\t\tSET_ADDRESS\n");
+	else if (r->bRequest == USB_REQ_SET_FEATURE)
+		serial_printf("\t\tSET_FEATURE\n");
+	else if (r->bRequest == USB_REQ_GET_DESCRIPTOR)
+		serial_printf("\t\tGET_DESCRIPTOR\n");
+	else if (r->bRequest == USB_REQ_SET_CONFIGURATION)
+		serial_printf("\t\tSET_CONFIGURATION\n");
+	else if (r->bRequest == USB_REQ_SET_INTERFACE)
+		serial_printf("\t\tUSB_REQ_SET_INTERFACE\n");
+	else
+		serial_printf("\tUNKNOWN %d\n", r->bRequest);
+	serial_printf("\twValue        0x%4.4x\n", r->wValue);
+	if (r->bRequest == USB_REQ_GET_DESCRIPTOR) {
+		switch (r->wValue >> 8) {
+		case USB_DESCRIPTOR_TYPE_DEVICE:
+			serial_printf("\tDEVICE\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_CONFIGURATION:
+			serial_printf("\tCONFIGURATION\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_STRING:
+			serial_printf("\tSTRING\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_INTERFACE:
+			serial_printf("\tINTERFACE\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_ENDPOINT:
+			serial_printf("\tENDPOINT\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER:
+			serial_printf("\tDEVICE_QUALIFIER\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_OTHER_SPEED_CONFIGURATION:
+			serial_printf("\tOTHER_SPEED_CONFIGURATION\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_INTERFACE_POWER:
+			serial_printf("\tINTERFACE_POWER\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_HID:
+			serial_printf("\tHID\n");
+			break;
+		case USB_DESCRIPTOR_TYPE_REPORT:
+			serial_printf("\tREPORT\n");
+			break;
+		default:
+			serial_printf("\tUNKNOWN TYPE\n");
+			break;
+		}
+	}
+	serial_printf("\twIndex        0x%4.4x\n", r->wIndex);
+	serial_printf("\twLength       0x%4.4x\n", r->wLength);
+}
+#else
+/* stubs */
+#define print_urb(u)
+#define print_usb_device_request(r)
+#endif /* DEBUG */
 #endif
diff --git a/lib_arm/board.c b/lib_arm/board.c
index e148739..4764017 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -296,6 +296,7 @@ void start_armboot (void)
 	mem_malloc_init (_armboot_start - CONFIG_SYS_MALLOC_LEN,
 			CONFIG_SYS_MALLOC_LEN);
 
+	register_diagnostics();
 #ifndef CONFIG_SYS_NO_FLASH
 	/* configure available FLASH banks */
 	display_flash_config (flash_init ());
diff --git a/net/tftp.c b/net/tftp.c
index cc60a3b..b46b808 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -90,12 +90,7 @@ extern flash_info_t flash_info[];
  * almost-MTU block sizes.  At least try... fall back to 512 if need be.
  * (but those using CONFIG_IP_DEFRAG may want to set a larger block in cfg file)
  */
-#ifdef CONFIG_TFTP_BLOCKSIZE
-#define TFTP_MTU_BLOCKSIZE CONFIG_TFTP_BLOCKSIZE
-#else
-#define TFTP_MTU_BLOCKSIZE 1468
-#endif
-
+#define TFTP_MTU_BLOCKSIZE 512
 static unsigned short TftpBlkSize=TFTP_BLOCK_SIZE;
 static unsigned short TftpBlkSizeOption=TFTP_MTU_BLOCKSIZE;
 
-- 
1.7.1

