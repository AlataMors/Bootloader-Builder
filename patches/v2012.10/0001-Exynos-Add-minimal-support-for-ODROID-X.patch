From 7a7432322f065d944d98c14c5b034858d7ab24cf Mon Sep 17 00:00:00 2001
From: Hakjoo Kim <ruppi.kim@hardkernel.com>
Date: Wed, 8 Aug 2012 14:38:12 +0900
Subject: [PATCH] Exynos: Add minimal support for ODROID-X.

  This patch adds the minimal support for ODROID-X. The platform and machine
  specific headers and sources updated for ODROID-X.

  Exynos4412 is Samsung's SOC based on ARM Cortex-A9 SMP architecture.
  It's a dual core SOC with GIC used for interrupt handling and SCU for cache coherency.
---
 MAINTAINERS                                      |    4 +
 arch/arm/cpu/armv7/exynos/clock.c                |   89 ++-
 arch/arm/cpu/armv7/exynos/pinmux.c               |  305 +++++++++++
 arch/arm/cpu/armv7/exynos/power.c                |   14 +
 arch/arm/include/asm/arch-exynos/clock.h         |  178 +++++-
 arch/arm/include/asm/arch-exynos/cpu.h           |    4 +-
 arch/arm/include/asm/arch-exynos/power.h         |    4 +
 arch/arm/include/asm/mach-types.h                |   13 +
 board/hardkernel/odroidx/Makefile                |   65 +++
 board/hardkernel/odroidx/lowlevel_init.S         |  498 +++++++++++++++++
 board/hardkernel/odroidx/mem_setup.S             |  297 ++++++++++
 board/hardkernel/odroidx/odroidx.c               |  195 +++++++
 board/hardkernel/odroidx/odroidx_setup.h         |  628 ++++++++++++++++++++++
 board/hardkernel/odroidx/spl_boot.c              |   67 +++
 board/hardkernel/odroidx/tools/mkodroidx_image.c |  117 ++++
 boards.cfg                                       |    2 +
 drivers/i2c/s3c24x0_i2c.c                        |   12 +-
 drivers/misc/Makefile                            |    1 +
 drivers/misc/pmic_max77686.c                     |   42 ++
 include/configs/odroidx.h                        |  224 ++++++++
 include/max77686_pmic.h                          |  158 ++++++
 include/sdhci.h                                  |    6 +-
 22 files changed, 2910 insertions(+), 13 deletions(-)
 create mode 100644 board/hardkernel/odroidx/Makefile
 create mode 100644 board/hardkernel/odroidx/lowlevel_init.S
 create mode 100644 board/hardkernel/odroidx/mem_setup.S
 create mode 100644 board/hardkernel/odroidx/odroidx.c
 create mode 100644 board/hardkernel/odroidx/odroidx_setup.h
 create mode 100644 board/hardkernel/odroidx/spl_boot.c
 create mode 100644 board/hardkernel/odroidx/tools/mkodroidx_image.c
 create mode 100644 drivers/misc/pmic_max77686.c
 create mode 100644 include/configs/odroidx.h
 create mode 100644 include/max77686_pmic.h

diff --git a/MAINTAINERS b/MAINTAINERS
index c5a6f2f..4b22936 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -719,6 +719,10 @@ Heungjun Kim <riverful.kim@samsung.com>
 
 	trats			ARM ARMV7 (EXYNOS4210 SoC)
 
+Hakjoo Kim <ruppi.kim@hardkernel.com>
+
+	odroidx			ARM ARMV7 (EXYNOS4412 SoC)
+
 Torsten Koschorrek <koschorrek@synertronixx.de>
 	scb9328		ARM920T (i.MXL)
 
diff --git a/arch/arm/cpu/armv7/exynos/clock.c b/arch/arm/cpu/armv7/exynos/clock.c
index f7829b2..f042934 100644
--- a/arch/arm/cpu/armv7/exynos/clock.c
+++ b/arch/arm/cpu/armv7/exynos/clock.c
@@ -293,6 +293,8 @@ static unsigned long exynos4_get_uart_clk(int dev_index)
 		sclk = get_pll_clk(EPLL);
 	else if (sel == 0x8)
 		sclk = get_pll_clk(VPLL);
+    else if (sel == 0x1)
+		sclk = CONFIG_SYS_CLK_FREQ;
 	else
 		return 0;
 
@@ -427,7 +429,11 @@ static unsigned long exynos4_get_lcd_clk(void)
 	 * CLK_SRC_LCD0
 	 * FIMD0_SEL [3:0]
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	sel = readl(&clk->src_lcd);
+#else
 	sel = readl(&clk->src_lcd0);
+#endif
 	sel = sel & 0xf;
 
 	/*
@@ -448,7 +454,11 @@ static unsigned long exynos4_get_lcd_clk(void)
 	 * CLK_DIV_LCD0
 	 * FIMD0_RATIO [3:0]
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	ratio = readl(&clk->div_lcd);
+#else
 	ratio = readl(&clk->div_lcd0);
+#endif
 	ratio = ratio & 0xf;
 
 	pclk = sclk / (ratio + 1);
@@ -484,10 +494,18 @@ void exynos4_set_lcd_clk(void)
 	 * MIPI0_SEL		[12:15]
 	 * set lcd0 src clock 0x6: SCLK_MPLL
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	cfg = readl(&clk->src_lcd);
+#else
 	cfg = readl(&clk->src_lcd0);
+#endif
 	cfg &= ~(0xf);
 	cfg |= 0x6;
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->src_lcd);
+#else
 	writel(cfg, &clk->src_lcd0);
+#endif
 
 	/*
 	 * CLK_GATE_IP_LCD0
@@ -499,9 +517,17 @@ void exynos4_set_lcd_clk(void)
 	 * CLK_PPMULCD0		[5]
 	 * Gating all clocks for FIMD0
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	cfg = readl(&clk->gate_ip_lcd);
+#else
 	cfg = readl(&clk->gate_ip_lcd0);
+#endif
 	cfg |= 1 << 0;
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->gate_ip_lcd);
+#else
 	writel(cfg, &clk->gate_ip_lcd0);
+#endif
 
 	/*
 	 * CLK_DIV_LCD0
@@ -515,7 +541,11 @@ void exynos4_set_lcd_clk(void)
 	 */
 	cfg &= ~(0xf);
 	cfg |= 0x1;
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->div_lcd);
+#else
 	writel(cfg, &clk->div_lcd0);
+#endif
 }
 
 void exynos4_set_mipi_clk(void)
@@ -532,10 +562,18 @@ void exynos4_set_mipi_clk(void)
 	 * MIPI0_SEL		[12:15]
 	 * set mipi0 src clock 0x6: SCLK_MPLL
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	cfg = readl(&clk->src_lcd);
+#else
 	cfg = readl(&clk->src_lcd0);
+#endif
 	cfg &= ~(0xf << 12);
 	cfg |= (0x6 << 12);
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->src_lcd);
+#else
 	writel(cfg, &clk->src_lcd0);
+#endif
 
 	/*
 	 * CLK_SRC_MASK_LCD0
@@ -545,9 +583,17 @@ void exynos4_set_mipi_clk(void)
 	 * MIPI0_MASK		[12]
 	 * set src mask mipi0 0x1: Unmask
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	cfg = readl(&clk->src_mask_lcd);
+#else
 	cfg = readl(&clk->src_mask_lcd0);
+#endif
 	cfg |= (0x1 << 12);
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->src_mask_lcd);
+#else
 	writel(cfg, &clk->src_mask_lcd0);
+#endif
 
 	/*
 	 * CLK_GATE_IP_LCD0
@@ -559,9 +605,17 @@ void exynos4_set_mipi_clk(void)
 	 * CLK_PPMULCD0		[5]
 	 * Gating all clocks for MIPI0
 	 */
+#if defined(CONFIG_EXYNOS4412)
+	cfg = readl(&clk->gate_ip_lcd);
+#else
 	cfg = readl(&clk->gate_ip_lcd0);
+#endif
 	cfg |= 1 << 3;
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->gate_ip_lcd);
+#else
 	writel(cfg, &clk->gate_ip_lcd0);
+#endif
 
 	/*
 	 * CLK_DIV_LCD0
@@ -575,7 +629,11 @@ void exynos4_set_mipi_clk(void)
 	 */
 	cfg &= ~(0xf << 16);
 	cfg |= (0x1 << 16);
+#if defined(CONFIG_EXYNOS4412)
+	writel(cfg, &clk->div_lcd);
+#else
 	writel(cfg, &clk->div_lcd0);
+#endif
 }
 
 /*
@@ -601,6 +659,31 @@ static unsigned long exynos5_get_i2c_clk(void)
 	return aclk_66;
 }
 
+/*
+ * I2C
+ *
+ * exynos5: obtaining the I2C clock
+ */
+static unsigned long exynos4_get_i2c_clk(void)
+{
+#if 0
+	struct exynos4_clock *clk =
+		(struct exynos4_clock *)samsung_get_base_clock();
+	unsigned long aclk_66, aclk_66_pre, sclk;
+	unsigned int ratio;
+
+	sclk = get_pll_clk(MPLL);
+
+	ratio = (readl(&clk->div_top1)) >> 24;
+	ratio &= 0x7;
+	aclk_66_pre = sclk / (ratio + 1);
+	ratio = readl(&clk->div_top0);
+	ratio &= 0x7;
+	aclk_66 = aclk_66_pre / (ratio + 1);
+	return aclk_66;
+#endif
+}
+
 unsigned long get_pll_clk(int pllreg)
 {
 	if (cpu_is_exynos5())
@@ -619,9 +702,11 @@ unsigned long get_arm_clk(void)
 
 unsigned long get_i2c_clk(void)
 {
-	if (cpu_is_exynos5()) {
+	if (cpu_is_exynos5())
 		return exynos5_get_i2c_clk();
-	} else {
+    else if (cpu_is_exynos4())
+		return exynos4_get_i2c_clk();
+    else {
 		debug("I2C clock is not set for this CPU\n");
 		return 0;
 	}
diff --git a/arch/arm/cpu/armv7/exynos/pinmux.c b/arch/arm/cpu/armv7/exynos/pinmux.c
index d28f055..37d7c20 100644
--- a/arch/arm/cpu/armv7/exynos/pinmux.c
+++ b/arch/arm/cpu/armv7/exynos/pinmux.c
@@ -26,6 +26,309 @@
 #include <asm/arch/pinmux.h>
 #include <asm/arch/sromc.h>
 
+static void exynos4_uart_config(int peripheral)
+{
+	struct exynos4_gpio_part1 *gpio1 =
+		(struct exynos4_gpio_part1 *) samsung_get_base_gpio_part1();
+	struct s5p_gpio_bank *bank;
+	int i, start, count;
+
+	switch (peripheral) {
+	case PERIPH_ID_UART0:
+		bank = &gpio1->a0;
+		start = 0;
+		count = 4;
+		break;
+	case PERIPH_ID_UART1:
+		bank = &gpio1->a0;
+		start = 4;
+		count = 4;
+		break;
+	case PERIPH_ID_UART2:
+		bank = &gpio1->a1;
+		start = 0;
+		count = 4;
+		break;
+	case PERIPH_ID_UART3:
+		bank = &gpio1->a1;
+		start = 4;
+		count = 2;
+		break;
+	}
+
+	for (i = start; i < start + count; i++) {
+		s5p_gpio_set_pull(bank, i, GPIO_PULL_NONE);
+		s5p_gpio_cfg_pin(bank, i, GPIO_FUNC(0x2));
+	}
+}
+
+static int exynos4_mmc_config(int peripheral, int flags)
+{
+#if defined(CONFIG_EXYNOS4412)
+	struct exynos4_gpio_part2 *gpio2 =
+		(struct exynos4_gpio_part2 *) samsung_get_base_gpio_part2();
+	struct s5p_gpio_bank *bank, *bank_ext;
+	int i, start, count, pin, pin_ext, drv;
+#else
+	struct exynos4_gpio_part1 *gpio1 =
+		(struct exynos4_gpio_part1 *) samsung_get_base_gpio_part1();
+	struct s5p_gpio_bank *bank, *bank_ext;
+	int i;
+#endif
+	switch (peripheral) {
+#if defined(CONFIG_EXYNOS4412)
+	case PERIPH_ID_SDMMC0:
+		bank = &gpio2->k0;
+		bank_ext = &gpio2->k1;
+		pin = GPIO_FUNC(3);
+		pin_ext = GPIO_FUNC(4);
+		break;
+	case PERIPH_ID_SDMMC1:
+		bank = &gpio2->k1;
+		bank_ext = NULL;
+		break;
+	case PERIPH_ID_SDMMC2:
+		bank = &gpio2->k2;
+		bank_ext = NULL;
+		pin = GPIO_FUNC(2);
+		break;
+	case PERIPH_ID_SDMMC3:
+		bank = &gpio2->k3;
+		bank_ext = NULL;
+		break;
+#else
+	case PERIPH_ID_SDMMC0:
+		bank = &gpio1->c0;
+		bank_ext = &gpio1->c1;
+		break;
+	case PERIPH_ID_SDMMC1:
+		bank = &gpio1->c1;
+		bank_ext = NULL;
+		break;
+	case PERIPH_ID_SDMMC2:
+		bank = &gpio1->c2;
+		bank_ext = &gpio1->c3;
+		break;
+	case PERIPH_ID_SDMMC3:
+		bank = &gpio1->c3;
+		bank_ext = NULL;
+		break;
+#endif
+	}
+	if ((flags & PINMUX_FLAG_8BIT_MODE) && !bank_ext) {
+		debug("SDMMC device %d does not support 8bit mode",
+				peripheral);
+		return -1;
+	}
+	if (flags & PINMUX_FLAG_8BIT_MODE) {
+		for (i = 3; i <= 6; i++) {
+			s5p_gpio_cfg_pin(bank_ext, i, pin_ext);
+			s5p_gpio_set_pull(bank_ext, i, GPIO_PULL_UP);
+			s5p_gpio_set_drv(bank_ext, i, GPIO_DRV_4X);
+		}
+			s5p_gpio_set_pull(bank_ext, 2, GPIO_PULL_UP);
+	}
+	for (i = 0; i < 2; i++) {
+		s5p_gpio_cfg_pin(bank, i, pin);
+		s5p_gpio_set_pull(bank, i, GPIO_PULL_NONE);
+		s5p_gpio_set_drv(bank, i, GPIO_DRV_4X);
+	}
+	for (i = 2; i <= 6; i++) {
+		s5p_gpio_cfg_pin(bank, i, pin);
+		s5p_gpio_set_pull(bank, i, GPIO_PULL_UP);
+		s5p_gpio_set_drv(bank, i, GPIO_DRV_4X);
+	}
+
+	return 0;
+}
+
+static void exynos4_sromc_config(int flags)
+{
+	struct exynos4_gpio_part1 *gpio1 =
+		(struct exynos4_gpio_part1 *) samsung_get_base_gpio_part1();
+	int i;
+
+#if 0
+	/*
+	 * SROM:CS1 and EBI
+	 *
+	 * GPY0[0]	SROM_CSn[0]
+	 * GPY0[1]	SROM_CSn[1](2)
+	 * GPY0[2]	SROM_CSn[2]
+	 * GPY0[3]	SROM_CSn[3]
+	 * GPY0[4]	EBI_OEn(2)
+	 * GPY0[5]	EBI_EEn(2)
+	 *
+	 * GPY1[0]	EBI_BEn[0](2)
+	 * GPY1[1]	EBI_BEn[1](2)
+	 * GPY1[2]	SROM_WAIT(2)
+	 * GPY1[3]	EBI_DATA_RDn(2)
+	 */
+	s5p_gpio_cfg_pin(&gpio1->y0, (flags & PINMUX_FLAG_BANK),
+				GPIO_FUNC(2));
+	s5p_gpio_cfg_pin(&gpio1->y0, 4, GPIO_FUNC(2));
+	s5p_gpio_cfg_pin(&gpio1->y0, 5, GPIO_FUNC(2));
+
+	for (i = 0; i < 4; i++)
+		s5p_gpio_cfg_pin(&gpio1->y1, i, GPIO_FUNC(2));
+
+	/*
+	 * EBI: 8 Addrss Lines
+	 *
+	 * GPY3[0]	EBI_ADDR[0](2)
+	 * GPY3[1]	EBI_ADDR[1](2)
+	 * GPY3[2]	EBI_ADDR[2](2)
+	 * GPY3[3]	EBI_ADDR[3](2)
+	 * GPY3[4]	EBI_ADDR[4](2)
+	 * GPY3[5]	EBI_ADDR[5](2)
+	 * GPY3[6]	EBI_ADDR[6](2)
+	 * GPY3[7]	EBI_ADDR[7](2)
+	 *
+	 * EBI: 16 Data Lines
+	 *
+	 * GPY5[0]	EBI_DATA[0](2)
+	 * GPY5[1]	EBI_DATA[1](2)
+	 * GPY5[2]	EBI_DATA[2](2)
+	 * GPY5[3]	EBI_DATA[3](2)
+	 * GPY5[4]	EBI_DATA[4](2)
+	 * GPY5[5]	EBI_DATA[5](2)
+	 * GPY5[6]	EBI_DATA[6](2)
+	 * GPY5[7]	EBI_DATA[7](2)
+	 *
+	 * GPY6[0]	EBI_DATA[8](2)
+	 * GPY6[1]	EBI_DATA[9](2)
+	 * GPY6[2]	EBI_DATA[10](2)
+	 * GPY6[3]	EBI_DATA[11](2)
+	 * GPY6[4]	EBI_DATA[12](2)
+	 * GPY6[5]	EBI_DATA[13](2)
+	 * GPY6[6]	EBI_DATA[14](2)
+	 * GPY6[7]	EBI_DATA[15](2)
+	 */
+	for (i = 0; i < 8; i++) {
+		s5p_gpio_cfg_pin(&gpio1->y3, i, GPIO_FUNC(2));
+		s5p_gpio_set_pull(&gpio1->y3, i, GPIO_PULL_UP);
+
+		s5p_gpio_cfg_pin(&gpio1->y5, i, GPIO_FUNC(2));
+		s5p_gpio_set_pull(&gpio1->y5, i, GPIO_PULL_UP);
+
+		s5p_gpio_cfg_pin(&gpio1->y6, i, GPIO_FUNC(2));
+		s5p_gpio_set_pull(&gpio1->y6, i, GPIO_PULL_UP);
+	}
+#endif
+}
+
+static void exynos4_i2c_config(int peripheral, int flags)
+{
+	struct exynos4_gpio_part1 *gpio1 =
+		(struct exynos4_gpio_part1 *) samsung_get_base_gpio_part1();
+
+	switch (peripheral) {
+#if defined(CONFIG_EXYNOS4412)
+	case PERIPH_ID_I2C0:
+		s5p_gpio_cfg_pin(&gpio1->d1, 0, GPIO_FUNC(0x2));
+		s5p_gpio_cfg_pin(&gpio1->d1, 1, GPIO_FUNC(0x2));
+		break;
+	case PERIPH_ID_I2C1:
+		s5p_gpio_cfg_pin(&gpio1->d1, 2, GPIO_FUNC(0x2));
+		s5p_gpio_cfg_pin(&gpio1->d1, 3, GPIO_FUNC(0x2));
+		break;
+	case PERIPH_ID_I2C2:
+		s5p_gpio_cfg_pin(&gpio1->a0, 6, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a0, 7, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C3:
+		s5p_gpio_cfg_pin(&gpio1->a1, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a1, 3, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C4:
+		s5p_gpio_cfg_pin(&gpio1->b, 0, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->b, 1, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C5:
+		s5p_gpio_cfg_pin(&gpio1->b, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->b, 3, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C6:
+		s5p_gpio_cfg_pin(&gpio1->c1, 3, GPIO_FUNC(0x4));
+		s5p_gpio_cfg_pin(&gpio1->c1, 4, GPIO_FUNC(0x4));
+		break;
+	case PERIPH_ID_I2C7:
+		s5p_gpio_cfg_pin(&gpio1->d0, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->d0, 3, GPIO_FUNC(0x3));
+		break;
+#else
+	switch (peripheral) {
+	case PERIPH_ID_I2C0:
+		s5p_gpio_cfg_pin(&gpio1->b3, 0, GPIO_FUNC(0x2));
+		s5p_gpio_cfg_pin(&gpio1->b3, 1, GPIO_FUNC(0x2));
+		break;
+	case PERIPH_ID_I2C1:
+		s5p_gpio_cfg_pin(&gpio1->b3, 2, GPIO_FUNC(0x2));
+		s5p_gpio_cfg_pin(&gpio1->b3, 3, GPIO_FUNC(0x2));
+		break;
+	case PERIPH_ID_I2C2:
+		s5p_gpio_cfg_pin(&gpio1->a0, 6, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a0, 7, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C3:
+		s5p_gpio_cfg_pin(&gpio1->a1, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a1, 3, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C4:
+		s5p_gpio_cfg_pin(&gpio1->a2, 0, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a2, 1, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C5:
+		s5p_gpio_cfg_pin(&gpio1->a2, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->a2, 3, GPIO_FUNC(0x3));
+		break;
+	case PERIPH_ID_I2C6:
+		s5p_gpio_cfg_pin(&gpio1->b1, 3, GPIO_FUNC(0x4));
+		s5p_gpio_cfg_pin(&gpio1->b1, 4, GPIO_FUNC(0x4));
+		break;
+	case PERIPH_ID_I2C7:
+		s5p_gpio_cfg_pin(&gpio1->b2, 2, GPIO_FUNC(0x3));
+		s5p_gpio_cfg_pin(&gpio1->b2, 3, GPIO_FUNC(0x3));
+		break;
+#endif
+	}
+}
+
+static int exynos4_pinmux_config(int peripheral, int flags)
+{
+	switch (peripheral) {
+	case PERIPH_ID_UART0:
+	case PERIPH_ID_UART1:
+	case PERIPH_ID_UART2:
+	case PERIPH_ID_UART3:
+		exynos4_uart_config(peripheral);
+		break;
+	case PERIPH_ID_SDMMC0:
+	case PERIPH_ID_SDMMC1:
+	case PERIPH_ID_SDMMC2:
+	case PERIPH_ID_SDMMC3:
+		return exynos4_mmc_config(peripheral, flags);
+	case PERIPH_ID_SROMC:
+		exynos4_sromc_config(flags);
+		break;
+	case PERIPH_ID_I2C0:
+	case PERIPH_ID_I2C1:
+	case PERIPH_ID_I2C2:
+	case PERIPH_ID_I2C3:
+	case PERIPH_ID_I2C4:
+	case PERIPH_ID_I2C5:
+	case PERIPH_ID_I2C6:
+	case PERIPH_ID_I2C7:
+		exynos4_i2c_config(peripheral, flags);
+		break;
+	default:
+		debug("%s: invalid peripheral %d", __func__, peripheral);
+		return -1;
+	}
+
+    return 0;
+}
+
 static void exynos5_uart_config(int peripheral)
 {
 	struct exynos5_gpio_part1 *gpio1 =
@@ -265,6 +568,8 @@ int exynos_pinmux_config(int peripheral, int flags)
 {
 	if (cpu_is_exynos5())
 		return exynos5_pinmux_config(peripheral, flags);
+    else if (cpu_is_exynos4())
+		return exynos4_pinmux_config(peripheral, flags);
 	else {
 		debug("pinmux functionality not supported\n");
 		return -1;
diff --git a/arch/arm/cpu/armv7/exynos/power.c b/arch/arm/cpu/armv7/exynos/power.c
index 4116781..4f97fa7 100644
--- a/arch/arm/cpu/armv7/exynos/power.c
+++ b/arch/arm/cpu/armv7/exynos/power.c
@@ -25,6 +25,14 @@
 #include <asm/io.h>
 #include <asm/arch/power.h>
 
+static void exynos4_ps_hold_setup(void)
+{
+    struct exynos4_power *power=
+            (struct exynos4_power *)samsung_get_base_power();
+
+    setbits_le32(&power->ps_hold_control, POWER_PS_HOLD_CONTROL_DATA_HIGH);
+}
+
 static void exynos4_mipi_phy_control(unsigned int dev_index,
 					unsigned int enable)
 {
@@ -74,3 +82,9 @@ void set_usbhost_phy_ctrl(unsigned int enable)
 	if (cpu_is_exynos5())
 		exynos5_set_usbhost_phy_ctrl(enable);
 }
+
+void ps_hold_setup(void)
+{
+	if (cpu_is_exynos4())
+        exynos4_ps_hold_setup();
+}
diff --git a/arch/arm/include/asm/arch-exynos/clock.h b/arch/arm/include/asm/arch-exynos/clock.h
index 50da958..aaa24b6 100644
--- a/arch/arm/include/asm/arch-exynos/clock.h
+++ b/arch/arm/include/asm/arch-exynos/clock.h
@@ -34,7 +34,15 @@ struct exynos4_clock {
 	unsigned int	div_stat_leftbus;
 	unsigned char	res6[0x1fc];
 	unsigned int	gate_ip_leftbus;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res1[0x12c];
+	unsigned int	gate_ip_image;
+#endif
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res7[0xcc];
+#else
 	unsigned char	res7[0x1fc];
+#endif
 	unsigned int	clkout_leftbus;
 	unsigned int	clkout_leftbus_div_stat;
 	unsigned char	res8[0x37f8];
@@ -47,7 +55,13 @@ struct exynos4_clock {
 	unsigned int	div_stat_rightbus;
 	unsigned char	res12[0x1fc];
 	unsigned int	gate_ip_rightbus;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res2[0x15c];
+	unsigned int	gate_ip_perir;
+	unsigned char	res13[0x9c];
+#else
 	unsigned char	res13[0x1fc];
+#endif
 	unsigned int	clkout_rightbus;
 	unsigned int	clkout_rightbus_div_stat;
 	unsigned char	res14[0x3608];
@@ -57,54 +71,107 @@ struct exynos4_clock {
 	unsigned char	res16[0xec];
 	unsigned int	epll_con0;
 	unsigned int	epll_con1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	epll_con2;
+	unsigned char	res17[0x4];
+#else
 	unsigned char	res17[0x8];
+#endif
 	unsigned int	vpll_con0;
 	unsigned int	vpll_con1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	vpll_con2;
+	unsigned char	res18[0xe4];
+#else
 	unsigned char	res18[0xe8];
+#endif
 	unsigned int	src_top0;
 	unsigned int	src_top1;
 	unsigned char	res19[0x8];
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	src_cam0;
+#else
 	unsigned int	src_cam;
+#endif
 	unsigned int	src_tv;
 	unsigned int	src_mfc;
 	unsigned int	src_g3d;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res3[0x4];
+	unsigned int	src_lcd;
+	unsigned int	src_isp;
+#else
 	unsigned int	src_image;
 	unsigned int	src_lcd0;
 	unsigned int	src_lcd1;
+#endif
 	unsigned int	src_maudio;
 	unsigned int	src_fsys;
 	unsigned char	res20[0xc];
 	unsigned int	src_peril0;
 	unsigned int	src_peril1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	src_cam1;
+	unsigned char	res21[0xc4];
+	unsigned int	src_mask_cam0;
+#else
 	unsigned char	res21[0xb8];
 	unsigned int	src_mask_top;
 	unsigned char	res22[0xc];
 	unsigned int	src_mask_cam;
+#endif
 	unsigned int	src_mask_tv;
 	unsigned char	res23[0xc];
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	src_mask_lcd;
+	unsigned int	src_mask_isp;
+#else
 	unsigned int	src_mask_lcd0;
 	unsigned int	src_mask_lcd1;
+#endif
 	unsigned int	src_mask_maudio;
 	unsigned int	src_mask_fsys;
 	unsigned char	res24[0xc];
 	unsigned int	src_mask_peril0;
 	unsigned int	src_mask_peril1;
 	unsigned char	res25[0xb8];
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	mux_stat_top0;
+	unsigned int	mux_stat_top1;
+	unsigned char	res26[0x10];
+#else
 	unsigned int	mux_stat_top;
 	unsigned char	res26[0x14];
+#endif
 	unsigned int	mux_stat_mfc;
 	unsigned int	mux_stat_g3d;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res4[0x28];
+	unsigned int	mux_stat_cam1;
+	unsigned char	res27[0xb4];
+#else
 	unsigned int	mux_stat_image;
 	unsigned char	res27[0xdc];
+#endif
 	unsigned int	div_top;
 	unsigned char	res28[0xc];
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	div_cam0;
+#else
 	unsigned int	div_cam;
+#endif
 	unsigned int	div_tv;
 	unsigned int	div_mfc;
 	unsigned int	div_g3d;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res5[0x4];
+	unsigned int	div_lcd;
+	unsigned int	div_isp;
+#else
 	unsigned int	div_image;
 	unsigned int	div_lcd0;
 	unsigned int	div_lcd1;
+#endif
 	unsigned int	div_maudio;
 	unsigned int	div_fsys0;
 	unsigned int	div_fsys1;
@@ -116,18 +183,34 @@ struct exynos4_clock {
 	unsigned int	div_peril3;
 	unsigned int	div_peril4;
 	unsigned int	div_peril5;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	div_cam1;
+	unsigned char	res29[0x14];
+#else
 	unsigned char	res29[0x18];
+#endif
 	unsigned int	div2_ratio;
 	unsigned char	res30[0x8c];
 	unsigned int	div_stat_top;
 	unsigned char	res31[0xc];
+
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	div_stat_cam0;
+#else
 	unsigned int	div_stat_cam;
+#endif
 	unsigned int	div_stat_tv;
 	unsigned int	div_stat_mfc;
 	unsigned int	div_stat_g3d;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res6[0x4];
+	unsigned int	div_stat_lcd;
+	unsigned int	div_stat_isp;
+#else
 	unsigned int	div_stat_image;
 	unsigned int	div_stat_lcd0;
 	unsigned int	div_stat_lcd1;
+#endif
 	unsigned int	div_stat_maudio;
 	unsigned int	div_stat_fsys0;
 	unsigned int	div_stat_fsys1;
@@ -139,29 +222,61 @@ struct exynos4_clock {
 	unsigned int	div_stat_peril3;
 	unsigned int	div_stat_peril4;
 	unsigned int	div_stat_peril5;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	div_stat_cam1;
+	unsigned char	res32[0x14];
+#else
 	unsigned char	res32[0x18];
+#endif
 	unsigned int	div2_stat;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res7[0xc0];
+	unsigned int	gate_bus_fsys1;
+	unsigned char	res33[0x1d8];
+#else
 	unsigned char	res33[0x29c];
+#endif
 	unsigned int	gate_ip_cam;
 	unsigned int	gate_ip_tv;
 	unsigned int	gate_ip_mfc;
 	unsigned int	gate_ip_g3d;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res34[0x4];
+	unsigned int	gate_ip_lcd;
+	unsigned int	gate_ip_isp;
+#else
 	unsigned int	gate_ip_image;
 	unsigned int	gate_ip_lcd0;
 	unsigned int	gate_ip_lcd1;
 	unsigned char	res34[0x4];
+#endif
 	unsigned int	gate_ip_fsys;
-	unsigned char	res35[0x8];
+	unsigned char	res35[0xC];
 	unsigned int	gate_ip_gps;
 	unsigned int	gate_ip_peril;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res36[0x1c];
+#else
 	unsigned char	res36[0xc];
 	unsigned int	gate_ip_perir;
-	unsigned char	res37[0xc];
+	unsigned char	res37[0x0c];
+#endif
 	unsigned int	gate_block;
 	unsigned char	res38[0x8c];
 	unsigned int	clkout_cmu_top;
 	unsigned int	clkout_cmu_top_div_stat;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res39[0x3600];
+#else
 	unsigned char	res39[0x37f8];
+#endif
+#if defined(CONFIG_EXYNOS4412)
+	unsigned int	mpll_lock;
+	unsigned char	exynos4412res8[0xfc];
+	unsigned int	mpll_con0;
+	unsigned int	mpll_con1;
+	unsigned char	exynos4412res9[0xf0];
+#endif
 	unsigned int	src_dmc;
 	unsigned char	res40[0xfc];
 	unsigned int	src_mask_dmc;
@@ -173,9 +288,19 @@ struct exynos4_clock {
 	unsigned char	res43[0xf8];
 	unsigned int	div_stat_dmc0;
 	unsigned int	div_stat_dmc1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res44[0xf8];
+	unsigned int	div_gate_bus_dmc0;
+	unsigned int	div_gate_bus_dmc1;
+	unsigned char	res45[0x1f8];
+	unsigned int	gate_ip_dmc0;
+	unsigned int	gate_ip_dmc1;
+	unsigned char	exynos4412res10[0xf8];
+#else
 	unsigned char	res44[0x2f8];
 	unsigned int	gate_ip_dmc;
 	unsigned char	res45[0xfc];
+#endif
 	unsigned int	clkout_cmu_dmc;
 	unsigned int	clkout_cmu_dmc_div_stat;
 	unsigned char	res46[0x5f8];
@@ -193,16 +318,33 @@ struct exynos4_clock {
 	unsigned char	res50[0x18];
 	unsigned int	dvsemclk_en;
 	unsigned int	maxperf;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	exynos4412res11[0xc];
+	unsigned int	dmc_pause_ctrl;
+	unsigned int	ddrphy_lock_ctrl;
+	unsigned int	c2c_state;
+	unsigned char	res51[0x2f60];
+#else
 	unsigned char	res51[0x2f78];
+#endif
 	unsigned int	apll_lock;
+
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res52[0xfc];
+#else
 	unsigned char	res52[0x4];
 	unsigned int	mpll_lock;
 	unsigned char	res53[0xf4];
+#endif
 	unsigned int	apll_con0;
 	unsigned int	apll_con1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res54[0xf8];
+#else
 	unsigned int	mpll_con0;
 	unsigned int	mpll_con1;
 	unsigned char	res54[0xf0];
+#endif
 	unsigned int	src_cpu;
 	unsigned char	res55[0x1fc];
 	unsigned int	mux_stat_cpu;
@@ -212,12 +354,43 @@ struct exynos4_clock {
 	unsigned char	res57[0xf8];
 	unsigned int	div_stat_cpu0;
 	unsigned int	div_stat_cpu1;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res58[0x2f8];
+	unsigned int	gate_ip_cpu;
+	unsigned char	exynos4412res12[0xfc];
+#else
 	unsigned char	res58[0x3f8];
+#endif
 	unsigned int	clkout_cmu_cpu;
 	unsigned int	clkout_cmu_cpu_div_stat;
 	unsigned char	res59[0x5f8];
 	unsigned int	armclk_stopctrl;
 	unsigned int	atclk_stopctrl;
+#if defined(CONFIG_EXYNOS4412)
+	unsigned char	res60[0x1c];
+    unsigned int    pwr_ctrl;
+    unsigned int    pwr_ctrl2;
+	unsigned char	res61[0x3d8];
+    unsigned int    l2_satus;
+	unsigned char	res62[0xc];
+    unsigned int    cpu_satus;
+	unsigned char	res63[0xc];
+    unsigned int    ptm_satus;
+    unsigned int    div_isp0;
+    unsigned int    div_isp1;
+    unsigned int    div_stat_isp0;
+    unsigned int    div_stat_isp1;
+	unsigned char	res64[0x8];
+    unsigned int    gate_ip_isp0;
+    unsigned int    gate_ip_isp1;
+	unsigned char	res65[0x8];
+    unsigned int    clkout_cmp_isp;
+    unsigned int    clkout_cmp_isp_divstat;
+    unsigned int    cmu_isp_spare0;
+    unsigned int    cmu_isp_spare1;
+    unsigned int    cmu_isp_spare2;
+    unsigned int    cmu_isp_spare3;
+#else
 	unsigned char	res60[0x8];
 	unsigned int	parityfail_status;
 	unsigned int	parityfail_clear;
@@ -249,6 +422,7 @@ struct exynos4_clock {
 	unsigned int	div_iem_l3;
 	unsigned int	div_iem_l2;
 	unsigned int	div_iem_l1;
+#endif
 };
 
 struct exynos5_clock {
diff --git a/arch/arm/include/asm/arch-exynos/cpu.h b/arch/arm/include/asm/arch-exynos/cpu.h
index 0e6ea87..70d438c 100644
--- a/arch/arm/include/asm/arch-exynos/cpu.h
+++ b/arch/arm/include/asm/arch-exynos/cpu.h
@@ -37,8 +37,8 @@
 #define EXYNOS4_SYSTIMER_BASE		0x10050000
 #define EXYNOS4_WATCHDOG_BASE		0x10060000
 #define EXYNOS4_MIU_BASE		0x10600000
-#define EXYNOS4_DMC0_BASE		0x10400000
-#define EXYNOS4_DMC1_BASE		0x10410000
+#define EXYNOS4_DMC0_BASE		0x10600000
+#define EXYNOS4_DMC1_BASE		0x10610000
 #define EXYNOS4_GPIO_PART2_BASE		0x11000000
 #define EXYNOS4_GPIO_PART1_BASE		0x11400000
 #define EXYNOS4_FIMD_BASE		0x11C00000
diff --git a/arch/arm/include/asm/arch-exynos/power.h b/arch/arm/include/asm/arch-exynos/power.h
index e5467e2..1c95577 100644
--- a/arch/arm/include/asm/arch-exynos/power.h
+++ b/arch/arm/include/asm/arch-exynos/power.h
@@ -859,4 +859,8 @@ void set_usbhost_phy_ctrl(unsigned int enable);
 
 #define POWER_USB_HOST_PHY_CTRL_EN		(1 << 0)
 #define POWER_USB_HOST_PHY_CTRL_DISABLE		(0 << 0)
+
+void ps_hold_setup(void);
+
+#define POWER_PS_HOLD_CONTROL_DATA_HIGH (1 << 8)
 #endif
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 2d5c3bc..2592fa3 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -1105,6 +1105,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_UBISYS_P9D_EVP       3493
 #define MACH_TYPE_ATDGP318             3494
 #define MACH_TYPE_OMAP5_SEVM           3777
+#define MACH_TYPE_ODROIDX              4289
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -14222,6 +14223,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_omap5_sevm()      (0)
 #endif
 
+#ifdef CONFIG_MACH_ODROIDX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type     __machine_arch_type
+# else
+#  define machine_arch_type     MACH_TYPE_ODROIDX
+# endif
+# define machine_is_odroidx()      (machine_arch_type == MACH_TYPE_ODROIDX)
+#else
+# define machine_is_odroidx()      (0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/board/hardkernel/odroidx/Makefile b/board/hardkernel/odroidx/Makefile
new file mode 100644
index 0000000..cfa36be
--- /dev/null
+++ b/board/hardkernel/odroidx/Makefile
@@ -0,0 +1,65 @@
+#
+# Copyright (C) 2012 Hardkernel Co.,LTD.
+# Hakjoo Kim <ruppi.kim@hardkernel.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+SOBJS	:= mem_setup.o
+SOBJS	+= lowlevel_init.o
+
+ifndef CONFIG_SPL_BUILD
+COBJS	+= odroidx.o
+endif
+
+ifdef CONFIG_SPL_BUILD
+COBJS	+= spl_boot.o
+endif
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+ifdef CONFIG_SPL_BUILD
+ALL	+= $(OBJTREE)/tools/mk$(BOARD)spl
+endif
+
+ALL	+=$(obj).depend $(LIB)
+
+all:	$(ALL)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+ifdef CONFIG_SPL_BUILD
+$(OBJTREE)/tools/mk$(BOARD)spl:	tools/mk$(BOARD)_image.c
+	$(HOSTCC) tools/mk$(BOARD)_image.c -o $(OBJTREE)/tools/mk$(BOARD)spl
+endif
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/hardkernel/odroidx/lowlevel_init.S b/board/hardkernel/odroidx/lowlevel_init.S
new file mode 100644
index 0000000..8600023
--- /dev/null
+++ b/board/hardkernel/odroidx/lowlevel_init.S
@@ -0,0 +1,498 @@
+/*
+ * Lowlevel setup for ODROIDX board based on EXYNOS4412
+ *
+ * Copyright (C) 2013 Hardkernel Co.,LTD.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/cpu.h>
+#include "odroidx_setup.h"
+#define MEM_DLLl_ON
+/*
+ * Register usages:
+ *
+ * r5 has zero always
+ * r7 has GPIO part1 base 0x11400000
+ * r6 has GPIO part2 base 0x11000000
+ */
+
+_TEXT_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+
+	/* use iRAM stack in bl2 */
+	ldr	sp, =CONFIG_IRAM_STACK
+	stmdb	r13!, {ip,lr}
+
+	/* r5 has always zero */
+	mov	r5, #0
+	ldr	r7, =EXYNOS4_GPIO_PART1_BASE
+	ldr	r6, =EXYNOS4_GPIO_PART2_BASE
+
+	/* check reset status */
+	ldr	r0, =(EXYNOS4_POWER_BASE + INFORM1_OFFSET)
+	ldr	r1, [r0]
+
+	/* AFTR wakeup reset */
+	ldr	r2, =S5P_CHECK_DIDLE
+	cmp	r1, r2
+	beq	exit_wakeup
+
+	/* LPA wakeup reset */
+	ldr	r2, =S5P_CHECK_LPA
+	cmp	r1, r2
+	beq	exit_wakeup
+
+	/* Sleep wakeup reset */
+	ldr	r2, =S5P_CHECK_SLEEP
+	cmp	r1, r2
+	beq	wakeup_reset
+
+	/*
+	 * If U-boot is already running in RAM, no need to relocate U-Boot.
+	 * Memory controller must be configured before relocating U-Boot
+	 * in ram.
+	 */
+	ldr	r0, =0x0ffffff		/* r0 <- Mask Bits*/
+	bic	r1, pc, r0		/* pc <- current addr of code */
+					/* r1 <- unmasked bits of pc */
+	ldr	r2, _TEXT_BASE		/* r2 <- original base addr in ram */
+	bic	r2, r2, r0		/* r2 <- unmasked bits of r2*/
+	cmp	r1, r2			/* compare r1, r2 */
+	beq	1f			/* r0 == r1 then skip sdram init */
+
+	/* Memory initialize */
+	bl mem_ctrl_asm_init
+
+	/* init system clock */
+	bl	system_clock_init
+
+1:
+	/* for UART */
+	bl uart_asm_init
+	bl tzpc_init
+    ldmia   r13!, {ip,pc}
+
+wakeup_reset:
+	bl mem_ctrl_asm_init
+	bl system_clock_init
+	bl tzpc_init
+
+exit_wakeup:
+	/* Load return address and jump to kernel */
+	ldr	r0, =(EXYNOS4_POWER_BASE + INFORM0_OFFSET)
+
+	/* r1 = physical address of exynos4_cpu_resume function */
+	ldr	r1, [r0]
+
+	/* Jump to kernel*/
+	mov	pc, r1
+	nop
+	nop
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+	push	{lr}
+	ldr	r0, =EXYNOS4_CLOCK_BASE
+
+	/* APLL(0), MPLL(0), CORE(0), HPM(0) */
+	ldr	r1, =CLK_SRC_CPU_VAL
+	ldr	r2, =CLK_SRC_CPU_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+2:	subs	r1, r1, #1
+	bne	2b
+
+	/* DMC */
+	ldr	r1, =CLK_DIV_DMC0_VAL
+	ldr	r2, =CLK_DIV_DMC0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =CLK_DIV_DMC1_VAL
+	ldr	r2, =CLK_DIV_DMC1_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =CLK_SRC_TOP0_VAL
+	ldr	r2, =CLK_SRC_TOP0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =CLK_SRC_TOP1_VAL
+	ldr	r2, =CLK_SRC_TOP1_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+3:	subs	r1, r1, #1
+	bne	3b
+
+	ldr	r1, =CLK_DIV_TOP_VAL
+	ldr	r2, =CLK_DIV_TOP_OFFSET
+	str	r1, [r0, r2]
+
+	/*_SRC_LEFTBUS */
+	ldr	r1, =CLK_SRC_LEFTBUS_VAL
+	ldr	r2, =CLK_SRC_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+4:	subs	r1, r1, #1
+	bne	4b
+
+	/*_DIV_LEFTBUS */
+	ldr	r1, =CLK_DIV_LEFTBUS_VAL
+	ldr	r2, =CLK_DIV_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/*_SRC_RIGHTBUS */
+	ldr	r1, =CLK_SRC_RIGHTBUS_VAL
+	ldr	r2, =CLK_SRC_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+5:	subs	r1, r1, #1
+	bne	5b
+
+	/*CLK_DIV_RIGHTBUS */
+	ldr	r1, =CLK_DIV_RIGHTBUS_VAL
+	ldr	r2, =CLK_DIV_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/* UART[0:4] */
+	ldr	r1, =CLK_SRC_PERIL0_VAL
+	ldr	r2, =CLK_SRC_PERIL0_OFFSET
+	str	r1, [r0, r2]
+
+	/* FIMD0 */
+	ldr	r1, =CLK_SRC_LCD0_VAL
+	ldr	r2, =CLK_SRC_LCD0_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+6:	subs	r1, r1, #1
+	bne	6b
+
+	/* MMC[0:1] */
+	ldr	r1, =CLK_DIV_FSYS1_VAL		/* 800(MPLL) / (15 + 1) */
+	ldr	r2, =CLK_DIV_FSYS1_OFFSET
+	str	r1, [r0, r2]
+
+	/* MMC[2:3] */
+	ldr	r1, =CLK_DIV_FSYS2_VAL		/* 800(MPLL) / (15 + 1) */
+	ldr	r2, =CLK_DIV_FSYS2_OFFSET
+	str	r1, [r0, r2]
+
+	/* MMC4 */
+	ldr	r1, =CLK_DIV_FSYS3_VAL		/* 800(MPLL) / (15 + 1) */
+	ldr	r2, =CLK_DIV_FSYS3_OFFSET
+	str	r1, [r0, r2]
+
+	/* _DIV_PERIL0: UART Clock Divisors */
+	ldr	r1, =CLK_DIV_PERIL0_VAL
+	ldr	r2, =CLK_DIV_PERIL0_OFFSET
+	str	r1, [r0, r2]
+
+	/* Set PLL locktime */
+	ldr	r1, =APLL_LOCK_VAL
+	ldr	r2, =APLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =MPLL_LOCK_VAL
+	ldr	r2, =MPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =EPLL_LOCK_VAL
+	ldr	r2, =EPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =VPLL_LOCK_VAL
+	ldr	r2, =VPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+    ldr r1, =CLK_DIV_CPU0_VAL
+	ldr	r2, =CLK_DIV_CPU0_OFFSET
+	str	r1, [r0, r2]
+    ldr r1, =CLK_DIV_CPU1_VAL
+	ldr	r2, =CLK_DIV_CPU1_OFFSET
+	str	r1, [r0, r2]
+
+	/* APLL_CON1 */
+	ldr	r1, =APLL_CON1_VAL
+	ldr	r2, =APLL_CON1_OFFSET
+	str	r1, [r0, r2]
+
+	/* APLL_CON0 */
+	ldr	r1, =APLL_CON0_VAL
+	ldr	r2, =APLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+    /* check MPLL and if MPLL is not 400 Mhz skip MPLL resetting for C2C operation */
+	ldr	r2, =MPLL_CON0_OFFSET
+	ldr	r1, [r0, r2]
+	ldr	r3, =0xa0640301
+    cmp r1, r3
+    bne skip_mpll
+
+	/* MPLL_CON1 */
+	ldr	r1, =MPLL_CON1_VAL
+	ldr	r2, =MPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+
+	/* MPLL_CON0 */
+	ldr	r1, =MPLL_CON0_VAL
+	ldr	r2, =MPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+skip_mpll:
+
+	/* EPLL_CON2 */
+	ldr	r1, =EPLL_CON2_VAL
+	ldr	r2, =EPLL_CON2_OFFSET
+	str	r1, [r0, r2]
+
+	/* EPLL_CON1 */
+	ldr	r1, =EPLL_CON1_VAL
+	ldr	r2, =EPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+
+	/* EPLL_CON0 */
+	ldr	r1, =EPLL_CON0_VAL
+	ldr	r2, =EPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+	/* VPLL_CON2 */
+	ldr	r1, =VPLL_CON2_VAL
+	ldr	r2, =VPLL_CON2_OFFSET
+	str	r1, [r0, r2]
+
+	/* VPLL_CON1 */
+	ldr	r1, =VPLL_CON1_VAL
+	ldr	r2, =VPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+
+	/* VPLL_CON0 */
+	ldr	r1, =VPLL_CON0_VAL
+	ldr	r2, =VPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x40000
+7:	subs	r1, r1, #1
+	bne	7b
+
+    ldr r1, =0x01000001
+    ldr r2, =CLK_SRC_CPU_OFFSET
+    str r1, [r0, r2]
+    ldr r1, =0x00011000
+    ldr r2, =CLK_SRC_DMC_OFFSET
+    str r1, [r0, r2]
+    ldr r1, =0x00000110
+    ldr r2, =CLK_SRC_TOP0_OFFSET
+    str r1, [r0, r2]
+    ldr r1, =0x01111000
+    ldr r2, =CLK_SRC_TOP1_OFFSET
+    str r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+8:	subs	r1, r1, #1
+	bne	8b
+
+/* check C2C_CTRL enable bit */
+	ldr r3, =EXYNOS4_POWER_BASE
+	ldr r1, [r3, #C2C_CTRL_OFFSET]
+	and r1, r1, #1
+	cmp r1, #0
+	bne v310_2
+
+/* ConControl */
+#ifdef MEM_DLLl_ON
+	ldr	r0, =EXYNOS4_DMC0_BASE
+
+	ldr	r1, =0x7F10100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0xE0000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7F10100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+9:	subs	r1, r1, #1
+	bne	9b
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+10:	subs	r1, r1, #1
+	bne	10b
+
+	ldr	r0, =EXYNOS4_DMC1_BASE
+
+	ldr	r1, =0x7F10100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0xE0000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7F10100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+11:	subs	r1, r1, #1
+	bne	11b
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+12:	subs	r1, r1, #1
+	bne	12b
+#endif
+
+	ldr	r0, =EXYNOS4_DMC0_BASE
+	ldr	r1, =0x0FFF30FA
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =EXYNOS4_DMC1_BASE
+	ldr	r1, =0x0FFF30FA
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =EXYNOS4_DMC0_BASE
+	ldr	r1, =0x00202533
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =EXYNOS4_DMC1_BASE
+	ldr	r1, =0x00202533
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+
+v310_2:
+	pop	{pc}
+/*
+ * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
+ * void uart_asm_init(void)
+ */
+	.globl uart_asm_init
+uart_asm_init:
+
+	/* setup UART0-UART3 GPIOs (part1) */
+	mov	r0, r7
+	ldr	r1, =EXYNOS4_GPIO_A0_CON_VAL
+	str	r1, [r0, #EXYNOS4_GPIO_A0_CON_OFFSET]
+	ldr	r1, =EXYNOS4_GPIO_A1_CON_VAL
+	str	r1, [r0, #EXYNOS4_GPIO_A1_CON_OFFSET]
+
+	ldr r0, =EXYNOS4_UART_BASE
+	add r0, r0, #EXYNOS4_DEFAULT_UART_OFFSET
+
+	ldr	r1, =ULCON_VAL
+	str	r1, [r0, #ULCON_OFFSET]
+	ldr	r1, =UCON_VAL
+	str	r1, [r0, #UCON_OFFSET]
+	ldr	r1, =UFCON_VAL
+	str	r1, [r0, #UFCON_OFFSET]
+	ldr	r1, =UBRDIV_VAL
+	str	r1, [r0, #UBRDIV_OFFSET]
+	ldr	r1, =UFRACVAL_VAL
+	str	r1, [r0, #UFRACVAL_OFFSET]
+#ifdef CONFIG_SPL_BUILD
+	ldr	r1, =0x4f4f4f4f
+	str	r1, [r0, #UTXHN_OFFSET]		@'O'
+#endif
+	mov	pc, lr
+
+/* Setting TZPC[TrustZone Protection Controller] */
+tzpc_init:
+	ldr	r0, =TZPC0_BASE
+	mov	r1, #R0SIZE
+	str	r1, [r0]
+	mov	r1, #DECPROTXSET
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+    mov r1, #0xbd
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	mov	r1, #DECPROTXSET
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	ldr	r0, =TZPC1_BASE
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	ldr	r0, =TZPC2_BASE
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	ldr	r0, =TZPC3_BASE
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	ldr	r0, =TZPC4_BASE
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	ldr	r0, =TZPC5_BASE
+	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+	mov	pc, lr
diff --git a/board/hardkernel/odroidx/mem_setup.S b/board/hardkernel/odroidx/mem_setup.S
new file mode 100644
index 0000000..2a74e5e
--- /dev/null
+++ b/board/hardkernel/odroidx/mem_setup.S
@@ -0,0 +1,297 @@
+/*
+ * Memory setup for ODROID-X board based on EXYNOS4412
+ *
+ * Copyright (C) 2013  Hardkernel Co.,LTD.
+ * Hakjoo Kim <ruppi.kim@hardkernel.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "odroidx_setup.h"
+#define SET_MIU
+
+	.globl mem_ctrl_asm_init
+mem_ctrl_asm_init:
+
+    /* CLK_DIV_DMC0 on iROM DMC=50MHz for Init DMC */
+	ldr	r0, =EXYNOS4_CLOCK_BASE
+    ldr r1, =0x00117713
+	ldr r2, =CLK_DIV_DMC0_OFFSET
+	str r1, [r0, r2]
+
+	/* DREX0 */
+	ldr	r0, =EXYNOS4_DMC0_BASE
+
+	/*
+	 * ZQ Calibration
+	 * Termination: Disable
+	 * Auto Calibration Start: Enable
+	 */
+	ldr	r1, =0xe3855403
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+    /*
+	 * DLL Parameters Setting:
+	 */
+	ldr	r1, =0x71101008
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100a
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	/*
+	 * Update DLL Information:
+	 * Force DLL Resyncronization
+	 */
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	/* Enable Differential DQS, DLL Off*/
+	ldr	r1, =0x71101008
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	/* DLL Start */
+	ldr	r1, =0x0000008c
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	/* DLL Start */
+	ldr	r1, =0x0000008c
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0FFF30CA
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	/*
+	 * Memor Burst length: 8
+	 * Number of chips: 2
+	 * Memory Bus width: 32 bit
+	 * Memory Type: DDR2
+	 * Additional Latancy for PLL: 1 Cycle
+	 */
+	ldr	r1, =0x00202500
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+	/*
+	 * Memory Configuration Chip 0
+	 * Address Mapping: Interleaved
+	 * Number of Column address Bits: 10 bits
+	 * Number of Rows Address Bits: 14
+	 * Number of Banks: 8
+	 */
+	ldr	r1, =0x40c01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+    /* Interleve on 128 byte */
+	ldr	r1, =0x80000007
+	str	r1, [r0, #DMC_IVCONTROL]
+
+	/* Config Precharge Policy */
+	ldr	r1, =0x64000000
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	/* Config Power Down  Policy */
+@	ldr	r1, =0x9c4000FF
+@	str	r1, [r0, #DMC_PWRDNCONFIG]
+
+	/*
+	 * TimingAref, TimingRow, TimingData, TimingPower Setting:
+	 * Values as per Memory AC Parameters
+	 */
+	ldr	r1, =0x0000005d
+	str	r1, [r0, #DMC_TIMINGAREF]
+	ldr	r1, =0x34498691
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x36330306
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x50380365
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+2:	subs	r2, r2, #1
+	bne	2b
+
+	/* Chip0: NOP Command: Assert and Hold CKE to high level */
+	ldr	r1, =0x07000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x300000
+3:	subs	r2, r2, #1
+	bne	3b
+
+	/* Chip0: ZQINIT */
+	ldr	r1, =0x00071c00
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+4:	subs	r2, r2, #1
+	bne	4b
+
+	/* Chip0: NOP Command: Assert and Hold CKE to high level */
+	ldr	r1, =0x00010bfc
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+5:	subs	r2, r2, #1
+	bne	5b
+
+	/* Chip0: EMRS2, EMRS3, EMRS, MRS Commands Using Direct Command */
+	ldr	r1, =0x00000608
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000810
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000c08
+	str	r1, [r0, #DMC_DIRECTCMD]
+#if 1
+/* PS-Hold high */
+	ldr	r0, =0x1002330c
+	ldr	r1, [r0]
+	orr	r1, r1, #0x300
+	str	r1, [r0]
+#endif
+
+
+	/* DREX1 */
+	ldr	r0, =EXYNOS4_DMC1_BASE	@0x10610000
+
+	ldr	r1, =0xE3855403
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	ldr	r1, =0x71101008
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100A
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x0000008C
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0000008C
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0FFF30CA
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0x00202500
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+/*
+	 * Memory Configuration Chip 0
+	 * Address Mapping: Interleaved
+	 * Number of Column address Bits: 10 bits
+	 * Number of Rows Address Bits: 14
+	 * Number of Banks: 8
+	 */
+
+	ldr	r1, =0x40c01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	ldr	r1, =0x80000007
+	str	r1, [r0, #DMC_IVCONTROL]
+
+	/* Config Precharge Policy */
+	ldr	r1, =0x64000000
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x9c4000ff
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	/*
+	 * TimingAref, TimingRow, TimingData, TimingPower Setting:
+	 * Values as per Memory AC Parameters
+	 */
+	ldr	r1, =0x0000005D
+	str	r1, [r0, #DMC_TIMINGAREF]
+	ldr	r1, =0x34498691
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x36330306
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x50380365
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+6:	subs	r2, r2, #1
+	bne	6b
+
+	/* Chip0: NOP Command: Assert and Hold CKE to high level */
+	ldr	r1, =0x07000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+7:	subs	r2, r2, #1
+	bne	7b
+
+	ldr	r1, =0x00071c00
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+8:	subs	r2, r2, #1
+	bne	8b
+
+	/* Chip1: ZQINIT */
+	ldr	r1, =0x00010bfc
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* Wait ?us*/
+	mov	r2, #0x100000
+9:	subs	r2, r2, #1
+	bne	9b
+
+    ldr	r1, =0x00000608
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000810
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000c08
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+#if 1
+/* PS-Hold high */
+	ldr	r0, =0x1002330c
+	ldr	r1, [r0]
+	orr	r1, r1, #0x300
+	str	r1, [r0]
+#endif
+
+
+	mov	pc, lr
diff --git a/board/hardkernel/odroidx/odroidx.c b/board/hardkernel/odroidx/odroidx.c
new file mode 100644
index 0000000..5bff3c7
--- /dev/null
+++ b/board/hardkernel/odroidx/odroidx.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2013  Hardkernel Co.,LTD.
+ * Hakjoo Kim <ruppi.kim@hardkernel.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/pinmux.h>
+#include <asm/arch/sromc.h>
+#include <asm/arch/power.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+struct exynos4_gpio_part1 *gpio1;
+struct exynos4_gpio_part2 *gpio2;
+
+int board_init(void)
+{
+	gpio1 = (struct exynos4_gpio_part1 *) EXYNOS4_GPIO_PART1_BASE;
+	gpio2 = (struct exynos4_gpio_part2 *) EXYNOS4_GPIO_PART2_BASE;
+
+	gd->bd->bi_boot_params = (PHYS_SDRAM_1 + 0x100UL);
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size	= get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE)
+			+ get_ram_size((long *)PHYS_SDRAM_2, PHYS_SDRAM_2_SIZE)
+			+ get_ram_size((long *)PHYS_SDRAM_3, PHYS_SDRAM_3_SIZE)
+			+ get_ram_size((long *)PHYS_SDRAM_4, PHYS_SDRAM_4_SIZE);
+    return 0;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = get_ram_size((long *)PHYS_SDRAM_1,
+							PHYS_SDRAM_1_SIZE);
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = get_ram_size((long *)PHYS_SDRAM_2,
+							PHYS_SDRAM_2_SIZE);
+	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+	gd->bd->bi_dram[2].size = get_ram_size((long *)PHYS_SDRAM_3,
+							PHYS_SDRAM_3_SIZE);
+	gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+	gd->bd->bi_dram[3].size = get_ram_size((long *)PHYS_SDRAM_4,
+							PHYS_SDRAM_4_SIZE);
+
+#ifdef CONFIG_TRUSTZONE
+      gd->bd->bi_dram[CONFIG_NR_DRAM_BANKS - 1].size -= CONFIG_TRUSTZONE_RESERVED_DRAM;
+#endif
+}
+
+static void board_power_init(void)
+{
+    ps_hold_setup();
+}
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_SMC911X_ODROID
+	if (smc9115_pre_init())
+		return -1;
+	return smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	printf("\nBoard: ODROID-X\n");
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_GENERIC_MMC
+int board_mmc_init(bd_t *bis)
+{
+	int err;
+#if 0
+	err = exynos_pinmux_config(PERIPH_ID_SDMMC0, PINMUX_FLAG_8BIT_MODE);
+	if (err) {
+		debug("SDMMC0 not configured\n");
+		return err;
+	}
+
+	/*
+	 * MMC device init
+	 * mmc0	 : eMMC (8-bit buswidth)
+	 * mmc2	 : SD card (4-bit buswidth)
+	 */
+	err = s5p_mmc_init(0, 8);
+#endif
+	err = exynos_pinmux_config(PERIPH_ID_SDMMC2, PINMUX_FLAG_NONE);
+	if (err) {
+		debug("SDMMC2 not configured\n");
+		return err;
+	}
+
+	err = s5p_mmc_init(2, 4);
+	return err;
+}
+#endif
+
+static int board_uart_init(void)
+{
+	int err;
+
+	err = exynos_pinmux_config(PERIPH_ID_UART0, PINMUX_FLAG_NONE);
+	if (err) {
+		debug("UART0 not configured\n");
+		return err;
+	}
+
+	err = exynos_pinmux_config(PERIPH_ID_UART1, PINMUX_FLAG_NONE);
+	if (err) {
+		debug("UART1 not configured\n");
+		return err;
+	}
+
+	err = exynos_pinmux_config(PERIPH_ID_UART2, PINMUX_FLAG_NONE);
+	if (err) {
+		debug("UART2 not configured\n");
+		return err;
+	}
+
+	err = exynos_pinmux_config(PERIPH_ID_UART3, PINMUX_FLAG_NONE);
+	if (err) {
+		debug("UART3 not configured\n");
+		return err;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_INIT_BOARD
+static int board_i2c_init(void)
+{
+	int i, err;
+
+	for (i = 0; i < CONFIG_MAX_I2C_NUM; i++) {
+		err = exynos_pinmux_config((PERIPH_ID_I2C0 + i),
+						PINMUX_FLAG_NONE);
+		if (err) {
+			debug("I2C%d not configured\n", (PERIPH_ID_I2C0 + i));
+			return err;
+		}
+	}
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+int board_early_init_f(void)
+{
+	int err;
+	err = board_uart_init();
+	if (err) {
+		debug("UART init failed\n");
+		return err;
+	}
+    board_power_init();
+#ifdef CONFIG_SYS_I2C_INIT_BOARD
+	err = board_i2c_init();
+#endif
+	return err;
+}
+#endif
diff --git a/board/hardkernel/odroidx/odroidx_setup.h b/board/hardkernel/odroidx/odroidx_setup.h
new file mode 100644
index 0000000..72dcb8b
--- /dev/null
+++ b/board/hardkernel/odroidx/odroidx_setup.h
@@ -0,0 +1,628 @@
+/*
+ * Machine Specific Values for ODROIDX board based on Exynos4412
+ *
+ * Copyright (C) 2013  Hardkernel Co.,LTD.
+ * Hakjoo Kim <ruppi.kim@hardkernel.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _ODROIDX_SETUP_H
+#define _ODROIDX_SETUP_H
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/cpu.h>
+
+/* Offsets of clock registers (sources and dividers) */
+#define CLK_SRC_CPU_OFFSET	0x14200
+#define CLK_DIV_CPU0_OFFSET	0x14500
+#define CLK_DIV_CPU1_OFFSET	0x14504
+
+#define CLK_SRC_DMC_OFFSET	0x10200
+#define CLK_DIV_DMC0_OFFSET	0x10500
+#define CLK_DIV_DMC1_OFFSET	0x10504
+
+#define CLK_SRC_TOP0_OFFSET	0xC210
+#define CLK_SRC_TOP1_OFFSET	0xC214
+#define CLK_DIV_TOP_OFFSET	0xC510
+
+#define CLK_SRC_LEFTBUS_OFFSET	0x4200
+#define CLK_DIV_LEFTBUS_OFFSET	0x4500
+
+#define CLK_SRC_RIGHTBUS_OFFSET	0x8200
+#define CLK_DIV_RIGHTBUS_OFFSET	0x8500
+
+#define CLK_SRC_FSYS_OFFSET	0xC240
+#define CLK_DIV_FSYS1_OFFSET	0xC544
+#define CLK_DIV_FSYS2_OFFSET	0xC548
+#define CLK_DIV_FSYS3_OFFSET	0xC54C
+
+#define CLK_SRC_PERIL0_OFFSET	0xC250
+#define CLK_DIV_PERIL0_OFFSET	0xC550
+
+#define CLK_SRC_LCD0_OFFSET	0xC234
+
+#define APLL_LOCK_OFFSET	0x14000
+#define MPLL_LOCK_OFFSET	0x14008
+#define APLL_CON0_OFFSET	0x14100
+#define APLL_CON1_OFFSET	0x14104
+#define MPLL_CON0_OFFSET	0x10108
+#define MPLL_CON1_OFFSET	0x1010C
+
+#define EPLL_LOCK_OFFSET	0xC010
+#define VPLL_LOCK_OFFSET	0xC020
+#define EPLL_CON0_OFFSET	0xC110
+#define EPLL_CON1_OFFSET	0xC114
+#define EPLL_CON2_OFFSET	0xC118
+#define VPLL_CON0_OFFSET	0xC120
+#define VPLL_CON1_OFFSET	0xC124
+#define VPLL_CON2_OFFSET	0xC128
+
+/* DMC: DRAM Controllor Register offsets */
+#define DMC_CONCONTROL		0x00
+#define DMC_MEMCONTROL		0x04
+#define DMC_MEMCONFIG0		0x08
+#define DMC_MEMCONFIG1		0x0C
+#define DMC_DIRECTCMD		0x10
+#define DMC_PRECHCONFIG		0x14
+#define DMC_PHYCONTROL0		0x18
+#define DMC_PHYCONTROL1		0x1C
+#define DMC_PHYCONTROL2		0x20
+#define DMC_PHYCONTROL3		0x24
+#define DMC_PWRDNCONFIG		0x18
+#define DMC_TIMINGAREF		0x30
+#define DMC_TIMINGROW		0x34
+#define DMC_TIMINGDATA		0x38
+#define DMC_TIMINGPOWER		0x3C
+#define DMC_PHYZQCONTROL	0x44
+#define DMC_IVCONTROL	    0xF0
+
+#define C2C_CTRL_OFFSET     0x24
+/* Bus Configuration Register Address */
+#define ASYNC_CONFIG		0x10010350
+
+/* MIU Config Register Offsets*/
+#define APB_SFR_INTERLEAVE_CONF_OFFSET	0x400
+#define APB_SFR_ARBRITATION_CONF_OFFSET		0xC00
+
+/* Offset for inform registers */
+#define INFORM0_OFFSET			0x800
+#define INFORM1_OFFSET			0x804
+
+/* GPIO Offsets for UART: GPIO Contol Register */
+#define EXYNOS4_GPIO_A0_CON_OFFSET	0x00
+#define EXYNOS4_GPIO_A1_CON_OFFSET	0x20
+
+/* UART Register offsets */
+#define ULCON_OFFSET		0x00
+#define UCON_OFFSET		0x04
+#define UFCON_OFFSET		0x08
+#define UTXHN_OFFSET		0x20
+#define UBRDIV_OFFSET		0x28
+#define UFRACVAL_OFFSET		0x2C
+
+/* TZPC : Register Offsets */
+#define TZPC0_BASE		0x10110000
+#define TZPC1_BASE		0x10120000
+#define TZPC2_BASE		0x10130000
+#define TZPC3_BASE		0x10140000
+#define TZPC4_BASE		0x10150000
+#define TZPC5_BASE		0x10160000
+
+#define TZPC_DECPROT0SET_OFFSET	0x804
+#define TZPC_DECPROT1SET_OFFSET	0x810
+#define TZPC_DECPROT2SET_OFFSET	0x81C
+#define TZPC_DECPROT3SET_OFFSET	0x828
+
+/* CLK_SRC_CPU */
+#define MUX_HPM_SEL_MOUTAPLL		0x0
+#define MUX_HPM_SEL_SCLKMPLL		0x1
+#define MUX_CORE_SEL_MOUTAPLL		0x0
+#define MUX_CORE_SEL_SCLKMPLL		0x1
+#define MUX_MPLL_SEL_FILPLL		0x0
+#define MUX_MPLL_SEL_MOUTMPLLFOUT	0x0
+#define MUX_APLL_SEL_FILPLL		0x0
+#define MUX_APLL_SEL_MOUTMPLLFOUT	0x0
+#define CLK_SRC_CPU_VAL			((MUX_HPM_SEL_MOUTAPLL << 20) \
+					| (MUX_CORE_SEL_MOUTAPLL << 16) \
+					| (MUX_MPLL_SEL_MOUTMPLLFOUT << 8)\
+					| (MUX_APLL_SEL_MOUTMPLLFOUT << 0))
+
+/* CLK_DIV_CPU0 */
+#define APLL_RATIO  0x1
+#define CORE_RATIO  0x0
+#define CORE2_RATIO 0x0
+#define COREM0_RATIO    0x2
+#define COREM1_RATIO    0x5
+#define PERIPH_RATIO    0x7
+#define ATB_RATIO   0x4
+#define PCLK_DBG_RATIO  0x1
+
+#define CLK_DIV_CPU0_VAL	((CORE2_RATIO << 28) \
+				| (APLL_RATIO << 24) \
+				| (PCLK_DBG_RATIO << 20) \
+				| (ATB_RATIO << 16) \
+				| (PERIPH_RATIO << 12) \
+				| (COREM1_RATIO << 8) \
+				| (COREM0_RATIO << 4) \
+				| (CORE_RATIO << 0))
+
+/* CLK_DIV_CPU1 */
+#define CORES_RATIO     0x3
+#define HPM_RATIO		0x0
+#define COPY_RATIO		0x4
+#define CLK_DIV_CPU1_VAL	((CORES_RATIO << 8) \
+                | (HPM_RATIO << 4)  \
+                | (COPY_RATIO))
+
+/* CLK_SRC_DMC */
+#define MUX_PWI_SEL_XXTI		0x0
+#define MUX_PWI_SEL_XUSBXTI		0x1
+#define MUX_PWI_SEL_SCLK_HDMI24M	0x2
+#define MUX_PWI_SEL_SCLK_USBPHY0	0x3
+#define MUX_PWI_SEL_SCLK_USBPHY1	0x4
+#define MUX_PWI_SEL_SCLK_HDMIPHY	0x5
+#define MUX_PWI_SEL_SCLKMPLL		0x6
+#define MUX_PWI_SEL_SCLKEPLL		0x7
+#define MUX_PWI_SEL_SCLKVPLL		0x8
+#define MUX_DPHY_SEL_SCLKMPLL		0x0
+#define MUX_DPHY_SEL_SCLKAPLL		0x1
+#define MUX_DMC_BUS_SEL_SCLKMPLL	0x0
+#define MUX_DMC_BUS_SEL_SCLKAPLL	0x1
+#define CLK_SRC_DMC_VAL			((MUX_PWI_SEL_XUSBXTI << 16) \
+					| (MUX_DPHY_SEL_SCLKMPLL << 8) \
+					| (MUX_DMC_BUS_SEL_SCLKMPLL << 4))
+
+/* CLK_DIV_DMC0 */
+#define CORE_TIMERS_RATIO   0x0
+#define COPY2_RATIO     0x0
+#define DMCP_RATIO		0x1
+#define DMCD_RATIO		0x1
+#if defined(CONFIG_CLK_BUS_DMC_100_200)
+#define DMC_RATIO		0x3
+#else
+#define DMC_RATIO		0x1
+#endif
+#define DPHY_RATIO		0x1
+#define ACP_PCLK_RATIO	    0x1
+#define ACP_RATIO		0x3
+
+#define CLK_DIV_DMC0_VAL	((CORE_TIMERS_RATIO << 28) \
+                | (COPY2_RATIO << 24) \
+                | (DMCP_RATIO << 20) \
+				| (DMCD_RATIO << 16) \
+				| (DMC_RATIO << 12) \
+				| (DPHY_RATIO << 8) \
+				| (ACP_PCLK_RATIO << 4)	\
+				| (ACP_RATIO << 0))
+
+/* CLK_DIV_DMC1 */
+#define DPM_RATIO     0x7
+#define DVSEM_RATIO		0x07
+#define C2C_ACLK_RATIO  0x1
+#define PWI_RATIO		0x7
+#define C2C_RATIO		0x1
+#define G2D_ACP_RATIO  	0x3
+
+/*
+#define CLK_DIV_DMC1_VAL	((DPM_RATIO << 24) \
+				| (DVSEM_RATIO << 16) \
+				| (C2C__ACLK_RATIO << 12) \
+				| (PWI_RATIO << 8) \
+				| (C2C_RATIO << 4)	\
+				| (G2D_ACP_RATIO << 0))
+*/
+#define CLK_DIV_DMC1_VAL    0x07071713
+
+/* CLK_SRC_TOP0 */
+#define MUX_ONENAND_SEL_ACLK_133	0x0
+#define MUX_ONENAND_SEL_ACLK_160	0x1
+#define MUX_ACLK_133_SEL_SCLKMPLL	0x0
+#define MUX_ACLK_133_SEL_SCLKAPLL	0x1
+#define MUX_ACLK_160_SEL_SCLKMPLL	0x0
+#define MUX_ACLK_160_SEL_SCLKAPLL	0x1
+#define MUX_ACLK_100_SEL_SCLKMPLL	0x0
+#define MUX_ACLK_100_SEL_SCLKAPLL	0x1
+#define MUX_ACLK_200_SEL_SCLKMPLL	0x0
+#define MUX_ACLK_200_SEL_SCLKAPLL	0x1
+#define MUX_VPLL_SEL_FINPLL		0x0
+#define MUX_VPLL_SEL_FOUTVPLL		0x1
+#define MUX_EPLL_SEL_FINPLL		0x0
+#define MUX_EPLL_SEL_FOUTEPLL		0x1
+#define MUX_ONENAND_1_SEL_MOUTONENAND	0x0
+#define MUX_ONENAND_1_SEL_SCLKVPLL	0x1
+#define CLK_SRC_TOP0_VAL		((MUX_ONENAND_SEL_ACLK_133 << 28) \
+					| (MUX_ACLK_133_SEL_SCLKMPLL << 24) \
+					| (MUX_ACLK_160_SEL_SCLKMPLL << 20) \
+					| (MUX_ACLK_100_SEL_SCLKMPLL << 16) \
+					| (MUX_ACLK_200_SEL_SCLKMPLL << 12) \
+					| (MUX_VPLL_SEL_FOUTVPLL << 8) \
+					| (MUX_EPLL_SEL_FOUTEPLL << 4)\
+					| (MUX_ONENAND_1_SEL_MOUTONENAND << 0))
+
+/* CLK_SRC_TOP1 */
+#define MUX_ACLK_400_MCUISP_SUB_SEL_FINPLL  0x0
+#define MUX_ACLK_400_MCUISP_SUB_SEL_DIVOUT  0x1
+#define MUX_ACLK_200_SUB_SEL_FINPLL  0x0
+#define MUX_ACLK_200_SUB_SEL_DIVOUT  0x1
+#define MUX_ACLK_266_GPS_SUB_SEL_FINPLL  0x0
+#define MUX_ACLK_266_GPS_SUB_SEL_DIVOUT  0x1
+#define MUX_MPLL_USER_SET_T_FINPLL  0x0
+#define MUX_MPLL_USER_SET_T_DIVOUT  0x1
+#define MUX_ACK_400_MCUISP_SEL_SCLKMPLL  0x0
+#define MUX_ACK_400_MCUISP_SEL_SCLKAPLL  0x1
+#define MUX_ACK_266_GPS_SEL_SCLKMPLL  0x0
+#define MUX_ACK_266_GPS_SEL_SCLKAPLL  0x1
+
+#define CLK_SRC_TOP1_VAL		((MUX_ACLK_400_MCUISP_SUB_SEL_DIVOUT << 24) \
+                    | (MUX_ACLK_200_SUB_SEL_DIVOUT << 20) \
+                    | (MUX_ACLK_266_GPS_SUB_SEL_DIVOUT << 16) \
+                    | (MUX_MPLL_USER_SET_T_DIVOUT << 12) \
+                    | (MUX_ACK_400_MCUISP_SEL_SCLKMPLL << 8) \
+                    | (MUX_ACK_266_GPS_SEL_SCLKMPLL << 4))
+
+
+/* CLK_DIV_TOP */
+#define ACLK_400_MCUISP_RATIO   0x1
+#define ACLK_266_GPS_RATIO		0x2
+#define ONENAND_RATIO		0x1
+#define ACLK_133_RATIO		0x5
+#define ACLK_160_RATIO		0x4
+#define ACLK_100_RATIO		0x7
+#define ACLK_200_RATIO		0x4
+#define CLK_DIV_TOP_VAL		((ACLK_400_MCUISP_RATIO << 24)	\
+				| (ACLK_266_GPS_RATIO << 20)     \
+				| (ONENAND_RATIO << 16)     \
+				| (ACLK_133_RATIO << 12)    \
+				| (ACLK_160_RATIO << 8)	    \
+				| (ACLK_100_RATIO << 4)	    \
+				| (ACLK_200_RATIO << 0))
+
+/* CLK_SRC_LEFTBUS */
+#define MUX_GDL_SEL_SCLKMPLL	0x0
+#define MUX_GDL_SEL_SCLKAPLL	0x1
+#define MUX_MPLL_USER_SEL_L_FINPLL	0x0
+#define MUX_MPLL_USER_SEL_L_FOUTPLL 0x1
+#define CLK_SRC_LEFTBUS_VAL	    ((MUX_MPLL_USER_SEL_L_FOUTPLL<<4) \
+                | (MUX_GDL_SEL_SCLKMPLL))
+
+/* CLK_DIV_LEFTBUS */
+#define GPL_RATIO		0x1
+#define GDL_RATIO		0x3
+#define CLK_DIV_LEFTBUS_VAL	((GPL_RATIO << 4) | (GDL_RATIO))
+
+/* CLK_SRC_RIGHTBUS */
+#define MUX_GDR_SEL_SCLKMPLL	0x0
+#define MUX_GDR_SEL_SCLKAPLL	0x1
+#define MUX_MPLL_USER_SEL_R_FINPLL	0x0
+#define MUX_MPLL_USER_SEL_R_SCLKPLL	0x1
+#define CLK_SRC_RIGHTBUS_VAL    ((MUX_MPLL_USER_SEL_R_SCLKPLL<<4) \
+                    | (MUX_GDR_SEL_SCLKMPLL))
+
+/* CLK_DIV_RIGHTBUS */
+#define GPR_RATIO		0x1
+#define GDR_RATIO		0x3
+#define CLK_DIV_RIGHTBUS_VAL	((GPR_RATIO << 4) | (GDR_RATIO))
+
+/* CLK_SRS_FSYS: 6 = SCLKMPLL */
+#define SATA_SEL_SCLKMPLL	0
+#define SATA_SEL_SCLKAPLL	1
+
+#define MMC_SEL_XXTI		0
+#define MMC_SEL_XUSBXTI		1
+#define MMC_SEL_SCLK_HDMI24M	2
+#define MMC_SEL_SCLK_USBPHY0	3
+#define MMC_SEL_SCLK_USBPHY1	4
+#define MMC_SEL_SCLK_HDMIPHY	5
+#define MMC_SEL_SCLKMPLL	6
+#define MMC_SEL_SCLKEPLL	7
+#define MMC_SEL_SCLKVPLL	8
+
+#define MMCC0_SEL		MMC_SEL_SCLKMPLL
+#define MMCC1_SEL		MMC_SEL_SCLKMPLL
+#define MMCC2_SEL		MMC_SEL_SCLKMPLL
+#define MMCC3_SEL		MMC_SEL_SCLKMPLL
+#define MMCC4_SEL		MMC_SEL_SCLKMPLL
+#define CLK_SRC_FSYS_VAL	((SATA_SEL_SCLKMPLL << 24) \
+				| (MMCC4_SEL << 16) \
+				| (MMCC3_SEL << 12) \
+				| (MMCC2_SEL << 8) \
+				| (MMCC1_SEL << 4) \
+				| (MMCC0_SEL << 0))
+
+/* SCLK_MMC[0-4] = MOUTMMC[0-4]/(MMC[0-4]_RATIO + 1)/(MMC[0-4]_PRE_RATIO +1) */
+/* CLK_DIV_FSYS1 */
+#define MMC0_RATIO		0xF
+#define MMC0_PRE_RATIO		0x0
+#define MMC1_RATIO		0xF
+#define MMC1_PRE_RATIO		0x0
+#define CLK_DIV_FSYS1_VAL	((MMC1_PRE_RATIO << 24) \
+				| (MMC1_RATIO << 16) \
+				| (MMC0_PRE_RATIO << 8) \
+				| (MMC0_RATIO << 0))
+
+/* CLK_DIV_FSYS2 */
+#define MMC2_RATIO		0xF
+#define MMC2_PRE_RATIO		0x0
+#define MMC3_RATIO		0xF
+#define MMC3_PRE_RATIO		0x0
+#define CLK_DIV_FSYS2_VAL	((MMC3_PRE_RATIO << 24) \
+				| (MMC3_RATIO << 16) \
+				| (MMC2_PRE_RATIO << 8) \
+				| (MMC2_RATIO << 0))
+
+/* CLK_DIV_FSYS3 */
+#define MMC4_RATIO		0xF
+#define MMC4_PRE_RATIO		0x0
+#define CLK_DIV_FSYS3_VAL	((MMC4_PRE_RATIO << 8) \
+				| (MMC4_RATIO << 0))
+
+/* CLK_SRC_PERIL0 */
+#define UART_SEL_XXTI		0
+#define UART_SEL_XUSBXTI	1
+#define UART_SEL_SCLK_HDMI24M	2
+#define UART_SEL_SCLK_USBPHY0	3
+#define UART_SEL_SCLK_USBPHY1	4
+#define UART_SEL_SCLK_HDMIPHY	5
+#define UART_SEL_SCLKMPLL	6
+#define UART_SEL_SCLKEPLL	7
+#define UART_SEL_SCLKVPLL	8
+
+#define UART0_SEL		UART_SEL_SCLKMPLL
+#define UART1_SEL		UART_SEL_SCLKMPLL
+#define UART2_SEL		UART_SEL_SCLKMPLL
+#define UART3_SEL		UART_SEL_SCLKMPLL
+#define UART4_SEL		UART_SEL_SCLKMPLL
+#define CLK_SRC_PERIL0_VAL	((UART4_SEL << 16) \
+				| (UART3_SEL << 12) \
+				| (UART2_SEL << 8) \
+				| (UART1_SEL << 4) \
+				| (UART0_SEL << 0))
+
+/* SCLK_UART[0-4] = MOUTUART[0-4]/(UART[0-4]_RATIO + 1) */
+/* CLK_DIV_PERIL0 */
+#define UART0_RATIO		7
+#define UART1_RATIO		7
+#define UART2_RATIO		7
+#define UART3_RATIO		7
+#define UART4_RATIO		7
+#define CLK_DIV_PERIL0_VAL	((UART4_RATIO << 16) \
+				| (UART3_RATIO << 12) \
+				| (UART2_RATIO << 8) \
+				| (UART1_RATIO << 4) \
+				| (UART0_RATIO << 0))
+
+/* CLK_SRC_LCD0 */
+#define FIMD_SEL_SCLKMPLL	6
+#define MDNIE0_SEL_XUSBXTI	1
+#define MDNIE_PWM0_SEL_XUSBXTI	1
+#define MIPI0_SEL_XUSBXTI	1
+#define CLK_SRC_LCD0_VAL	((MIPI0_SEL_XUSBXTI << 12) \
+				| (MDNIE_PWM0_SEL_XUSBXTI << 8) \
+				| (MDNIE0_SEL_XUSBXTI << 4) \
+				| (FIMD_SEL_SCLKMPLL << 0))
+
+/* Required period to generate a stable clock output */
+/* PLL_LOCK_TIME */
+#define APLL_LOCK_VAL		0x3E8
+#define MPLL_LOCK_VAL		0x2F1
+#define EPLL_LOCK_VAL		0x2321
+#define VPLL_LOCK_VAL		0x2321
+#define PLL_LOCKTIME		0x1C20
+
+/* PLL Values */
+#define DISABLE			0
+#define ENABLE			1
+#define SET_PLL(mdiv, pdiv, sdiv)	((ENABLE << 31)\
+					| (mdiv << 16) \
+					| (pdiv << 8) \
+					| (sdiv << 0))
+
+/* APLL_CON0 */
+#define APLL_MDIV		0x7D
+#define APLL_PDIV		0x3
+#define APLL_SDIV		0x0
+#define APLL_CON0_VAL		SET_PLL(APLL_MDIV, APLL_PDIV, APLL_SDIV)
+
+/* APLL_CON1 */
+#define APLL_AFC_ENB		0x8
+#define APLL_AFC		0x38
+#define APLL_CON1_VAL		((APLL_AFC_ENB << 20) | (APLL_AFC << 8))
+
+/* MPLL_CON0 */
+#define MPLL_MDIV		0x64
+#define MPLL_PDIV		0x3
+#define MPLL_SDIV		0x0
+#define MPLL_CON0_VAL		SET_PLL(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)
+
+/* MPLL_CON1 */
+#define MPLL_AFC_ENB		0x8
+#define MPLL_AFC		0x38
+#define MPLL_CON1_VAL		((MPLL_AFC_ENB << 20) | (MPLL_AFC << 8))
+
+/* EPLL_CON0 */
+#define EPLL_MDIV		0x40
+#define EPLL_PDIV		0x2
+#define EPLL_SDIV		0x3
+#define EPLL_CON0_VAL		SET_PLL(EPLL_MDIV, EPLL_PDIV, EPLL_SDIV)
+
+/* EPLL_CON1 */
+#define EPLL_K			0x66010000
+#define EPLL_CON1_VAL		(EPLL_K >> 0)
+#define EPLL_CON2_VAL   0x00000080
+
+/* VPLL_CON0 */
+#define VPLL_MDIV		0x48
+#define VPLL_PDIV		0x2
+#define VPLL_SDIV		0x3
+#define VPLL_CON0_VAL		SET_PLL(VPLL_MDIV, VPLL_PDIV, VPLL_SDIV)
+
+/* VPLL_CON1 */
+#define VPLL_SEL_PF_DN_SPREAD	0x0
+#define VPLL_SEL_PF_UP_SPREAD	0x1
+#define VPLL_SEL_PF_CT_SPREAD	0x3
+#define VPLL_MRR		0x6
+#define VPLL_MFR		0x1
+#define VPLL_K			0x000
+#define VPLL_CON1_VAL		((VPLL_SEL_PF_CT_SPREAD << 29) \
+				| (VPLL_MRR << 24) \
+				| (VPLL_MFR << 16) \
+				| (VPLL_K << 0))
+#define VPLL_CON2_VAL   0x00000080
+/*
+ * UART GPIO_A0/GPIO_A1 Control Register Value
+ * 0x2: UART Function
+ */
+#define EXYNOS4_GPIO_A0_CON_VAL	0x22222222
+#define EXYNOS4_GPIO_A1_CON_VAL	0x222222
+
+/* ULCON: UART Line Control Value 8N1 */
+#define WORD_LEN_5_BIT		0x00
+#define WORD_LEN_6_BIT		0x01
+#define WORD_LEN_7_BIT		0x02
+#define WORD_LEN_8_BIT		0x03
+
+#define STOP_BIT_1		0x00
+#define STOP_BIT_2		0x01
+
+#define NO_PARITY			0x00
+#define ODD_PARITY			0x4
+#define EVEN_PARITY			0x5
+#define FORCED_PARITY_CHECK_AS_1	0x6
+#define FORCED_PARITY_CHECK_AS_0	0x7
+
+#define INFRAMODE_NORMAL		0x00
+#define INFRAMODE_INFRARED		0x01
+
+#define ULCON_VAL		((INFRAMODE_NORMAL << 6) \
+				| (NO_PARITY << 3) \
+				| (STOP_BIT_1 << 2) \
+				| (WORD_LEN_8_BIT << 0))
+
+/*
+ * UCON: UART Control Value
+ * Tx_interrupt Type: Level
+ * Rx_interrupt Type: Level
+ * Rx Timeout Enabled: Yes
+ * Rx-Error Atatus_Int Enable: Yes
+ * Loop_Back: No
+ * Break Signal: No
+ * Transmit mode : Interrupt request/polling
+ * Receive mode : Interrupt request/polling
+ */
+#define TX_PULSE_INTERRUPT	0
+#define TX_LEVEL_INTERRUPT	1
+#define RX_PULSE_INTERRUPT	0
+#define RX_LEVEL_INTERRUPT	1
+
+#define RX_TIME_OUT		ENABLE
+#define RX_ERROR_STATE_INT_ENB	ENABLE
+#define LOOP_BACK		DISABLE
+#define BREAK_SIGNAL		DISABLE
+
+#define TX_MODE_DISABLED	0X00
+#define TX_MODE_IRQ_OR_POLL	0X01
+#define TX_MODE_DMA		0X02
+
+#define RX_MODE_DISABLED	0X00
+#define RX_MODE_IRQ_OR_POLL	0X01
+#define RX_MODE_DMA		0X02
+
+#define UCON_VAL		((TX_LEVEL_INTERRUPT << 9) \
+				| (RX_LEVEL_INTERRUPT << 8) \
+				| (RX_TIME_OUT << 7) \
+				| (RX_ERROR_STATE_INT_ENB << 6) \
+				| (LOOP_BACK << 5) \
+				| (BREAK_SIGNAL << 4) \
+				| (TX_MODE_IRQ_OR_POLL << 2) \
+				| (RX_MODE_IRQ_OR_POLL << 0))
+
+/*
+ * UFCON: UART FIFO Control Value
+ * Tx FIFO Trigger LEVEL: 2 Bytes (001)
+ * Rx FIFO Trigger LEVEL: 2 Bytes (001)
+ * Tx Fifo Reset: No
+ * Rx Fifo Reset: No
+ * FIFO Enable: Yes
+ */
+#define TX_FIFO_TRIGGER_LEVEL_0_BYTES	0x00
+#define TX_FIFO_TRIGGER_LEVEL_2_BYTES	0x1
+#define TX_FIFO_TRIGGER_LEVEL_4_BYTES	0x2
+#define TX_FIFO_TRIGGER_LEVEL_6_BYTES	0x3
+#define TX_FIFO_TRIGGER_LEVEL_8_BYTES	0x4
+#define TX_FIFO_TRIGGER_LEVEL_10_BYTES	0x5
+#define TX_FIFO_TRIGGER_LEVEL_12_BYTES	0x6
+#define TX_FIFO_TRIGGER_LEVEL_14_BYTES	0x7
+
+#define RX_FIFO_TRIGGER_LEVEL_2_BYTES	0x0
+#define RX_FIFO_TRIGGER_LEVEL_4_BYTES	0x1
+#define RX_FIFO_TRIGGER_LEVEL_6_BYTES	0x2
+#define RX_FIFO_TRIGGER_LEVEL_8_BYTES	0x3
+#define RX_FIFO_TRIGGER_LEVEL_10_BYTES	0x4
+#define RX_FIFO_TRIGGER_LEVEL_12_BYTES	0x5
+#define RX_FIFO_TRIGGER_LEVEL_14_BYTES	0x6
+#define RX_FIFO_TRIGGER_LEVEL_16_BYTES	0x7
+
+#define TX_FIFO_TRIGGER_LEVEL		TX_FIFO_TRIGGER_LEVEL_2_BYTES
+#define RX_FIFO_TRIGGER_LEVEL		RX_FIFO_TRIGGER_LEVEL_4_BYTES
+#define TX_FIFO_RESET			DISABLE
+#define RX_FIFO_RESET			DISABLE
+#define FIFO_ENABLE			ENABLE
+#define UFCON_VAL			((TX_FIFO_TRIGGER_LEVEL << 8) \
+					| (RX_FIFO_TRIGGER_LEVEL << 4) \
+					| (TX_FIFO_RESET << 2) \
+					| (RX_FIFO_RESET << 1) \
+					| (FIFO_ENABLE << 0))
+/*
+ * Baud Rate Division Value
+ * 115200 BAUD:
+ * UBRDIV_VAL = (SCLK_UART/DIVUART)/((115200 * 16) - 1)
+ * UBRDIV_VAL = (800 MHz/8)/((115200 * 16) - 1)
+ */
+//#define UBRDIV_VAL		0x2B
+#define UBRDIV_VAL		0x35
+
+/*
+ * Fractional Part of Baud Rate Divisor:
+ * 115200 BAUD:
+ * UBRFRACVAL = ((((SCLK_UART/DIVUART*10/(115200*16) -10))%10)*16/10)
+ * UBRFRACVAL = ((((800MHz/8*10/(115200*16) -10))%10)*16/10)
+ */
+//#define UFRACVAL_VAL		0xC
+#define UFRACVAL_VAL		0x4
+
+/*
+ * TZPC Register Value :
+ * R0SIZE: 0x0 : Size of secured ram
+ */
+#define R0SIZE			0x0
+
+/*
+ * TZPC Decode Protection Register Value :
+ * DECPROTXSET: 0xFF : Set Decode region to non-secure
+ */
+#define DECPROTXSET		0xFF
+
+/* PS_HOLD: Data Hight, Output En */
+#define BIT_DAT             8
+#define BIT_EN              9
+#define EXYNOS4_PS_HOLD_CON_VAL     (0x1 << BIT_DAT | 0x1 << BIT_EN)
+
+#endif
diff --git a/board/hardkernel/odroidx/spl_boot.c b/board/hardkernel/odroidx/spl_boot.c
new file mode 100644
index 0000000..127cb1d
--- /dev/null
+++ b/board/hardkernel/odroidx/spl_boot.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2013  Hardkernel Co.,LTD.
+ * Hakjoo Kim <ruppi.kim@hardkernel.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include<common.h>
+#include<config.h>
+
+enum boot_mode {
+    BOOT_MODE_MMCSD = 4,
+    BOOT_MODE_EMMC = 6,
+    BOOT_MODE_EMMC_4_4 = 0x8,
+    BOOT_MODE_OM = 32,
+    BOOT_MODE_USB,
+};
+
+/*
+* Copy U-boot from mmc to RAM:
+* COPY_BL2_FNPTR_ADDR: Address in iRAM, which Contains
+* Pointer to API (Data transfer from mmc to ram)
+*/
+void copy_uboot_to_ram(void)
+{
+	u32 (*copy_bl2)(u32, u32, u32)  = (void *) *(u32 *)COPY_BL2_FNPTR_ADDR;
+
+	copy_bl2(BL2_START_OFFSET, BL2_SIZE_BLOC_COUNT, CONFIG_SYS_TEXT_BASE);
+}
+
+void board_init_f(unsigned long bootflag)
+{
+	__attribute__((noreturn)) void (*uboot)(void);
+	copy_uboot_to_ram();
+
+	/* Jump to U-Boot image */
+	uboot = (void *)CONFIG_SYS_TEXT_BASE;
+	(*uboot)();
+	/* Never returns Here */
+}
+
+/* Place Holders */
+void board_init_r(gd_t *id, ulong dest_addr)
+{
+	/* Function attribute is no-return */
+	/* This Function never executes */
+	while (1)
+		;
+}
+
+void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3) { }
diff --git a/board/hardkernel/odroidx/tools/mkodroidx_image.c b/board/hardkernel/odroidx/tools/mkodroidx_image.c
new file mode 100644
index 0000000..1a51913
--- /dev/null
+++ b/board/hardkernel/odroidx/tools/mkodroidx_image.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#define CHECKSUM_OFFSET		(14*1024-4)
+#define BUFSIZE			(16*1024)
+#define FILE_PERM		(S_IRUSR | S_IWUSR | S_IRGRP \
+				| S_IWGRP | S_IROTH | S_IWOTH)
+/*
+* Requirement:
+* IROM code reads first 14K bytes from boot device.
+* It then calculates the checksum of 14K-4 bytes and compare with data at
+* 14K-4 offset.
+*
+* This function takes two filenames:
+* IN  "u-boot-spl.bin" and
+* OUT "u-boot-mmc-spl.bin" as filenames.
+* It reads the "u-boot-spl.bin" in 16K buffer.
+* It calculates checksum of 14K-4 Bytes and stores at 14K-4 offset in buffer.
+* It writes the buffer to "u-boot-mmc-spl.bin" file.
+*/
+
+int main(int argc, char **argv)
+{
+	int i, len;
+	unsigned char buffer[BUFSIZE] = {0};
+	int ifd, ofd;
+	unsigned int checksum = 0, count;
+
+	if (argc != 3) {
+		printf(" %d Wrong number of arguments\n", argc);
+		exit(EXIT_FAILURE);
+	}
+
+	ifd = open(argv[1], O_RDONLY);
+	if (ifd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	ofd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, FILE_PERM);
+	if (ifd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+		if (ifd)
+			close(ifd);
+		exit(EXIT_FAILURE);
+	}
+
+	len = lseek(ifd, 0, SEEK_END);
+	lseek(ifd, 0, SEEK_SET);
+
+	count = (len < CHECKSUM_OFFSET) ? len : CHECKSUM_OFFSET;
+
+	if (read(ifd, buffer, count) != count) {
+		fprintf(stderr, "%s: Can't read %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+
+	for (i = 0, checksum = 0; i < CHECKSUM_OFFSET; i++)
+		checksum += buffer[i];
+
+	memcpy(&buffer[CHECKSUM_OFFSET], &checksum, sizeof(checksum));
+
+	if (write(ofd, buffer, BUFSIZE) != BUFSIZE) {
+		fprintf(stderr, "%s: Can't write %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+
+	if (ifd)
+		close(ifd);
+	if (ofd)
+		close(ofd);
+
+	return EXIT_SUCCESS;
+}
diff --git a/boards.cfg b/boards.cfg
index fdb84ad..f65baa4 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -252,7 +252,9 @@ omap5_evm                    arm         armv7       omap5_evm           ti		oma
 s5p_goni                     arm         armv7       goni                samsung        s5pc1xx
 smdkc100                     arm         armv7       smdkc100            samsung        s5pc1xx
 origen			     arm	 armv7	     origen		 samsung	exynos
+odroidx			             arm	     armv7	     odroidx	         hardkernel	    exynos
 s5pc210_universal            arm         armv7       universal_c210      samsung        exynos
+smdk4412		     arm	 armv7	     smdk4412		 hardkernel	exynos
 smdk5250		     arm	 armv7	     smdk5250		 samsung	exynos
 smdkv310		     arm	 armv7	     smdkv310		 samsung	exynos
 trats                        arm         armv7       trats               samsung        exynos
diff --git a/drivers/i2c/s3c24x0_i2c.c b/drivers/i2c/s3c24x0_i2c.c
index 9bc4c7f..dc79aa2 100644
--- a/drivers/i2c/s3c24x0_i2c.c
+++ b/drivers/i2c/s3c24x0_i2c.c
@@ -27,7 +27,7 @@
  */
 
 #include <common.h>
-#ifdef CONFIG_EXYNOS5
+#if defined CONFIG_EXYNOS5 || defined CONFIG_EXYNOS4
 #include <asm/arch/clk.h>
 #include <asm/arch/cpu.h>
 #else
@@ -62,7 +62,7 @@
 
 static unsigned int g_current_bus;	/* Stores Current I2C Bus */
 
-#ifndef CONFIG_EXYNOS5
+#if !defined  CONFIG_EXYNOS5 && !defined CONFIG_EXYNOS4
 static int GetI2CSDA(void)
 {
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
@@ -121,7 +121,7 @@ static void ReadWriteByte(struct s3c24x0_i2c *i2c)
 
 static struct s3c24x0_i2c *get_base_i2c(void)
 {
-#ifdef CONFIG_EXYNOS5
+#if defined CONFIG_EXYNOS5 || defined CONFIG_EXYNOS4
 	struct s3c24x0_i2c *i2c = (struct s3c24x0_i2c *)(samsung_get_base_i2c()
 							+ (EXYNOS5_I2C_SPACING
 							* g_current_bus));
@@ -134,7 +134,7 @@ static struct s3c24x0_i2c *get_base_i2c(void)
 static void i2c_ch_init(struct s3c24x0_i2c *i2c, int speed, int slaveadd)
 {
 	ulong freq, pres = 16, div;
-#ifdef CONFIG_EXYNOS5
+#if defined CONFIG_EXYNOS5 || defined CONFIG_EXYNOS4
 	freq = get_i2c_clk();
 #else
 	freq = get_PCLK();
@@ -188,7 +188,7 @@ unsigned int i2c_get_bus_num(void)
 void i2c_init(int speed, int slaveadd)
 {
 	struct s3c24x0_i2c *i2c;
-#ifndef CONFIG_EXYNOS5
+#if !defined  CONFIG_EXYNOS5 && !defined CONFIG_EXYNOS4
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
 #endif
 	int i;
@@ -204,7 +204,7 @@ void i2c_init(int speed, int slaveadd)
 		i--;
 	}
 
-#ifndef CONFIG_EXYNOS5
+#if !defined  CONFIG_EXYNOS5 && !defined CONFIG_EXYNOS4
 	if ((readl(&i2c->iicstat) & I2CSTAT_BSY) || GetI2CSDA() == 0) {
 #ifdef CONFIG_S3C2410
 		ulong old_gpecon = readl(&gpio->gpecon);
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 271463c..9fac190 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -39,6 +39,7 @@ COBJS-$(CONFIG_DIALOG_PMIC) += pmic_dialog.o
 COBJS-$(CONFIG_PMIC_FSL) += pmic_fsl.o
 COBJS-$(CONFIG_PMIC_I2C) += pmic_i2c.o
 COBJS-$(CONFIG_PMIC_SPI) += pmic_spi.o
+COBJS-$(CONFIG_PMIC_MAX77686) += pmic_max77686.o
 COBJS-$(CONFIG_PMIC_MAX8998) += pmic_max8998.o
 COBJS-$(CONFIG_PMIC_MAX8997) += pmic_max8997.o
 
diff --git a/drivers/misc/pmic_max77686.c b/drivers/misc/pmic_max77686.c
new file mode 100644
index 0000000..36f7f4d
--- /dev/null
+++ b/drivers/misc/pmic_max77686.c
@@ -0,0 +1,42 @@
+/*
+ *  Copyright (C) 2012 Samsung Electronics
+ *  Rajeshwari Shinde <rajeshwari.s@samsung.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pmic.h>
+#include <max77686_pmic.h>
+
+int pmic_init(void)
+{
+	struct pmic *p = get_pmic();
+	static const char name[] = "MAX77686_PMIC";
+
+	puts("Board PMIC init\n");
+	p->name = name;
+	p->interface = PMIC_I2C;
+	p->number_of_regs = PMIC_NUM_OF_REGS;
+	p->hw.i2c.addr = MAX77686_I2C_ADDR;
+	p->hw.i2c.tx_num = 1;
+	p->bus = I2C_PMIC;
+
+	return 0;
+}
diff --git a/include/configs/odroidx.h b/include/configs/odroidx.h
new file mode 100644
index 0000000..a0174e5
--- /dev/null
+++ b/include/configs/odroidx.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2013  Hardkernel Co.,LTD.
+ * Hakjoo Kim <ruppi.kim@hardkernel.com>
+ *
+ * Configuration settings for the Hardkernel ODROID-X (EXYNOS4412) board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* High Level Configuration Options */
+#define CONFIG_SAMSUNG			/* in a SAMSUNG core */
+#define CONFIG_S5P			/* S5P Family */
+#define CONFIG_EXYNOS4			/* which is in a Exynos4 Family */
+#define CONFIG_EXYNOS4412		/* which is in a Exynos4412 */
+#define CONFIG_ODROIDX			/* which is in a ODROID-X */
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* Keep L2 Cache Disabled */
+#define CONFIG_SYS_DCACHE_OFF
+
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define CONFIG_SYS_TEXT_BASE		0x43E00000
+
+/* input clock of PLL: ODROID-X has 24MHz input clock */
+#define CONFIG_SYS_CLK_FREQ		24000000
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_EDITING
+
+/* MACH_TYPE_ODROIDX macro will be removed once added to mach-types */
+#define MACH_TYPE_ODROIDX		4289
+#define CONFIG_MACH_TYPE		MACH_TYPE_ODROIDX
+
+/* Power Down Modes */
+#define S5P_CHECK_SLEEP			0x00000BAD
+#define S5P_CHECK_DIDLE			0xBAD00000
+#define S5P_CHECK_LPA			0xABAD0000
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (1 << 20))
+
+/* select serial console configuration */
+#define CONFIG_SERIAL_MULTI
+#define CONFIG_SERIAL1          1	/* use SERIAL 1 */
+#define CONFIG_BAUDRATE			115200
+#define EXYNOS4_DEFAULT_UART_OFFSET	0x010000
+
+#define TZPC_BASE_OFFSET		0x10000
+
+/* SD/MMC configuration */
+#define CONFIG_GENERIC_MMC
+#define CONFIG_MMC
+#define CONFIG_SDHCI
+#define CONFIG_S5P_SDHCI
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+/* PWM */
+#define CONFIG_PWM
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/* Command definition*/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_NET
+
+#define CONFIG_BOOTDELAY		3
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+/* USB */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_EXYNOS
+#define CONFIG_USB_STORAGE
+
+/* MMC SPL */
+#define CONFIG_SPL
+#define COPY_BL2_FNPTR_ADDR	0x02020030
+
+#define CONFIG_BOOTCOMMAND	"mmc read 40007000 451 2000; bootm 40007000"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser	*/
+#define CONFIG_SYS_PROMPT		"ODROIDX # "
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		384	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttySAC1,115200n8\0"
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x5E00000)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x3E00000)
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_RD_LVL
+
+/* Stack sizes */
+#define CONFIG_STACKSIZE		(256 << 10)	/* 256KB */
+
+#define CONFIG_NR_DRAM_BANKS	4
+#define SDRAM_BANK_SIZE		(256UL << 20UL)	/* 256 MB */
+#define PHYS_SDRAM_1		CONFIG_SYS_SDRAM_BASE
+#define PHYS_SDRAM_1_SIZE	SDRAM_BANK_SIZE
+#define PHYS_SDRAM_2		(CONFIG_SYS_SDRAM_BASE + SDRAM_BANK_SIZE)
+#define PHYS_SDRAM_2_SIZE	SDRAM_BANK_SIZE
+#define PHYS_SDRAM_3		(CONFIG_SYS_SDRAM_BASE + (2 * SDRAM_BANK_SIZE))
+#define PHYS_SDRAM_3_SIZE	SDRAM_BANK_SIZE
+#define PHYS_SDRAM_4		(CONFIG_SYS_SDRAM_BASE + (3 * SDRAM_BANK_SIZE))
+#define PHYS_SDRAM_4_SIZE	SDRAM_BANK_SIZE
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+#undef CONFIG_CMD_IMLS
+#define CONFIG_IDENT_STRING		" for ODROIDX"
+
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#define CONFIG_SECURE_BL1_ONLY
+
+/* Secure FW size configuration */
+#ifdef	CONFIG_SECURE_BL1_ONLY
+#define	CONFIG_SEC_FW_SIZE		(8 << 10)	/* 8KB */
+#else
+#define	CONFIG_SEC_FW_SIZE		0
+#endif
+
+/* Configuration of BL1, BL2, ENV Blocks on mmc */
+#define CONFIG_RES_BLOCK_SIZE	(512)
+#define CONFIG_BL1_SIZE		(16 << 10) /*16 K reserved for BL1*/
+#define	CONFIG_BL2_SIZE		(512UL << 10UL)	/* 512 KB */
+#define CONFIG_ENV_SIZE		(16 << 10)	/* 16 KB */
+
+#define CONFIG_BL1_OFFSET	(CONFIG_RES_BLOCK_SIZE + CONFIG_SEC_FW_SIZE)
+#define CONFIG_BL2_OFFSET	(CONFIG_BL1_OFFSET + CONFIG_BL1_SIZE)
+#define CONFIG_ENV_OFFSET	(CONFIG_BL2_OFFSET + CONFIG_BL2_SIZE)
+
+/* U-boot copy size from boot Media to DRAM.*/
+#define BL2_START_OFFSET	(CONFIG_BL2_OFFSET/512)
+#define BL2_SIZE_BLOC_COUNT	(CONFIG_BL2_SIZE/512)
+#define CONFIG_DOS_PARTITION
+
+#define OM_STAT	(0x1f << 1)
+#define CONFIG_IRAM_STACK	0x02060000
+
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR - 0x1000000)
+
+/* I2C */
+#define CONFIG_SYS_I2C_INIT_BOARD
+#define CONFIG_HARD_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C_SPEED	100000		/* 100 Kbps */
+#define CONFIG_DRIVER_S3C24X0_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_MAX_I2C_NUM	2
+#define CONFIG_SYS_I2C_SLAVE    0x0
+
+/* PMIC */
+
+#define CONFIG_PMIC
+#define CONFIG_PMIC_I2C
+#define CONFIG_PMIC_MAX77686
+
+/* Ethernet Controllor Driver */
+#ifdef CONFIG_CMD_NET
+#define CONFIG_SMC911X
+#define CONFIG_SMC911X_BASE		0x5000000
+#define CONFIG_SMC911X_16_BIT
+#define CONFIG_ENV_SROM_BANK		1
+#endif /*CONFIG_CMD_NET*/
+
+/* Enable devicetree support */
+#define CONFIG_OF_LIBFDT
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_SYS_MAPPED_RAM_BASE	0xc0000000
+#define virt_to_phys(x)	virt_to_phy_s5pv310(x)
+#else
+#define CONFIG_SYS_MAPPED_RAM_BASE	CONFIG_SYS_SDRAM_BASE
+#define virt_to_phys(x)	(x)
+#endif
+
+#define CONFIG_PHY_UBOOT_BASE		CONFIG_SYS_SDRAM_BASE + 0x3e00000
+#define DEBUG
+#endif	/* __CONFIG_H */
diff --git a/include/max77686_pmic.h b/include/max77686_pmic.h
new file mode 100644
index 0000000..d949ace
--- /dev/null
+++ b/include/max77686_pmic.h
@@ -0,0 +1,158 @@
+/*
+ *  Copyright (C) 2012 Samsung Electronics
+ *  Rajeshwari Shinde <rajeshwari.s@samsung.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __MAX77686_H_
+#define __MAX77686_H_
+
+enum {
+	MAX77686_REG_PMIC_ID		= 0x0,
+	MAX77686_REG_PMIC_INTSRC,
+	MAX77686_REG_PMIC_INT1,
+	MAX77686_REG_PMIC_INT2,
+	MAX77686_REG_PMIC_INT1MSK,
+	MAX77686_REG_PMIC_INT2MSK,
+
+	MAX77686_REG_PMIC_STATUS1,
+	MAX77686_REG_PMIC_STATUS2,
+
+	MAX77686_REG_PMIC_PWRON,
+	MAX77686_REG_PMIC_ONOFFDELAY,
+	MAX77686_REG_PMIC_MRSTB,
+
+	MAX77686_REG_PMIC_BUCK1CRTL	= 0x10,
+	MAX77686_REG_PMIC_BUCK1OUT,
+	MAX77686_REG_PMIC_BUCK2CTRL1,
+	MAX77686_REG_PMIC_BUCK234FREQ,
+	MAX77686_REG_PMIC_BUCK2DVS1,
+	MAX77686_REG_PMIC_BUCK2DVS2,
+	MAX77686_REG_PMIC_BUCK2DVS3,
+	MAX77686_REG_PMIC_BUCK2DVS4,
+	MAX77686_REG_PMIC_BUCK2DVS5,
+	MAX77686_REG_PMIC_BUCK2DVS6,
+	MAX77686_REG_PMIC_BUCK2DVS7,
+	MAX77686_REG_PMIC_BUCK2DVS8,
+	MAX77686_REG_PMIC_BUCK3CTRL,
+	MAX77686_REG_PMIC_BUCK3DVS1,
+	MAX77686_REG_PMIC_BUCK3DVS2,
+	MAX77686_REG_PMIC_BUCK3DVS3,
+	MAX77686_REG_PMIC_BUCK3DVS4,
+	MAX77686_REG_PMIC_BUCK3DVS5,
+	MAX77686_REG_PMIC_BUCK3DVS6,
+	MAX77686_REG_PMIC_BUCK3DVS7,
+	MAX77686_REG_PMIC_BUCK3DVS8,
+	MAX77686_REG_PMIC_BUCK4CTRL1,
+	MAX77686_REG_PMIC_BUCK4DVS1	= 0x28,
+	MAX77686_REG_PMIC_BUCK4DVS2,
+	MAX77686_REG_PMIC_BUCK4DVS3,
+	MAX77686_REG_PMIC_BUCK4DVS4,
+	MAX77686_REG_PMIC_BUCK4DVS5,
+	MAX77686_REG_PMIC_BUCK4DVS6,
+	MAX77686_REG_PMIC_BUCK4DVS7,
+	MAX77686_REG_PMIC_BUCK4DVS8,
+	MAX77686_REG_PMIC_BUCK5CTRL,
+	MAX77686_REG_PMIC_BUCK5OUT,
+	MAX77686_REG_PMIC_BUCK6CRTL,
+	MAX77686_REG_PMIC_BUCK6OUT,
+	MAX77686_REG_PMIC_BUCK7CRTL,
+	MAX77686_REG_PMIC_BUCK7OUT,
+	MAX77686_REG_PMIC_BUCK8CRTL,
+	MAX77686_REG_PMIC_BUCK8OUT,
+	MAX77686_REG_PMIC_BUCK9CRTL,
+	MAX77686_REG_PMIC_BUCK9OUT,
+
+	MAX77686_REG_PMIC_LDO1CTRL1	= 0x40,
+	MAX77686_REG_PMIC_LDO2CTRL1,
+	MAX77686_REG_PMIC_LDO3CTRL1,
+	MAX77686_REG_PMIC_LDO4CTRL1,
+	MAX77686_REG_PMIC_LDO5CTRL1,
+	MAX77686_REG_PMIC_LDO6CTRL1,
+	MAX77686_REG_PMIC_LDO7CTRL1,
+	MAX77686_REG_PMIC_LDO8CTRL1,
+	MAX77686_REG_PMIC_LDO9CTRL1,
+	MAX77686_REG_PMIC_LDO10CTRL1,
+	MAX77686_REG_PMIC_LDO11CTRL1,
+	MAX77686_REG_PMIC_LDO12CTRL1,
+	MAX77686_REG_PMIC_LDO13CTRL1,
+	MAX77686_REG_PMIC_LDO14CTRL1,
+	MAX77686_REG_PMIC_LDO15CTRL1,
+	MAX77686_REG_PMIC_LDO16CTRL1,
+	MAX77686_REG_PMIC_LDO17CTRL1,
+	MAX77686_REG_PMIC_LDO18CTRL1,
+	MAX77686_REG_PMIC_LDO19CTRL1,
+	MAX77686_REG_PMIC_LDO20CTRL1,
+	MAX77686_REG_PMIC_LDO21CTRL1,
+	MAX77686_REG_PMIC_LDO22CTRL1,
+	MAX77686_REG_PMIC_LDO23CTRL1,
+	MAX77686_REG_PMIC_LDO24CTRL1,
+	MAX77686_REG_PMIC_LDO25CTRL1,
+	MAX77686_REG_PMIC_LDO26CTRL1,
+	MAX77686_REG_PMIC_LDO1CTRL2,
+	MAX77686_REG_PMIC_LDO2CTRL2,
+	MAX77686_REG_PMIC_LDO3CTRL2,
+	MAX77686_REG_PMIC_LDO4CTRL2,
+	MAX77686_REG_PMIC_LDO5CTRL2,
+	MAX77686_REG_PMIC_LDO6CTRL2,
+	MAX77686_REG_PMIC_LDO7CTRL2,
+	MAX77686_REG_PMIC_LDO8CTRL2,
+	MAX77686_REG_PMIC_LDO9CTRL2,
+	MAX77686_REG_PMIC_LDO10CTRL2,
+	MAX77686_REG_PMIC_LDO11CTRL2,
+	MAX77686_REG_PMIC_LDO12CTRL2,
+	MAX77686_REG_PMIC_LDO13CTRL2,
+	MAX77686_REG_PMIC_LDO14CTRL2,
+	MAX77686_REG_PMIC_LDO15CTRL2,
+	MAX77686_REG_PMIC_LDO16CTRL2,
+	MAX77686_REG_PMIC_LDO17CTRL2,
+	MAX77686_REG_PMIC_LDO18CTRL2,
+	MAX77686_REG_PMIC_LDO19CTRL2,
+	MAX77686_REG_PMIC_LDO20CTRL2,
+	MAX77686_REG_PMIC_LDO21CTRL2,
+	MAX77686_REG_PMIC_LDO22CTRL2,
+	MAX77686_REG_PMIC_LDO23CTRL2,
+	MAX77686_REG_PMIC_LDO24CTRL2,
+	MAX77686_REG_PMIC_LDO25CTRL2,
+	MAX77686_REG_PMIC_LDO26CTRL2,
+
+	MAX77686_REG_PMIC_BBAT		= 0x7e,
+	MAX77686_REG_PMIC_32KHZ,
+
+	PMIC_NUM_OF_REGS,
+};
+
+/* I2C device address for pmic max77686 */
+#define MAX77686_I2C_ADDR (0x12 >> 1)
+
+enum {
+	REG_DISABLE = 0,
+	REG_ENABLE
+};
+
+enum {
+	LDO_OFF = 0,
+	LDO_ON,
+
+	DIS_LDO = (0x00 << 6),
+	EN_LDO = (0x3 << 6),
+};
+
+#endif /* __MAX77686_PMIC_H_ */
diff --git a/include/sdhci.h b/include/sdhci.h
index 9d37183..6ed19b0 100644
--- a/include/sdhci.h
+++ b/include/sdhci.h
@@ -191,7 +191,11 @@
 
 #define SDHCI_ADMA_ADDRESS	0x58
 
-/* 60-FB reserved */
+/* 60-FB reserved, 80 used to Exynos4412*/
+
+#if defined(EXYNOS4412)
+#define SDHCI_SDHCI_CONTROL2 0x80
+#endif
 
 #define SDHCI_SLOT_INT_STATUS	0xFC
 
-- 
1.7.10.4

