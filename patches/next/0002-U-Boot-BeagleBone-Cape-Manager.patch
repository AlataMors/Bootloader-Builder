From 983866fd82d41ec4113bf22462c8b5d16ca7c4c8 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Thu, 19 Jan 2017 16:58:56 -0600
Subject: [PATCH 2/2] U-Boot: BeagleBone Cape Manager

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/mach-omap2/am33xx/clock_am33xx.c |   1 +
 board/ti/am335x/board.c                   | 229 +++++++++++++++++++++++++++---
 board/ti/am335x/board.h                   |  17 +++
 board/ti/am335x/mux.c                     |  15 ++
 include/configs/ti_armv7_common.h         | 120 ++++++++++++++++
 include/configs/ti_armv7_omap.h           |   3 +
 6 files changed, 365 insertions(+), 20 deletions(-)

diff --git a/arch/arm/mach-omap2/am33xx/clock_am33xx.c b/arch/arm/mach-omap2/am33xx/clock_am33xx.c
index 7b841b2d55..119ca3d62c 100644
--- a/arch/arm/mach-omap2/am33xx/clock_am33xx.c
+++ b/arch/arm/mach-omap2/am33xx/clock_am33xx.c
@@ -145,6 +145,7 @@ void enable_basic_clocks(void)
 		&cmper->gpio2clkctrl,
 		&cmper->gpio3clkctrl,
 		&cmper->i2c1clkctrl,
+		&cmper->i2c2clkctrl,
 		&cmper->cpgmac0clkctrl,
 		&cmper->spi0clkctrl,
 		&cmrtc->rtcclkctrl,
diff --git a/board/ti/am335x/board.c b/board/ti/am335x/board.c
index b385de0447..884ddbbcb7 100644
--- a/board/ti/am335x/board.c
+++ b/board/ti/am335x/board.c
@@ -72,9 +72,212 @@ void do_board_detect(void)
 
 	if (ti_i2c_eeprom_am_get(-1, CONFIG_SYS_I2C_EEPROM_ADDR))
 		printf("ti_i2c_eeprom_init failed\n");
+
+	//hack-ish, needs to mux'ed early, in do_cape_detect was too late...
+	enable_i2c2_pin_mux();
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED2, CONFIG_SYS_OMAP24_I2C_SLAVE2);
 }
 #endif
 
+#define CAPE_EEPROM_ADDR0	0x54
+#define CAPE_EEPROM_ADDR1	0x55
+#define CAPE_EEPROM_ADDR2	0x56
+#define CAPE_EEPROM_ADDR3	0x57
+
+void write_hex (unsigned char i)
+{
+	char cc;
+
+	cc = i >> 4;
+	cc &= 0xf;
+	if (cc > 9)
+		serial_putc (cc + 55);
+	else
+		serial_putc (cc + 48);
+	cc = i & 0xf;
+	if (cc > 9)
+		serial_putc (cc + 55);
+	else
+		serial_putc (cc + 48);
+}
+
+static int probe_cape_eeprom(struct am335x_cape_eeprom_id *cape_header)
+{
+	unsigned char addr;
+	/* /lib/firmware/BB-CAPE-DISP-CT4-00A0.dtbo */
+	/* 14 + 16 + 1 + 4 + 5 = 40 */
+	char cape_overlay[40];
+	const char s[2] = ".";
+	char *token;
+
+	char virtual_emmc=0;
+	/* 1 -> TDA998x, 2 -> ADV7511 */
+	char virtual_video=0;
+	/* 1 -> Black Wireless, 2 -> Green Wireless */
+	char virtual_wireless=0;
+
+	char *name = NULL;
+
+	if (board_is_bone_lt()) {
+		puts("BeagleBone Black:\n");
+		virtual_emmc=1;
+		virtual_video=1;
+		virtual_wireless=0;
+		name = "A335BNLT";
+
+		if (!strncmp(board_ti_get_rev(), "BLA", 3)) {
+			puts("Model: BeagleBoard.org BeagleBone Blue:\n");
+			virtual_emmc=0;
+			virtual_video=0;
+			virtual_wireless=0;
+		}
+		if (!strncmp(board_ti_get_rev(), "BW", 2)) {
+			puts("Model: BeagleBoard.org BeagleBone Black Wireless:\n");
+			virtual_emmc=1;
+			virtual_video=1;
+			virtual_wireless=1;
+			name = "BBBW";
+		}
+		if (!strncmp(board_ti_get_rev(), "BBG", 3)) {
+			/* catches again in board_is_bbg1() */
+			//puts("Model: SeeedStudio BeagleBone Green:\n");
+			virtual_emmc=1;
+			virtual_video=0;
+			virtual_wireless=0;
+			name = "BBG1";
+		}
+		if (!strncmp(board_ti_get_rev(), "GW1", 3)) {
+			puts("Model: SeeedStudio BeagleBone Green Wireless:\n");
+			virtual_emmc=1;
+			virtual_video=0;
+			virtual_wireless=2;
+		}
+		if (!strncmp(board_ti_get_rev(), "AIA", 3)) {
+			puts("Model: Arrow BeagleBone Black Industrial:\n");
+			virtual_emmc=1;
+			virtual_video=2;
+			virtual_wireless=0;
+		}
+		if (!strncmp(board_ti_get_rev(), "EIA", 3)) {
+			puts("Model: Element14 BeagleBone Black Industrial:\n");
+			virtual_emmc=1;
+			virtual_video=1;
+			virtual_wireless=0;
+		}
+		if (!strncmp(board_ti_get_rev(), "SE", 2)) {
+			puts("Model: SanCloud BeagleBone Enhanced:\n");
+			virtual_emmc=1;
+			virtual_video=1;
+			virtual_wireless=0;
+		}
+		if (!strncmp(board_ti_get_rev(), "ME0", 3)) {
+			puts("Model: MENTOREL BeagleBone uSomIQ:\n");
+			virtual_emmc=1;
+			virtual_video=1;
+			virtual_wireless=0;
+		}
+		if (!strncmp(board_ti_get_rev(), "NAD", 3)) {
+			puts("Model: Neuromeka BeagleBone Air:\n");
+			virtual_emmc=1;
+			virtual_video=1;
+			virtual_wireless=0;
+		}
+	}
+
+	if (board_is_bbg1()) {
+		puts("Model: SeeedStudio BeagleBone Green:\n");
+		virtual_emmc=1;
+		virtual_video=0;
+		virtual_wireless=0;
+		name = "BBG1";
+	}
+
+	set_board_info_env(name);
+
+	i2c_set_bus_num(2);
+
+	for ( addr = CAPE_EEPROM_ADDR0; addr <= CAPE_EEPROM_ADDR3; addr++ ) {
+		if (i2c_probe(addr)) {
+			puts("BeagleBone: cape eeprom: i2c_probe: 0x");  write_hex(addr); puts(":\n");
+		} else {
+			/* read the eeprom using i2c */
+			if (i2c_read(addr, 0, 2, (uchar *)cape_header,
+				     sizeof(struct am335x_cape_eeprom_id))) {
+				puts("BeagleBone: cape eeprom: Could not read the EEPROM; something fundamentally"
+					" wrong on the I2C bus.\n");
+				return -EIO;
+			}
+
+			if (cape_header->header == 0xEE3355AA) {
+				strlcpy(cape_overlay, "/lib/firmware/", 14 + 1);
+
+				/* cape_header->part_number stop at [.] */
+				token = strtok(cape_header->part_number, s);
+				strncat(cape_overlay, token, 16);
+
+				strncat(cape_overlay, "-", 1);
+				strncat(cape_overlay, cape_header->version, 4);
+				strncat(cape_overlay, ".dtbo", 5);
+
+				puts("BeagleBone: cape eeprom: i2c_probe: 0x");
+				write_hex(addr);
+				printf(": %s\n", cape_overlay);
+
+				switch(addr)
+				{
+					case CAPE_EEPROM_ADDR0:
+						setenv("uboot_overlay_addr0", cape_overlay);
+						break;
+					case CAPE_EEPROM_ADDR1:
+						setenv("uboot_overlay_addr1", cape_overlay);
+						break;
+					case CAPE_EEPROM_ADDR2:
+						setenv("uboot_overlay_addr2", cape_overlay);
+						break;
+					case CAPE_EEPROM_ADDR3:
+						setenv("uboot_overlay_addr3", cape_overlay);
+						break;
+				}
+
+				virtual_emmc=0;
+				virtual_video=0;
+				virtual_wireless=0;
+			}
+		}
+	}
+
+	if (virtual_emmc == 1) {
+		setenv("uboot_emmc", "/lib/firmware/BB-BONE-eMMC1-01-00A0.dtbo");
+	}
+
+	if (virtual_video == 1) {
+		setenv("uboot_video", "/lib/firmware/BB-HDMI-TDA998x-00A0.dtbo");
+	}
+
+	if (virtual_video == 2) {
+		setenv("uboot_video", "/lib/firmware/BB-HDMI-ADV7511-00A0.dtbo");
+	}
+
+	if (virtual_wireless == 1) {
+		setenv("uboot_wireless", "/lib/firmware/BB-BBBW-WL1835-00A0.dtbo");
+	}
+
+	if (virtual_wireless == 2) {
+		setenv("uboot_wireless", "/lib/firmware/BB-BBGW-WL1835-00A0.dtbo");
+	}
+
+	i2c_set_bus_num(0);
+	return 0;
+}
+
+void do_cape_detect(void)
+{
+	struct am335x_cape_eeprom_id cape_header;
+
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED2, CONFIG_SYS_OMAP24_I2C_SLAVE2);
+	probe_cape_eeprom(&cape_header);
+}
+
 #ifndef CONFIG_DM_SERIAL
 struct serial_device *default_serial_console(void)
 {
@@ -667,26 +870,6 @@ int board_late_init(void)
 #endif
 
 #ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
-	char *name = NULL;
-
-	if (board_is_bone_lt()) {
-		puts("Board: BeagleBone Black\n");
-		name = "A335BNLT";
-		if (!strncmp(board_ti_get_rev(), "BW", 2)) {
-			puts("Model: BeagleBone Black Wireless\n");
-			name = "BBBW";
-		}
-		if (!strncmp(board_ti_get_rev(), "SE", 2)) {
-			puts("Model: SanCloud BeagleBone Enhanced\n");
-			name = "SBBE";
-		}
-	}
-
-	if (board_is_bbg1())
-		name = "BBG1";
-
-	set_board_info_env(name);
-
 	/*
 	 * Default FIT boot on HS devices. Non FIT images are not allowed
 	 * on HS devices.
@@ -728,6 +911,12 @@ int board_late_init(void)
 	}
 #endif
 
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+	do_cape_detect();
+#endif
+#endif
+
 	return 0;
 }
 #endif
diff --git a/board/ti/am335x/board.h b/board/ti/am335x/board.h
index 8e872bb1c7..05d713e228 100644
--- a/board/ti/am335x/board.h
+++ b/board/ti/am335x/board.h
@@ -11,6 +11,22 @@
 #ifndef _BOARD_H_
 #define _BOARD_H_
 
+struct am335x_cape_eeprom_id {
+	unsigned int header;
+	char eeprom_rev[2];
+	char board_name[32];
+	char version[4];
+	char manufacture[16];
+	char part_number[16];
+	char number_of_pins[2];
+	char serial_number[12];
+	char pin_usage[140];
+	char vdd_3v3exp[ 2];
+	char vdd_5v[ 2];
+	char sys_5v[2];
+	char dc_supplied[2];
+};
+
 /**
  * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
  * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
@@ -93,5 +109,6 @@ void enable_uart3_pin_mux(void);
 void enable_uart4_pin_mux(void);
 void enable_uart5_pin_mux(void);
 void enable_i2c0_pin_mux(void);
+void enable_i2c2_pin_mux(void);
 void enable_board_pin_mux(void);
 #endif
diff --git a/board/ti/am335x/mux.c b/board/ti/am335x/mux.c
index 6d65e99a1a..2ae077fb14 100644
--- a/board/ti/am335x/mux.c
+++ b/board/ti/am335x/mux.c
@@ -120,6 +120,14 @@ static struct module_pin_mux i2c1_pin_mux[] = {
 	{-1},
 };
 
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUP_EN | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
 static struct module_pin_mux spi0_pin_mux[] = {
 	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
 	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
@@ -304,6 +312,11 @@ void enable_i2c0_pin_mux(void)
 	configure_module_pin_mux(i2c0_pin_mux);
 }
 
+void enable_i2c2_pin_mux(void)
+{
+	configure_module_pin_mux(i2c2_pin_mux);
+}
+
 /*
  * The AM335x GP EVM, if daughter card(s) are connected, can have 8
  * different profiles.  These profiles determine what peripherals are
@@ -352,6 +365,7 @@ void enable_board_pin_mux(void)
 #else
 		configure_module_pin_mux(mmc1_pin_mux);
 #endif
+		configure_module_pin_mux(i2c2_pin_mux);
 	} else if (board_is_gp_evm()) {
 		/* General Purpose EVM */
 		unsigned short profile = detect_daughter_board_profile();
@@ -397,6 +411,7 @@ void enable_board_pin_mux(void)
 #else
 		configure_module_pin_mux(mmc1_pin_mux);
 #endif
+		configure_module_pin_mux(i2c2_pin_mux);
 	} else if (board_is_icev2()) {
 		configure_module_pin_mux(mmc0_pin_mux);
 		configure_module_pin_mux(gpio0_18_pin_mux);
diff --git a/include/configs/ti_armv7_common.h b/include/configs/ti_armv7_common.h
index 5ef1e8f18a..3500336caa 100644
--- a/include/configs/ti_armv7_common.h
+++ b/include/configs/ti_armv7_common.h
@@ -347,6 +347,126 @@
 					"fi;" \
 				"fi;" \
 			"fi; " \
+			"if test -n ${enable_uboot_overlays}; then " \
+				"setenv fdt_buffer 0x60000;" \
+				"if test -n ${uboot_fdt_buffer}; then " \
+					"setenv fdt_buffer ${uboot_fdt_buffer};" \
+				"fi;" \
+				"echo debug: [fdt_buffer=${fdt_buffer}] ... ;" \
+				"if test -n ${uboot_overlay_addr0}; then " \
+					"echo debug: [uboot_overlay_addr0=${uboot_overlay_addr0}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_overlay_addr0}; then " \
+						"echo loading ${uboot_overlay_addr0} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_overlay_addr0};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_overlay_addr0}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_overlay_addr1}; then " \
+					"echo debug: [uboot_overlay_addr1=${uboot_overlay_addr1}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_overlay_addr1}; then " \
+						"echo loading ${uboot_overlay_addr1} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_overlay_addr1};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_overlay_addr1}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_overlay_addr2}; then " \
+					"echo debug: [uboot_overlay_addr2=${uboot_overlay_addr2}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_overlay_addr2}; then " \
+						"echo loading ${uboot_overlay_addr2} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_overlay_addr2};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_overlay_addr2}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_overlay_addr3}; then " \
+					"echo debug: [uboot_overlay_addr3=${uboot_overlay_addr3}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_overlay_addr3}; then " \
+						"echo loading ${uboot_overlay_addr3} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_overlay_addr3};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_overlay_addr3}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_emmc}; then " \
+					"echo debug: [uboot_emmc=${uboot_emmc}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_emmc}; then " \
+						"echo loading ${uboot_emmc} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_emmc};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_emmc}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_video}; then " \
+					"echo debug: [uboot_video=${uboot_video}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_video}; then " \
+						"echo loading ${uboot_video} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_video};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_video}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${uboot_wireless}; then " \
+					"echo debug: [uboot_wireless=${uboot_wireless}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${uboot_wireless}; then " \
+						"echo loading ${uboot_wireless} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${uboot_wireless};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"setenv cape_uboot bone_capemgr.uboot_capemgr_enabled=1; " \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${uboot_wireless}]...;" \
+					"fi; " \
+				"fi;" \
+				"if test -n ${dtb_overlay}; then " \
+					"echo debug: [dtb_overlay=${dtb_overlay}] ... ;" \
+					"if test -e ${devtype} ${bootpart} ${dtb_overlay}; then " \
+						"echo loading ${dtb_overlay} ...;" \
+						"load ${devtype} ${bootpart} ${rdaddr} ${dtb_overlay};" \
+						"fdt addr ${fdtaddr};" \
+						"fdt resize ${fdt_buffer};" \
+						"fdt apply ${rdaddr};" \
+						"fdt resize ${fdt_buffer};" \
+					"else " \
+						"echo unable to find [${devtype} ${bootpart} ${dtb_overlay}]...;" \
+					"fi; " \
+				"fi;" \
+			"else " \
+				"echo add [enable_uboot_overlays=1] to /boot/uEnv.txt to enable...;" \
+			"fi;" \
 			"setenv rdfile initrd.img-${uname_r}; " \
 			"if test -e ${devtype} ${bootpart} ${bootdir}/${rdfile}; then " \
 				"echo loading ${bootdir}/${rdfile} ...; "\
diff --git a/include/configs/ti_armv7_omap.h b/include/configs/ti_armv7_omap.h
index 6d9d4b2d97..9c9e2266fc 100644
--- a/include/configs/ti_armv7_omap.h
+++ b/include/configs/ti_armv7_omap.h
@@ -20,6 +20,9 @@
 #define CONFIG_SYS_OMAP24_I2C_SLAVE	1
 #define CONFIG_SYS_I2C_OMAP24XX
 
+#define CONFIG_SYS_OMAP24_I2C_SPEED2	100000
+#define CONFIG_SYS_OMAP24_I2C_SLAVE2	1
+
 /* MMC/SD IP block */
 #define CONFIG_OMAP_HSMMC
 
-- 
2.11.0

